{"ast":null,"code":"import _inherits from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _createClass from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Injectable, NgModule, ChangeDetectionStrategy, ChangeDetectorRef, Component, EventEmitter, forwardRef, Inject, Input, Optional, Output, ViewChild, ViewEncapsulation, ElementRef, NgZone, InjectionToken, ViewContainerRef, Directive, Attribute, ContentChild, defineInjectable } from '@angular/core';\nimport { Subject, merge, Subscription, of } from 'rxjs';\nimport { take, filter } from 'rxjs/operators';\nimport { DOWN_ARROW, END, ENTER, HOME, LEFT_ARROW, PAGE_DOWN, PAGE_UP, RIGHT_ARROW, UP_ARROW, SPACE, ESCAPE } from '@angular/cdk/keycodes';\nimport { DateAdapter, MAT_DATE_FORMATS, mixinColor } from '@angular/material/core';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { ComponentPortal, PortalModule } from '@angular/cdk/portal';\nimport { animate, state, style, transition, trigger } from '@angular/animations';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { MatDialog, MatDialogModule } from '@angular/material/dialog';\nimport { NG_VALIDATORS, NG_VALUE_ACCESSOR, Validators } from '@angular/forms';\nimport { MatFormField } from '@angular/material/form-field';\nimport { MAT_INPUT_VALUE_ACCESSOR } from '@angular/material/input';\nimport { A11yModule } from '@angular/cdk/a11y';\nimport { MatButtonModule } from '@angular/material/button';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * \\@docs-private\n * @param {?} provider\n * @return {?}\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nimport * as ɵngcc2 from '@angular/material/core';\nimport * as ɵngcc3 from '@angular/cdk/bidi';\nimport * as ɵngcc4 from '@angular/material/button';\nimport * as ɵngcc5 from '@angular/cdk/a11y';\nimport * as ɵngcc6 from '@angular/cdk/portal';\nimport * as ɵngcc7 from '@angular/material/dialog';\nimport * as ɵngcc8 from '@angular/cdk/overlay';\nimport * as ɵngcc9 from '@angular/material/form-field';\nvar _c0 = [\"mat-calendar-body\", \"\"];\n\nfunction MatCalendarBody_tr_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"tr\", 2);\n    ɵngcc0.ɵɵelementStart(1, \"td\", 3);\n    ɵngcc0.ɵɵtext(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵstyleProp(\"padding-top\", 50 * ctx_r0.cellAspectRatio / ctx_r0.numCols, \"%\")(\"padding-bottom\", 50 * ctx_r0.cellAspectRatio / ctx_r0.numCols, \"%\");\n    ɵngcc0.ɵɵattribute(\"colspan\", ctx_r0.numCols);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r0.label);\n  }\n}\n\nfunction MatCalendarBody_tr_1_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"td\", 7);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r4 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵstyleProp(\"padding-top\", 50 * ctx_r4.cellAspectRatio / ctx_r4.numCols, \"%\")(\"padding-bottom\", 50 * ctx_r4.cellAspectRatio / ctx_r4.numCols, \"%\");\n    ɵngcc0.ɵɵattribute(\"colspan\", ctx_r4._firstRowOffset);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r4._firstRowOffset >= ctx_r4.labelMinRequiredCells ? ctx_r4.label : \"\");\n  }\n}\n\nfunction MatCalendarBody_tr_1_td_2_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r9 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"td\", 8);\n    ɵngcc0.ɵɵlistener(\"click\", function MatCalendarBody_tr_1_td_2_Template_td_click_0_listener() {\n      var restoredCtx = ɵngcc0.ɵɵrestoreView(_r9);\n      var item_r6 = restoredCtx.$implicit;\n      var ctx_r8 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r8._cellClicked(item_r6);\n    });\n    ɵngcc0.ɵɵelementStart(1, \"div\", 9);\n    ɵngcc0.ɵɵtext(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var item_r6 = ctx.$implicit;\n    var colIndex_r7 = ctx.index;\n    var rowIndex_r3 = ɵngcc0.ɵɵnextContext().index;\n    var ctx_r5 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵstyleProp(\"width\", 100 / ctx_r5.numCols, \"%\")(\"padding-top\", 50 * ctx_r5.cellAspectRatio / ctx_r5.numCols, \"%\")(\"padding-bottom\", 50 * ctx_r5.cellAspectRatio / ctx_r5.numCols, \"%\");\n    ɵngcc0.ɵɵclassProp(\"mat-calendar-body-disabled\", !item_r6.enabled)(\"mat-calendar-body-active\", ctx_r5._isActiveCell(rowIndex_r3, colIndex_r7));\n    ɵngcc0.ɵɵproperty(\"tabindex\", ctx_r5._isActiveCell(rowIndex_r3, colIndex_r7) ? 0 : -1);\n    ɵngcc0.ɵɵattribute(\"aria-label\", item_r6.ariaLabel)(\"aria-disabled\", !item_r6.enabled || null)(\"aria-selected\", ctx_r5.selectedValue === item_r6.value);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵclassProp(\"mat-calendar-body-selected\", ctx_r5.selectedValue === item_r6.value)(\"mat-calendar-body-today\", ctx_r5.todayValue === item_r6.value);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(item_r6.displayValue);\n  }\n}\n\nfunction MatCalendarBody_tr_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"tr\", 4);\n    ɵngcc0.ɵɵtemplate(1, MatCalendarBody_tr_1_td_1_Template, 2, 6, \"td\", 5);\n    ɵngcc0.ɵɵtemplate(2, MatCalendarBody_tr_1_td_2_Template, 3, 19, \"td\", 6);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var row_r2 = ctx.$implicit;\n    var rowIndex_r3 = ctx.index;\n    var ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", rowIndex_r3 === 0 && ctx_r1._firstRowOffset);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", row_r2);\n  }\n}\n\nfunction MatMonthView_th_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"th\");\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var day_r1 = ctx.$implicit;\n    ɵngcc0.ɵɵattribute(\"aria-label\", day_r1.long);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(day_r1.narrow);\n  }\n}\n\nvar _c1 = [\"*\"];\n\nfunction MatCalendar_ng_template_0_Template(rf, ctx) {}\n\nfunction MatCalendar_mat_month_view_2_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r5 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"mat-month-view\", 5);\n    ɵngcc0.ɵɵlistener(\"activeDateChange\", function MatCalendar_mat_month_view_2_Template_mat_month_view_activeDateChange_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r5);\n      var ctx_r4 = ɵngcc0.ɵɵnextContext();\n      return ctx_r4.activeDate = $event;\n    })(\"selectedChange\", function MatCalendar_mat_month_view_2_Template_mat_month_view_selectedChange_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r5);\n      var ctx_r6 = ɵngcc0.ɵɵnextContext();\n      return ctx_r6._dateSelected($event);\n    })(\"_userSelection\", function MatCalendar_mat_month_view_2_Template_mat_month_view__userSelection_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r5);\n      var ctx_r7 = ɵngcc0.ɵɵnextContext();\n      return ctx_r7._userSelected();\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"activeDate\", ctx_r1.activeDate)(\"selected\", ctx_r1.selected)(\"dateFilter\", ctx_r1.dateFilter)(\"maxDate\", ctx_r1.maxDate)(\"minDate\", ctx_r1.minDate);\n  }\n}\n\nfunction MatCalendar_mat_year_view_3_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r9 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"mat-year-view\", 6);\n    ɵngcc0.ɵɵlistener(\"activeDateChange\", function MatCalendar_mat_year_view_3_Template_mat_year_view_activeDateChange_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r9);\n      var ctx_r8 = ɵngcc0.ɵɵnextContext();\n      return ctx_r8.activeDate = $event;\n    })(\"monthSelected\", function MatCalendar_mat_year_view_3_Template_mat_year_view_monthSelected_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r9);\n      var ctx_r10 = ɵngcc0.ɵɵnextContext();\n      return ctx_r10._monthSelectedInYearView($event);\n    })(\"selectedChange\", function MatCalendar_mat_year_view_3_Template_mat_year_view_selectedChange_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r9);\n      var ctx_r11 = ɵngcc0.ɵɵnextContext();\n      return ctx_r11._goToDateInView($event, \"month\");\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"activeDate\", ctx_r2.activeDate)(\"selected\", ctx_r2.selected)(\"dateFilter\", ctx_r2.dateFilter)(\"maxDate\", ctx_r2.maxDate)(\"minDate\", ctx_r2.minDate);\n  }\n}\n\nfunction MatCalendar_mat_multi_year_view_4_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r13 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"mat-multi-year-view\", 7);\n    ɵngcc0.ɵɵlistener(\"activeDateChange\", function MatCalendar_mat_multi_year_view_4_Template_mat_multi_year_view_activeDateChange_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r13);\n      var ctx_r12 = ɵngcc0.ɵɵnextContext();\n      return ctx_r12.activeDate = $event;\n    })(\"yearSelected\", function MatCalendar_mat_multi_year_view_4_Template_mat_multi_year_view_yearSelected_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r13);\n      var ctx_r14 = ɵngcc0.ɵɵnextContext();\n      return ctx_r14._yearSelectedInMultiYearView($event);\n    })(\"selectedChange\", function MatCalendar_mat_multi_year_view_4_Template_mat_multi_year_view_selectedChange_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r13);\n      var ctx_r15 = ɵngcc0.ɵɵnextContext();\n      return ctx_r15._goToDateInView($event, \"year\");\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r3 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"activeDate\", ctx_r3.activeDate)(\"selected\", ctx_r3.selected)(\"dateFilter\", ctx_r3.dateFilter)(\"maxDate\", ctx_r3.maxDate)(\"minDate\", ctx_r3.minDate);\n  }\n}\n\nfunction MatDatepickerToggle__svg_svg_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(0, \"svg\", 2);\n    ɵngcc0.ɵɵelement(1, \"path\", 3);\n    ɵngcc0.ɵɵelement(2, \"path\", 4);\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nvar _c2 = [[[\"\", \"matDatepickerToggleIcon\", \"\"]]];\nvar _c3 = [\"[matDatepickerToggleIcon]\"];\n\nfunction createMissingDateImplError(provider) {\n  return Error(\"MatDatepicker: No provider found for \".concat(provider, \". You must import one of the following \") + \"modules at your application root: MatNativeDateModule, MatMomentDateModule, or provide a \" + \"custom implementation.\");\n}\n\nvar MatDatepickerIntl = /*@__PURE__*/function () {\n  var MatDatepickerIntl = function MatDatepickerIntl() {\n    _classCallCheck(this, MatDatepickerIntl);\n\n    /**\n     * Stream that emits whenever the labels here are changed. Use this to notify\n     * components if the labels have changed after initialization.\n     */\n    this.changes = new Subject();\n    /**\n     * A label for the calendar popup (used by screen readers).\n     */\n\n    this.calendarLabel = 'Calendar';\n    /**\n     * A label for the button used to open the calendar popup (used by screen readers).\n     */\n\n    this.openCalendarLabel = 'Open calendar';\n    /**\n     * A label for the previous month button (used by screen readers).\n     */\n\n    this.prevMonthLabel = 'Previous month';\n    /**\n     * A label for the next month button (used by screen readers).\n     */\n\n    this.nextMonthLabel = 'Next month';\n    /**\n     * A label for the previous year button (used by screen readers).\n     */\n\n    this.prevYearLabel = 'Previous year';\n    /**\n     * A label for the next year button (used by screen readers).\n     */\n\n    this.nextYearLabel = 'Next year';\n    /**\n     * A label for the previous multi-year button (used by screen readers).\n     */\n\n    this.prevMultiYearLabel = 'Previous 20 years';\n    /**\n     * A label for the next multi-year button (used by screen readers).\n     */\n\n    this.nextMultiYearLabel = 'Next 20 years';\n    /**\n     * A label for the 'switch to month view' button (used by screen readers).\n     */\n\n    this.switchToMonthViewLabel = 'Choose date';\n    /**\n     * A label for the 'switch to year view' button (used by screen readers).\n     */\n\n    this.switchToMultiYearViewLabel = 'Choose month and year';\n  };\n\n  MatDatepickerIntl.ɵfac = function MatDatepickerIntl_Factory(t) {\n    return new (t || MatDatepickerIntl)();\n  };\n\n  MatDatepickerIntl.ɵprov =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineInjectable({\n    token: MatDatepickerIntl,\n    factory: MatDatepickerIntl.ɵfac,\n    providedIn: 'root'\n  });\n  /** @nocollapse */\n\n  MatDatepickerIntl.ngInjectableDef = /*@__PURE__*/defineInjectable({\n    factory: function MatDatepickerIntl_Factory() {\n      return new MatDatepickerIntl();\n    },\n    token: MatDatepickerIntl,\n    providedIn: \"root\"\n  });\n  return MatDatepickerIntl;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * An internal class that represents the data corresponding to a single calendar cell.\n * \\@docs-private\n */\n\n\nvar MatCalendarCell =\n/**\n * @param {?} value\n * @param {?} displayValue\n * @param {?} ariaLabel\n * @param {?} enabled\n */\nfunction MatCalendarCell(value, displayValue, ariaLabel, enabled) {\n  _classCallCheck(this, MatCalendarCell);\n\n  this.value = value;\n  this.displayValue = displayValue;\n  this.ariaLabel = ariaLabel;\n  this.enabled = enabled;\n};\n\nvar MatCalendarBody = /*@__PURE__*/function () {\n  var MatCalendarBody = /*#__PURE__*/function () {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _ngZone\n     */\n    function MatCalendarBody(_elementRef, _ngZone) {\n      _classCallCheck(this, MatCalendarBody);\n\n      this._elementRef = _elementRef;\n      this._ngZone = _ngZone;\n      /**\n       * The number of columns in the table.\n       */\n\n      this.numCols = 7;\n      /**\n       * The cell number of the active cell in the table.\n       */\n\n      this.activeCell = 0;\n      /**\n       * The aspect ratio (width / height) to use for the cells in the table. This aspect ratio will be\n       * maintained even as the table resizes.\n       */\n\n      this.cellAspectRatio = 1;\n      /**\n       * Emits when a new value is selected.\n       */\n\n      this.selectedValueChange = new EventEmitter();\n    }\n    /**\n     * @param {?} cell\n     * @return {?}\n     */\n\n\n    _createClass(MatCalendarBody, [{\n      key: \"_cellClicked\",\n      value: function _cellClicked(cell) {\n        if (cell.enabled) {\n          this.selectedValueChange.emit(cell.value);\n        }\n      }\n      /**\n       * The number of blank cells to put at the beginning for the first row.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_firstRowOffset\",\n      get: function get() {\n        return this.rows && this.rows.length && this.rows[0].length ? this.numCols - this.rows[0].length : 0;\n      }\n      /**\n       * @param {?} rowIndex\n       * @param {?} colIndex\n       * @return {?}\n       */\n\n    }, {\n      key: \"_isActiveCell\",\n      value: function _isActiveCell(rowIndex, colIndex) {\n        /** @type {?} */\n        var cellNumber = rowIndex * this.numCols + colIndex; // Account for the fact that the first row may not have as many cells.\n\n        if (rowIndex) {\n          cellNumber -= this._firstRowOffset;\n        }\n\n        return cellNumber == this.activeCell;\n      }\n      /**\n       * Focuses the active cell after the microtask queue is empty.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_focusActiveCell\",\n      value: function _focusActiveCell() {\n        var _this = this;\n\n        this._ngZone.runOutsideAngular(function () {\n          _this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(function () {\n            /** @type {?} */\n            var activeCell = _this._elementRef.nativeElement.querySelector('.mat-calendar-body-active');\n\n            if (activeCell) {\n              activeCell.focus();\n            }\n          });\n        });\n      }\n    }]);\n\n    return MatCalendarBody;\n  }();\n\n  MatCalendarBody.ɵfac = function MatCalendarBody_Factory(t) {\n    return new (t || MatCalendarBody)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  MatCalendarBody.ɵcmp =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineComponent({\n    type: MatCalendarBody,\n    selectors: [[\"\", \"mat-calendar-body\", \"\"]],\n    hostAttrs: [\"role\", \"grid\", \"aria-readonly\", \"true\", 1, \"mat-calendar-body\"],\n    inputs: {\n      numCols: \"numCols\",\n      activeCell: \"activeCell\",\n      cellAspectRatio: \"cellAspectRatio\",\n      label: \"label\",\n      rows: \"rows\",\n      todayValue: \"todayValue\",\n      selectedValue: \"selectedValue\",\n      labelMinRequiredCells: \"labelMinRequiredCells\"\n    },\n    outputs: {\n      selectedValueChange: \"selectedValueChange\"\n    },\n    exportAs: [\"matCalendarBody\"],\n    attrs: _c0,\n    decls: 2,\n    vars: 2,\n    consts: [[\"aria-hidden\", \"true\", 4, \"ngIf\"], [\"role\", \"row\", 4, \"ngFor\", \"ngForOf\"], [\"aria-hidden\", \"true\"], [1, \"mat-calendar-body-label\"], [\"role\", \"row\"], [\"aria-hidden\", \"true\", \"class\", \"mat-calendar-body-label\", 3, \"paddingTop\", \"paddingBottom\", 4, \"ngIf\"], [\"role\", \"gridcell\", \"class\", \"mat-calendar-body-cell\", 3, \"tabindex\", \"mat-calendar-body-disabled\", \"mat-calendar-body-active\", \"width\", \"paddingTop\", \"paddingBottom\", \"click\", 4, \"ngFor\", \"ngForOf\"], [\"aria-hidden\", \"true\", 1, \"mat-calendar-body-label\"], [\"role\", \"gridcell\", 1, \"mat-calendar-body-cell\", 3, \"tabindex\", \"click\"], [1, \"mat-calendar-body-cell-content\"]],\n    template: function MatCalendarBody_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, MatCalendarBody_tr_0_Template, 3, 6, \"tr\", 0);\n        ɵngcc0.ɵɵtemplate(1, MatCalendarBody_tr_1_Template, 3, 2, \"tr\", 1);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx._firstRowOffset < ctx.labelMinRequiredCells);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.rows);\n      }\n    },\n    directives: [ɵngcc1.NgIf, ɵngcc1.NgForOf],\n    styles: [\".mat-calendar-body{min-width:224px}.mat-calendar-body-label{height:0;line-height:0;text-align:left;padding-left:4.71429%;padding-right:4.71429%}.mat-calendar-body-cell{position:relative;height:0;line-height:0;text-align:center;outline:0;cursor:pointer}.mat-calendar-body-disabled{cursor:default}.mat-calendar-body-cell-content{position:absolute;top:5%;left:5%;display:flex;align-items:center;justify-content:center;box-sizing:border-box;width:90%;height:90%;line-height:1;border-width:1px;border-style:solid;border-radius:999px}@media screen and (-ms-high-contrast:active){.mat-calendar-body-cell-content{border:none}}@media screen and (-ms-high-contrast:active){.mat-calendar-body-selected,.mat-datepicker-popup:not(:empty){outline:solid 1px}.mat-calendar-body-today{outline:dotted 1px}}[dir=rtl] .mat-calendar-body-label{text-align:right}\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MatCalendarBody;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar DAYS_PER_WEEK = 7;\n\nvar MatMonthView = /*@__PURE__*/function () {\n  var MatMonthView = /*#__PURE__*/function () {\n    /**\n     * @param {?} _changeDetectorRef\n     * @param {?} _dateFormats\n     * @param {?} _dateAdapter\n     * @param {?=} _dir\n     */\n    function MatMonthView(_changeDetectorRef, _dateFormats, _dateAdapter, _dir) {\n      _classCallCheck(this, MatMonthView);\n\n      this._changeDetectorRef = _changeDetectorRef;\n      this._dateFormats = _dateFormats;\n      this._dateAdapter = _dateAdapter;\n      this._dir = _dir;\n      /**\n       * Emits when a new date is selected.\n       */\n\n      this.selectedChange = new EventEmitter();\n      /**\n       * Emits when any date is selected.\n       */\n\n      this._userSelection = new EventEmitter();\n      /**\n       * Emits when any date is activated.\n       */\n\n      this.activeDateChange = new EventEmitter();\n\n      if (!this._dateAdapter) {\n        throw createMissingDateImplError('DateAdapter');\n      }\n\n      if (!this._dateFormats) {\n        throw createMissingDateImplError('MAT_DATE_FORMATS');\n      }\n      /** @type {?} */\n\n\n      var firstDayOfWeek = this._dateAdapter.getFirstDayOfWeek();\n      /** @type {?} */\n\n\n      var narrowWeekdays = this._dateAdapter.getDayOfWeekNames('narrow');\n      /** @type {?} */\n\n\n      var longWeekdays = this._dateAdapter.getDayOfWeekNames('long');\n      /** @type {?} */\n\n\n      var weekdays = longWeekdays.map(function (long, i) {\n        return {\n          long: long,\n          narrow: narrowWeekdays[i]\n        };\n      });\n      this._weekdays = weekdays.slice(firstDayOfWeek).concat(weekdays.slice(0, firstDayOfWeek));\n      this._activeDate = this._dateAdapter.today();\n    }\n    /**\n     * The date to display in this month view (everything other than the month and year is ignored).\n     * @return {?}\n     */\n\n\n    _createClass(MatMonthView, [{\n      key: \"activeDate\",\n      get: function get() {\n        return this._activeDate;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        /** @type {?} */\n        var oldActiveDate = this._activeDate;\n        /** @type {?} */\n\n        var validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();\n\n        this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);\n\n        if (!this._hasSameMonthAndYear(oldActiveDate, this._activeDate)) {\n          this._init();\n        }\n      }\n      /**\n       * The currently selected date.\n       * @return {?}\n       */\n\n    }, {\n      key: \"selected\",\n      get: function get() {\n        return this._selected;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n        this._selectedDate = this._getDateInCurrentMonth(this._selected);\n      }\n      /**\n       * The minimum selectable date.\n       * @return {?}\n       */\n\n    }, {\n      key: \"minDate\",\n      get: function get() {\n        return this._minDate;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n      }\n      /**\n       * The maximum selectable date.\n       * @return {?}\n       */\n\n    }, {\n      key: \"maxDate\",\n      get: function get() {\n        return this._maxDate;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngAfterContentInit\",\n      value: function ngAfterContentInit() {\n        this._init();\n      }\n      /**\n       * Handles when a new date is selected.\n       * @param {?} date\n       * @return {?}\n       */\n\n    }, {\n      key: \"_dateSelected\",\n      value: function _dateSelected(date) {\n        if (this._selectedDate != date) {\n          /** @type {?} */\n          var selectedYear = this._dateAdapter.getYear(this.activeDate);\n          /** @type {?} */\n\n\n          var selectedMonth = this._dateAdapter.getMonth(this.activeDate);\n          /** @type {?} */\n\n\n          var selectedDate = this._dateAdapter.createDate(selectedYear, selectedMonth, date);\n\n          this.selectedChange.emit(selectedDate);\n        }\n\n        this._userSelection.emit();\n      }\n      /**\n       * Handles keydown events on the calendar body when calendar is in month view.\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"_handleCalendarBodyKeydown\",\n      value: function _handleCalendarBodyKeydown(event) {\n        /** @type {?} */\n        var oldActiveDate = this._activeDate;\n        /** @type {?} */\n\n        var isRtl = this._isRtl();\n\n        switch (event.keyCode) {\n          case LEFT_ARROW:\n            this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, isRtl ? 1 : -1);\n            break;\n\n          case RIGHT_ARROW:\n            this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, isRtl ? -1 : 1);\n            break;\n\n          case UP_ARROW:\n            this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, -7);\n            break;\n\n          case DOWN_ARROW:\n            this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 7);\n            break;\n\n          case HOME:\n            this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 1 - this._dateAdapter.getDate(this._activeDate));\n            break;\n\n          case END:\n            this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, this._dateAdapter.getNumDaysInMonth(this._activeDate) - this._dateAdapter.getDate(this._activeDate));\n            break;\n\n          case PAGE_UP:\n            this.activeDate = event.altKey ? this._dateAdapter.addCalendarYears(this._activeDate, -1) : this._dateAdapter.addCalendarMonths(this._activeDate, -1);\n            break;\n\n          case PAGE_DOWN:\n            this.activeDate = event.altKey ? this._dateAdapter.addCalendarYears(this._activeDate, 1) : this._dateAdapter.addCalendarMonths(this._activeDate, 1);\n            break;\n\n          case ENTER:\n          case SPACE:\n            if (!this.dateFilter || this.dateFilter(this._activeDate)) {\n              this._dateSelected(this._dateAdapter.getDate(this._activeDate));\n\n              this._userSelection.emit(); // Prevent unexpected default actions such as form submission.\n\n\n              event.preventDefault();\n            }\n\n            return;\n\n          default:\n            // Don't prevent default or focus active cell on keys that we don't explicitly handle.\n            return;\n        }\n\n        if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {\n          this.activeDateChange.emit(this.activeDate);\n        }\n\n        this._focusActiveCell(); // Prevent unexpected default actions such as form submission.\n\n\n        event.preventDefault();\n      }\n      /**\n       * Initializes this month view.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_init\",\n      value: function _init() {\n        this._selectedDate = this._getDateInCurrentMonth(this.selected);\n        this._todayDate = this._getDateInCurrentMonth(this._dateAdapter.today());\n        this._monthLabel = this._dateAdapter.getMonthNames('short')[this._dateAdapter.getMonth(this.activeDate)].toLocaleUpperCase();\n        /** @type {?} */\n\n        var firstOfMonth = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), 1);\n\n        this._firstWeekOffset = (DAYS_PER_WEEK + this._dateAdapter.getDayOfWeek(firstOfMonth) - this._dateAdapter.getFirstDayOfWeek()) % DAYS_PER_WEEK;\n\n        this._createWeekCells();\n\n        this._changeDetectorRef.markForCheck();\n      }\n      /**\n       * Focuses the active cell after the microtask queue is empty.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_focusActiveCell\",\n      value: function _focusActiveCell() {\n        this._matCalendarBody._focusActiveCell();\n      }\n      /**\n       * Creates MatCalendarCells for the dates in this month.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_createWeekCells\",\n      value: function _createWeekCells() {\n        /** @type {?} */\n        var daysInMonth = this._dateAdapter.getNumDaysInMonth(this.activeDate);\n        /** @type {?} */\n\n\n        var dateNames = this._dateAdapter.getDateNames();\n\n        this._weeks = [[]];\n\n        for (var i = 0, cell = this._firstWeekOffset; i < daysInMonth; i++, cell++) {\n          if (cell == DAYS_PER_WEEK) {\n            this._weeks.push([]);\n\n            cell = 0;\n          }\n          /** @type {?} */\n\n\n          var date = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), i + 1);\n          /** @type {?} */\n\n\n          var enabled = this._shouldEnableDate(date);\n          /** @type {?} */\n\n\n          var ariaLabel = this._dateAdapter.format(date, this._dateFormats.display.dateA11yLabel);\n\n          this._weeks[this._weeks.length - 1].push(new MatCalendarCell(i + 1, dateNames[i], ariaLabel, enabled));\n        }\n      }\n      /**\n       * Date filter for the month\n       * @param {?} date\n       * @return {?}\n       */\n\n    }, {\n      key: \"_shouldEnableDate\",\n      value: function _shouldEnableDate(date) {\n        return !!date && (!this.dateFilter || this.dateFilter(date)) && (!this.minDate || this._dateAdapter.compareDate(date, this.minDate) >= 0) && (!this.maxDate || this._dateAdapter.compareDate(date, this.maxDate) <= 0);\n      }\n      /**\n       * Gets the date in this month that the given Date falls on.\n       * Returns null if the given Date is in another month.\n       * @param {?} date\n       * @return {?}\n       */\n\n    }, {\n      key: \"_getDateInCurrentMonth\",\n      value: function _getDateInCurrentMonth(date) {\n        return date && this._hasSameMonthAndYear(date, this.activeDate) ? this._dateAdapter.getDate(date) : null;\n      }\n      /**\n       * Checks whether the 2 dates are non-null and fall within the same month of the same year.\n       * @param {?} d1\n       * @param {?} d2\n       * @return {?}\n       */\n\n    }, {\n      key: \"_hasSameMonthAndYear\",\n      value: function _hasSameMonthAndYear(d1, d2) {\n        return !!(d1 && d2 && this._dateAdapter.getMonth(d1) == this._dateAdapter.getMonth(d2) && this._dateAdapter.getYear(d1) == this._dateAdapter.getYear(d2));\n      }\n      /**\n       * @param {?} obj The object to check.\n       * @return {?} The given object if it is both a date instance and valid, otherwise null.\n       */\n\n    }, {\n      key: \"_getValidDateOrNull\",\n      value: function _getValidDateOrNull(obj) {\n        return this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj) ? obj : null;\n      }\n      /**\n       * Determines whether the user has the RTL layout direction.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_isRtl\",\n      value: function _isRtl() {\n        return this._dir && this._dir.value === 'rtl';\n      }\n    }]);\n\n    return MatMonthView;\n  }();\n\n  MatMonthView.ɵfac = function MatMonthView_Factory(t) {\n    return new (t || MatMonthView)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(MAT_DATE_FORMATS, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.DateAdapter, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Directionality, 8));\n  };\n\n  MatMonthView.ɵcmp =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineComponent({\n    type: MatMonthView,\n    selectors: [[\"mat-month-view\"]],\n    viewQuery: function MatMonthView_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(MatCalendarBody, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._matCalendarBody = _t.first);\n      }\n    },\n    inputs: {\n      activeDate: \"activeDate\",\n      selected: \"selected\",\n      minDate: \"minDate\",\n      maxDate: \"maxDate\",\n      dateFilter: \"dateFilter\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\",\n      _userSelection: \"_userSelection\",\n      activeDateChange: \"activeDateChange\"\n    },\n    exportAs: [\"matMonthView\"],\n    decls: 7,\n    vars: 7,\n    consts: [[1, \"mat-calendar-table\"], [1, \"mat-calendar-table-header\"], [4, \"ngFor\", \"ngForOf\"], [\"colspan\", \"7\", \"aria-hidden\", \"true\", 1, \"mat-calendar-table-header-divider\"], [\"mat-calendar-body\", \"\", 3, \"label\", \"rows\", \"todayValue\", \"selectedValue\", \"labelMinRequiredCells\", \"activeCell\", \"selectedValueChange\", \"keydown\"]],\n    template: function MatMonthView_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"table\", 0);\n        ɵngcc0.ɵɵelementStart(1, \"thead\", 1);\n        ɵngcc0.ɵɵelementStart(2, \"tr\");\n        ɵngcc0.ɵɵtemplate(3, MatMonthView_th_3_Template, 2, 2, \"th\", 2);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(4, \"tr\");\n        ɵngcc0.ɵɵelement(5, \"th\", 3);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(6, \"tbody\", 4);\n        ɵngcc0.ɵɵlistener(\"selectedValueChange\", function MatMonthView_Template_tbody_selectedValueChange_6_listener($event) {\n          return ctx._dateSelected($event);\n        })(\"keydown\", function MatMonthView_Template_tbody_keydown_6_listener($event) {\n          return ctx._handleCalendarBodyKeydown($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx._weekdays);\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"label\", ctx._monthLabel)(\"rows\", ctx._weeks)(\"todayValue\", ctx._todayDate)(\"selectedValue\", ctx._selectedDate)(\"labelMinRequiredCells\", 3)(\"activeCell\", ctx._dateAdapter.getDate(ctx.activeDate) - 1);\n      }\n    },\n    directives: [ɵngcc1.NgForOf, MatCalendarBody],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MatMonthView;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar yearsPerPage = 24;\n/** @type {?} */\n\nvar yearsPerRow = 4;\n\nvar MatMultiYearView = /*@__PURE__*/function () {\n  var MatMultiYearView = /*#__PURE__*/function () {\n    /**\n     * @param {?} _changeDetectorRef\n     * @param {?} _dateAdapter\n     * @param {?=} _dir\n     */\n    function MatMultiYearView(_changeDetectorRef, _dateAdapter, _dir) {\n      _classCallCheck(this, MatMultiYearView);\n\n      this._changeDetectorRef = _changeDetectorRef;\n      this._dateAdapter = _dateAdapter;\n      this._dir = _dir;\n      /**\n       * Emits when a new year is selected.\n       */\n\n      this.selectedChange = new EventEmitter();\n      /**\n       * Emits the selected year. This doesn't imply a change on the selected date\n       */\n\n      this.yearSelected = new EventEmitter();\n      /**\n       * Emits when any date is activated.\n       */\n\n      this.activeDateChange = new EventEmitter();\n\n      if (!this._dateAdapter) {\n        throw createMissingDateImplError('DateAdapter');\n      }\n\n      this._activeDate = this._dateAdapter.today();\n    }\n    /**\n     * The date to display in this multi-year view (everything other than the year is ignored).\n     * @return {?}\n     */\n\n\n    _createClass(MatMultiYearView, [{\n      key: \"activeDate\",\n      get: function get() {\n        return this._activeDate;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        /** @type {?} */\n        var oldActiveDate = this._activeDate;\n        /** @type {?} */\n\n        var validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();\n\n        this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);\n\n        if (Math.floor(this._dateAdapter.getYear(oldActiveDate) / yearsPerPage) != Math.floor(this._dateAdapter.getYear(this._activeDate) / yearsPerPage)) {\n          this._init();\n        }\n      }\n      /**\n       * The currently selected date.\n       * @return {?}\n       */\n\n    }, {\n      key: \"selected\",\n      get: function get() {\n        return this._selected;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n        this._selectedYear = this._selected && this._dateAdapter.getYear(this._selected);\n      }\n      /**\n       * The minimum selectable date.\n       * @return {?}\n       */\n\n    }, {\n      key: \"minDate\",\n      get: function get() {\n        return this._minDate;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n      }\n      /**\n       * The maximum selectable date.\n       * @return {?}\n       */\n\n    }, {\n      key: \"maxDate\",\n      get: function get() {\n        return this._maxDate;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngAfterContentInit\",\n      value: function ngAfterContentInit() {\n        this._init();\n      }\n      /**\n       * Initializes this multi-year view.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_init\",\n      value: function _init() {\n        var _this2 = this;\n\n        this._todayYear = this._dateAdapter.getYear(this._dateAdapter.today());\n        /** @type {?} */\n\n        var activeYear = this._dateAdapter.getYear(this._activeDate);\n        /** @type {?} */\n\n\n        var activeOffset = activeYear % yearsPerPage;\n        this._years = [];\n\n        for (var i = 0, row = []; i < yearsPerPage; i++) {\n          row.push(activeYear - activeOffset + i);\n\n          if (row.length == yearsPerRow) {\n            this._years.push(row.map(function (year) {\n              return _this2._createCellForYear(year);\n            }));\n\n            row = [];\n          }\n        }\n\n        this._changeDetectorRef.markForCheck();\n      }\n      /**\n       * Handles when a new year is selected.\n       * @param {?} year\n       * @return {?}\n       */\n\n    }, {\n      key: \"_yearSelected\",\n      value: function _yearSelected(year) {\n        this.yearSelected.emit(this._dateAdapter.createDate(year, 0, 1));\n        /** @type {?} */\n\n        var month = this._dateAdapter.getMonth(this.activeDate);\n        /** @type {?} */\n\n\n        var daysInMonth = this._dateAdapter.getNumDaysInMonth(this._dateAdapter.createDate(year, month, 1));\n\n        this.selectedChange.emit(this._dateAdapter.createDate(year, month, Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth)));\n      }\n      /**\n       * Handles keydown events on the calendar body when calendar is in multi-year view.\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"_handleCalendarBodyKeydown\",\n      value: function _handleCalendarBodyKeydown(event) {\n        /** @type {?} */\n        var oldActiveDate = this._activeDate;\n        /** @type {?} */\n\n        var isRtl = this._isRtl();\n\n        switch (event.keyCode) {\n          case LEFT_ARROW:\n            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, isRtl ? 1 : -1);\n            break;\n\n          case RIGHT_ARROW:\n            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, isRtl ? -1 : 1);\n            break;\n\n          case UP_ARROW:\n            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -yearsPerRow);\n            break;\n\n          case DOWN_ARROW:\n            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, yearsPerRow);\n            break;\n\n          case HOME:\n            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -this._dateAdapter.getYear(this._activeDate) % yearsPerPage);\n            break;\n\n          case END:\n            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, yearsPerPage - this._dateAdapter.getYear(this._activeDate) % yearsPerPage - 1);\n            break;\n\n          case PAGE_UP:\n            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? -yearsPerPage * 10 : -yearsPerPage);\n            break;\n\n          case PAGE_DOWN:\n            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? yearsPerPage * 10 : yearsPerPage);\n            break;\n\n          case ENTER:\n          case SPACE:\n            this._yearSelected(this._dateAdapter.getYear(this._activeDate));\n\n            break;\n\n          default:\n            // Don't prevent default or focus active cell on keys that we don't explicitly handle.\n            return;\n        }\n\n        if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {\n          this.activeDateChange.emit(this.activeDate);\n        }\n\n        this._focusActiveCell(); // Prevent unexpected default actions such as form submission.\n\n\n        event.preventDefault();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"_getActiveCell\",\n      value: function _getActiveCell() {\n        return this._dateAdapter.getYear(this.activeDate) % yearsPerPage;\n      }\n      /**\n       * Focuses the active cell after the microtask queue is empty.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_focusActiveCell\",\n      value: function _focusActiveCell() {\n        this._matCalendarBody._focusActiveCell();\n      }\n      /**\n       * Creates an MatCalendarCell for the given year.\n       * @param {?} year\n       * @return {?}\n       */\n\n    }, {\n      key: \"_createCellForYear\",\n      value: function _createCellForYear(year) {\n        /** @type {?} */\n        var yearName = this._dateAdapter.getYearName(this._dateAdapter.createDate(year, 0, 1));\n\n        return new MatCalendarCell(year, yearName, yearName, this._shouldEnableYear(year));\n      }\n      /**\n       * Whether the given year is enabled.\n       * @param {?} year\n       * @return {?}\n       */\n\n    }, {\n      key: \"_shouldEnableYear\",\n      value: function _shouldEnableYear(year) {\n        // disable if the year is greater than maxDate lower than minDate\n        if (year === undefined || year === null || this.maxDate && year > this._dateAdapter.getYear(this.maxDate) || this.minDate && year < this._dateAdapter.getYear(this.minDate)) {\n          return false;\n        } // enable if it reaches here and there's no filter defined\n\n\n        if (!this.dateFilter) {\n          return true;\n        }\n        /** @type {?} */\n\n\n        var firstOfYear = this._dateAdapter.createDate(year, 0, 1); // If any date in the year is enabled count the year as enabled.\n\n\n        for (var date = firstOfYear; this._dateAdapter.getYear(date) == year; date = this._dateAdapter.addCalendarDays(date, 1)) {\n          if (this.dateFilter(date)) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n      /**\n       * @param {?} obj The object to check.\n       * @return {?} The given object if it is both a date instance and valid, otherwise null.\n       */\n\n    }, {\n      key: \"_getValidDateOrNull\",\n      value: function _getValidDateOrNull(obj) {\n        return this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj) ? obj : null;\n      }\n      /**\n       * Determines whether the user has the RTL layout direction.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_isRtl\",\n      value: function _isRtl() {\n        return this._dir && this._dir.value === 'rtl';\n      }\n    }]);\n\n    return MatMultiYearView;\n  }();\n\n  MatMultiYearView.ɵfac = function MatMultiYearView_Factory(t) {\n    return new (t || MatMultiYearView)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.DateAdapter, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Directionality, 8));\n  };\n\n  MatMultiYearView.ɵcmp =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineComponent({\n    type: MatMultiYearView,\n    selectors: [[\"mat-multi-year-view\"]],\n    viewQuery: function MatMultiYearView_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(MatCalendarBody, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._matCalendarBody = _t.first);\n      }\n    },\n    inputs: {\n      activeDate: \"activeDate\",\n      selected: \"selected\",\n      minDate: \"minDate\",\n      maxDate: \"maxDate\",\n      dateFilter: \"dateFilter\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\",\n      yearSelected: \"yearSelected\",\n      activeDateChange: \"activeDateChange\"\n    },\n    exportAs: [\"matMultiYearView\"],\n    decls: 5,\n    vars: 6,\n    consts: [[1, \"mat-calendar-table\"], [1, \"mat-calendar-table-header\"], [\"colspan\", \"4\", 1, \"mat-calendar-table-header-divider\"], [\"mat-calendar-body\", \"\", 3, \"rows\", \"todayValue\", \"selectedValue\", \"numCols\", \"cellAspectRatio\", \"activeCell\", \"selectedValueChange\", \"keydown\"]],\n    template: function MatMultiYearView_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"table\", 0);\n        ɵngcc0.ɵɵelementStart(1, \"thead\", 1);\n        ɵngcc0.ɵɵelementStart(2, \"tr\");\n        ɵngcc0.ɵɵelement(3, \"th\", 2);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(4, \"tbody\", 3);\n        ɵngcc0.ɵɵlistener(\"selectedValueChange\", function MatMultiYearView_Template_tbody_selectedValueChange_4_listener($event) {\n          return ctx._yearSelected($event);\n        })(\"keydown\", function MatMultiYearView_Template_tbody_keydown_4_listener($event) {\n          return ctx._handleCalendarBodyKeydown($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(4);\n        ɵngcc0.ɵɵproperty(\"rows\", ctx._years)(\"todayValue\", ctx._todayYear)(\"selectedValue\", ctx._selectedYear)(\"numCols\", 4)(\"cellAspectRatio\", 4 / 7)(\"activeCell\", ctx._getActiveCell());\n      }\n    },\n    directives: [MatCalendarBody],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MatMultiYearView;\n}();\n\nvar MatYearView = /*@__PURE__*/function () {\n  var MatYearView = /*#__PURE__*/function () {\n    /**\n     * @param {?} _changeDetectorRef\n     * @param {?} _dateFormats\n     * @param {?} _dateAdapter\n     * @param {?=} _dir\n     */\n    function MatYearView(_changeDetectorRef, _dateFormats, _dateAdapter, _dir) {\n      _classCallCheck(this, MatYearView);\n\n      this._changeDetectorRef = _changeDetectorRef;\n      this._dateFormats = _dateFormats;\n      this._dateAdapter = _dateAdapter;\n      this._dir = _dir;\n      /**\n       * Emits when a new month is selected.\n       */\n\n      this.selectedChange = new EventEmitter();\n      /**\n       * Emits the selected month. This doesn't imply a change on the selected date\n       */\n\n      this.monthSelected = new EventEmitter();\n      /**\n       * Emits when any date is activated.\n       */\n\n      this.activeDateChange = new EventEmitter();\n\n      if (!this._dateAdapter) {\n        throw createMissingDateImplError('DateAdapter');\n      }\n\n      if (!this._dateFormats) {\n        throw createMissingDateImplError('MAT_DATE_FORMATS');\n      }\n\n      this._activeDate = this._dateAdapter.today();\n    }\n    /**\n     * The date to display in this year view (everything other than the year is ignored).\n     * @return {?}\n     */\n\n\n    _createClass(MatYearView, [{\n      key: \"activeDate\",\n      get: function get() {\n        return this._activeDate;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        /** @type {?} */\n        var oldActiveDate = this._activeDate;\n        /** @type {?} */\n\n        var validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();\n\n        this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);\n\n        if (this._dateAdapter.getYear(oldActiveDate) !== this._dateAdapter.getYear(this._activeDate)) {\n          this._init();\n        }\n      }\n      /**\n       * The currently selected date.\n       * @return {?}\n       */\n\n    }, {\n      key: \"selected\",\n      get: function get() {\n        return this._selected;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n        this._selectedMonth = this._getMonthInCurrentYear(this._selected);\n      }\n      /**\n       * The minimum selectable date.\n       * @return {?}\n       */\n\n    }, {\n      key: \"minDate\",\n      get: function get() {\n        return this._minDate;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n      }\n      /**\n       * The maximum selectable date.\n       * @return {?}\n       */\n\n    }, {\n      key: \"maxDate\",\n      get: function get() {\n        return this._maxDate;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngAfterContentInit\",\n      value: function ngAfterContentInit() {\n        this._init();\n      }\n      /**\n       * Handles when a new month is selected.\n       * @param {?} month\n       * @return {?}\n       */\n\n    }, {\n      key: \"_monthSelected\",\n      value: function _monthSelected(month) {\n        /** @type {?} */\n        var normalizedDate = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1);\n\n        this.monthSelected.emit(normalizedDate);\n        /** @type {?} */\n\n        var daysInMonth = this._dateAdapter.getNumDaysInMonth(normalizedDate);\n\n        this.selectedChange.emit(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth)));\n      }\n      /**\n       * Handles keydown events on the calendar body when calendar is in year view.\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"_handleCalendarBodyKeydown\",\n      value: function _handleCalendarBodyKeydown(event) {\n        /** @type {?} */\n        var oldActiveDate = this._activeDate;\n        /** @type {?} */\n\n        var isRtl = this._isRtl();\n\n        switch (event.keyCode) {\n          case LEFT_ARROW:\n            this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, isRtl ? 1 : -1);\n            break;\n\n          case RIGHT_ARROW:\n            this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, isRtl ? -1 : 1);\n            break;\n\n          case UP_ARROW:\n            this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -4);\n            break;\n\n          case DOWN_ARROW:\n            this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 4);\n            break;\n\n          case HOME:\n            this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -this._dateAdapter.getMonth(this._activeDate));\n            break;\n\n          case END:\n            this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 11 - this._dateAdapter.getMonth(this._activeDate));\n            break;\n\n          case PAGE_UP:\n            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? -10 : -1);\n            break;\n\n          case PAGE_DOWN:\n            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? 10 : 1);\n            break;\n\n          case ENTER:\n          case SPACE:\n            this._monthSelected(this._dateAdapter.getMonth(this._activeDate));\n\n            break;\n\n          default:\n            // Don't prevent default or focus active cell on keys that we don't explicitly handle.\n            return;\n        }\n\n        if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {\n          this.activeDateChange.emit(this.activeDate);\n        }\n\n        this._focusActiveCell(); // Prevent unexpected default actions such as form submission.\n\n\n        event.preventDefault();\n      }\n      /**\n       * Initializes this year view.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_init\",\n      value: function _init() {\n        var _this3 = this;\n\n        this._selectedMonth = this._getMonthInCurrentYear(this.selected);\n        this._todayMonth = this._getMonthInCurrentYear(this._dateAdapter.today());\n        this._yearLabel = this._dateAdapter.getYearName(this.activeDate);\n        /** @type {?} */\n\n        var monthNames = this._dateAdapter.getMonthNames('short'); // First row of months only contains 5 elements so we can fit the year label on the same row.\n\n\n        this._months = [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]].map(function (row) {\n          return row.map(function (month) {\n            return _this3._createCellForMonth(month, monthNames[month]);\n          });\n        });\n\n        this._changeDetectorRef.markForCheck();\n      }\n      /**\n       * Focuses the active cell after the microtask queue is empty.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_focusActiveCell\",\n      value: function _focusActiveCell() {\n        this._matCalendarBody._focusActiveCell();\n      }\n      /**\n       * Gets the month in this year that the given Date falls on.\n       * Returns null if the given Date is in another year.\n       * @param {?} date\n       * @return {?}\n       */\n\n    }, {\n      key: \"_getMonthInCurrentYear\",\n      value: function _getMonthInCurrentYear(date) {\n        return date && this._dateAdapter.getYear(date) == this._dateAdapter.getYear(this.activeDate) ? this._dateAdapter.getMonth(date) : null;\n      }\n      /**\n       * Creates an MatCalendarCell for the given month.\n       * @param {?} month\n       * @param {?} monthName\n       * @return {?}\n       */\n\n    }, {\n      key: \"_createCellForMonth\",\n      value: function _createCellForMonth(month, monthName) {\n        /** @type {?} */\n        var ariaLabel = this._dateAdapter.format(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1), this._dateFormats.display.monthYearA11yLabel);\n\n        return new MatCalendarCell(month, monthName.toLocaleUpperCase(), ariaLabel, this._shouldEnableMonth(month));\n      }\n      /**\n       * Whether the given month is enabled.\n       * @param {?} month\n       * @return {?}\n       */\n\n    }, {\n      key: \"_shouldEnableMonth\",\n      value: function _shouldEnableMonth(month) {\n        /** @type {?} */\n        var activeYear = this._dateAdapter.getYear(this.activeDate);\n\n        if (month === undefined || month === null || this._isYearAndMonthAfterMaxDate(activeYear, month) || this._isYearAndMonthBeforeMinDate(activeYear, month)) {\n          return false;\n        }\n\n        if (!this.dateFilter) {\n          return true;\n        }\n        /** @type {?} */\n\n\n        var firstOfMonth = this._dateAdapter.createDate(activeYear, month, 1); // If any date in the month is enabled count the month as enabled.\n\n\n        for (var date = firstOfMonth; this._dateAdapter.getMonth(date) == month; date = this._dateAdapter.addCalendarDays(date, 1)) {\n          if (this.dateFilter(date)) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n      /**\n       * Tests whether the combination month/year is after this.maxDate, considering\n       * just the month and year of this.maxDate\n       * @param {?} year\n       * @param {?} month\n       * @return {?}\n       */\n\n    }, {\n      key: \"_isYearAndMonthAfterMaxDate\",\n      value: function _isYearAndMonthAfterMaxDate(year, month) {\n        if (this.maxDate) {\n          /** @type {?} */\n          var maxYear = this._dateAdapter.getYear(this.maxDate);\n          /** @type {?} */\n\n\n          var maxMonth = this._dateAdapter.getMonth(this.maxDate);\n\n          return year > maxYear || year === maxYear && month > maxMonth;\n        }\n\n        return false;\n      }\n      /**\n       * Tests whether the combination month/year is before this.minDate, considering\n       * just the month and year of this.minDate\n       * @param {?} year\n       * @param {?} month\n       * @return {?}\n       */\n\n    }, {\n      key: \"_isYearAndMonthBeforeMinDate\",\n      value: function _isYearAndMonthBeforeMinDate(year, month) {\n        if (this.minDate) {\n          /** @type {?} */\n          var minYear = this._dateAdapter.getYear(this.minDate);\n          /** @type {?} */\n\n\n          var minMonth = this._dateAdapter.getMonth(this.minDate);\n\n          return year < minYear || year === minYear && month < minMonth;\n        }\n\n        return false;\n      }\n      /**\n       * @param {?} obj The object to check.\n       * @return {?} The given object if it is both a date instance and valid, otherwise null.\n       */\n\n    }, {\n      key: \"_getValidDateOrNull\",\n      value: function _getValidDateOrNull(obj) {\n        return this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj) ? obj : null;\n      }\n      /**\n       * Determines whether the user has the RTL layout direction.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_isRtl\",\n      value: function _isRtl() {\n        return this._dir && this._dir.value === 'rtl';\n      }\n    }]);\n\n    return MatYearView;\n  }();\n\n  MatYearView.ɵfac = function MatYearView_Factory(t) {\n    return new (t || MatYearView)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(MAT_DATE_FORMATS, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.DateAdapter, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Directionality, 8));\n  };\n\n  MatYearView.ɵcmp =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineComponent({\n    type: MatYearView,\n    selectors: [[\"mat-year-view\"]],\n    viewQuery: function MatYearView_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(MatCalendarBody, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._matCalendarBody = _t.first);\n      }\n    },\n    inputs: {\n      activeDate: \"activeDate\",\n      selected: \"selected\",\n      minDate: \"minDate\",\n      maxDate: \"maxDate\",\n      dateFilter: \"dateFilter\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\",\n      monthSelected: \"monthSelected\",\n      activeDateChange: \"activeDateChange\"\n    },\n    exportAs: [\"matYearView\"],\n    decls: 5,\n    vars: 8,\n    consts: [[1, \"mat-calendar-table\"], [1, \"mat-calendar-table-header\"], [\"colspan\", \"4\", 1, \"mat-calendar-table-header-divider\"], [\"mat-calendar-body\", \"\", 3, \"label\", \"rows\", \"todayValue\", \"selectedValue\", \"labelMinRequiredCells\", \"numCols\", \"cellAspectRatio\", \"activeCell\", \"selectedValueChange\", \"keydown\"]],\n    template: function MatYearView_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"table\", 0);\n        ɵngcc0.ɵɵelementStart(1, \"thead\", 1);\n        ɵngcc0.ɵɵelementStart(2, \"tr\");\n        ɵngcc0.ɵɵelement(3, \"th\", 2);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(4, \"tbody\", 3);\n        ɵngcc0.ɵɵlistener(\"selectedValueChange\", function MatYearView_Template_tbody_selectedValueChange_4_listener($event) {\n          return ctx._monthSelected($event);\n        })(\"keydown\", function MatYearView_Template_tbody_keydown_4_listener($event) {\n          return ctx._handleCalendarBodyKeydown($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(4);\n        ɵngcc0.ɵɵproperty(\"label\", ctx._yearLabel)(\"rows\", ctx._months)(\"todayValue\", ctx._todayMonth)(\"selectedValue\", ctx._selectedMonth)(\"labelMinRequiredCells\", 2)(\"numCols\", 4)(\"cellAspectRatio\", 4 / 7)(\"activeCell\", ctx._dateAdapter.getMonth(ctx.activeDate));\n      }\n    },\n    directives: [MatCalendarBody],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MatYearView;\n}();\n\nvar MatCalendarHeader = /*@__PURE__*/function () {\n  var MatCalendarHeader = /*#__PURE__*/function () {\n    /**\n     * @param {?} _intl\n     * @param {?} calendar\n     * @param {?} _dateAdapter\n     * @param {?} _dateFormats\n     * @param {?} changeDetectorRef\n     */\n    function MatCalendarHeader(_intl, calendar, _dateAdapter, _dateFormats, changeDetectorRef) {\n      _classCallCheck(this, MatCalendarHeader);\n\n      this._intl = _intl;\n      this.calendar = calendar;\n      this._dateAdapter = _dateAdapter;\n      this._dateFormats = _dateFormats;\n      this.calendar.stateChanges.subscribe(function () {\n        return changeDetectorRef.markForCheck();\n      });\n    }\n    /**\n     * The label for the current calendar view.\n     * @return {?}\n     */\n\n\n    _createClass(MatCalendarHeader, [{\n      key: \"periodButtonText\",\n      get: function get() {\n        if (this.calendar.currentView == 'month') {\n          return this._dateAdapter.format(this.calendar.activeDate, this._dateFormats.display.monthYearLabel).toLocaleUpperCase();\n        }\n\n        if (this.calendar.currentView == 'year') {\n          return this._dateAdapter.getYearName(this.calendar.activeDate);\n        }\n        /** @type {?} */\n\n\n        var activeYear = this._dateAdapter.getYear(this.calendar.activeDate);\n        /** @type {?} */\n\n\n        var firstYearInView = this._dateAdapter.getYearName(this._dateAdapter.createDate(activeYear - activeYear % 24, 0, 1));\n        /** @type {?} */\n\n\n        var lastYearInView = this._dateAdapter.getYearName(this._dateAdapter.createDate(activeYear + yearsPerPage - 1 - activeYear % 24, 0, 1));\n\n        return \"\".concat(firstYearInView, \" \\u2013 \").concat(lastYearInView);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"periodButtonLabel\",\n      get: function get() {\n        return this.calendar.currentView == 'month' ? this._intl.switchToMultiYearViewLabel : this._intl.switchToMonthViewLabel;\n      }\n      /**\n       * The label for the the previous button.\n       * @return {?}\n       */\n\n    }, {\n      key: \"prevButtonLabel\",\n      get: function get() {\n        return {\n          'month': this._intl.prevMonthLabel,\n          'year': this._intl.prevYearLabel,\n          'multi-year': this._intl.prevMultiYearLabel\n        }[this.calendar.currentView];\n      }\n      /**\n       * The label for the the next button.\n       * @return {?}\n       */\n\n    }, {\n      key: \"nextButtonLabel\",\n      get: function get() {\n        return {\n          'month': this._intl.nextMonthLabel,\n          'year': this._intl.nextYearLabel,\n          'multi-year': this._intl.nextMultiYearLabel\n        }[this.calendar.currentView];\n      }\n      /**\n       * Handles user clicks on the period label.\n       * @return {?}\n       */\n\n    }, {\n      key: \"currentPeriodClicked\",\n      value: function currentPeriodClicked() {\n        this.calendar.currentView = this.calendar.currentView == 'month' ? 'multi-year' : 'month';\n      }\n      /**\n       * Handles user clicks on the previous button.\n       * @return {?}\n       */\n\n    }, {\n      key: \"previousClicked\",\n      value: function previousClicked() {\n        this.calendar.activeDate = this.calendar.currentView == 'month' ? this._dateAdapter.addCalendarMonths(this.calendar.activeDate, -1) : this._dateAdapter.addCalendarYears(this.calendar.activeDate, this.calendar.currentView == 'year' ? -1 : -yearsPerPage);\n      }\n      /**\n       * Handles user clicks on the next button.\n       * @return {?}\n       */\n\n    }, {\n      key: \"nextClicked\",\n      value: function nextClicked() {\n        this.calendar.activeDate = this.calendar.currentView == 'month' ? this._dateAdapter.addCalendarMonths(this.calendar.activeDate, 1) : this._dateAdapter.addCalendarYears(this.calendar.activeDate, this.calendar.currentView == 'year' ? 1 : yearsPerPage);\n      }\n      /**\n       * Whether the previous period button is enabled.\n       * @return {?}\n       */\n\n    }, {\n      key: \"previousEnabled\",\n      value: function previousEnabled() {\n        if (!this.calendar.minDate) {\n          return true;\n        }\n\n        return !this.calendar.minDate || !this._isSameView(this.calendar.activeDate, this.calendar.minDate);\n      }\n      /**\n       * Whether the next period button is enabled.\n       * @return {?}\n       */\n\n    }, {\n      key: \"nextEnabled\",\n      value: function nextEnabled() {\n        return !this.calendar.maxDate || !this._isSameView(this.calendar.activeDate, this.calendar.maxDate);\n      }\n      /**\n       * Whether the two dates represent the same view in the current view mode (month or year).\n       * @param {?} date1\n       * @param {?} date2\n       * @return {?}\n       */\n\n    }, {\n      key: \"_isSameView\",\n      value: function _isSameView(date1, date2) {\n        if (this.calendar.currentView == 'month') {\n          return this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2) && this._dateAdapter.getMonth(date1) == this._dateAdapter.getMonth(date2);\n        }\n\n        if (this.calendar.currentView == 'year') {\n          return this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2);\n        } // Otherwise we are in 'multi-year' view.\n\n\n        return Math.floor(this._dateAdapter.getYear(date1) / yearsPerPage) == Math.floor(this._dateAdapter.getYear(date2) / yearsPerPage);\n      }\n    }]);\n\n    return MatCalendarHeader;\n  }();\n\n  MatCalendarHeader.ɵfac = function MatCalendarHeader_Factory(t) {\n    return new (t || MatCalendarHeader)(ɵngcc0.ɵɵdirectiveInject(MatDatepickerIntl), ɵngcc0.ɵɵdirectiveInject(forwardRef(function () {\n      return MatCalendar;\n    })), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.DateAdapter, 8), ɵngcc0.ɵɵdirectiveInject(MAT_DATE_FORMATS, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  MatCalendarHeader.ɵcmp =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineComponent({\n    type: MatCalendarHeader,\n    selectors: [[\"mat-calendar-header\"]],\n    exportAs: [\"matCalendarHeader\"],\n    ngContentSelectors: _c1,\n    decls: 9,\n    vars: 8,\n    consts: [[1, \"mat-calendar-header\"], [1, \"mat-calendar-controls\"], [\"mat-button\", \"\", \"type\", \"button\", \"cdkAriaLive\", \"polite\", 1, \"mat-calendar-period-button\", 3, \"click\"], [1, \"mat-calendar-arrow\"], [1, \"mat-calendar-spacer\"], [\"mat-icon-button\", \"\", \"type\", \"button\", 1, \"mat-calendar-previous-button\", 3, \"disabled\", \"click\"], [\"mat-icon-button\", \"\", \"type\", \"button\", 1, \"mat-calendar-next-button\", 3, \"disabled\", \"click\"]],\n    template: function MatCalendarHeader_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵelementStart(1, \"div\", 1);\n        ɵngcc0.ɵɵelementStart(2, \"button\", 2);\n        ɵngcc0.ɵɵlistener(\"click\", function MatCalendarHeader_Template_button_click_2_listener() {\n          return ctx.currentPeriodClicked();\n        });\n        ɵngcc0.ɵɵtext(3);\n        ɵngcc0.ɵɵelement(4, \"div\", 3);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelement(5, \"div\", 4);\n        ɵngcc0.ɵɵprojection(6);\n        ɵngcc0.ɵɵelementStart(7, \"button\", 5);\n        ɵngcc0.ɵɵlistener(\"click\", function MatCalendarHeader_Template_button_click_7_listener() {\n          return ctx.previousClicked();\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(8, \"button\", 6);\n        ɵngcc0.ɵɵlistener(\"click\", function MatCalendarHeader_Template_button_click_8_listener() {\n          return ctx.nextClicked();\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵattribute(\"aria-label\", ctx.periodButtonLabel);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵtextInterpolate(ctx.periodButtonText);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵclassProp(\"mat-calendar-invert\", ctx.calendar.currentView != \"month\");\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"disabled\", !ctx.previousEnabled());\n        ɵngcc0.ɵɵattribute(\"aria-label\", ctx.prevButtonLabel);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"disabled\", !ctx.nextEnabled());\n        ɵngcc0.ɵɵattribute(\"aria-label\", ctx.nextButtonLabel);\n      }\n    },\n    directives: [ɵngcc4.MatButton, ɵngcc5.CdkAriaLive],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MatCalendarHeader;\n}();\n\nvar MatCalendar = /*@__PURE__*/function () {\n  var MatCalendar = /*#__PURE__*/function () {\n    /**\n     * @param {?} _intl\n     * @param {?} _dateAdapter\n     * @param {?} _dateFormats\n     * @param {?} _changeDetectorRef\n     */\n    function MatCalendar(_intl, _dateAdapter, _dateFormats, _changeDetectorRef) {\n      var _this4 = this;\n\n      _classCallCheck(this, MatCalendar);\n\n      this._dateAdapter = _dateAdapter;\n      this._dateFormats = _dateFormats;\n      this._changeDetectorRef = _changeDetectorRef;\n      /**\n       * Used for scheduling that focus should be moved to the active cell on the next tick.\n       * We need to schedule it, rather than do it immediately, because we have to wait\n       * for Angular to re-evaluate the view children.\n       */\n\n      this._moveFocusOnNextTick = false;\n      /**\n       * Whether the calendar should be started in month or year view.\n       */\n\n      this.startView = 'month';\n      /**\n       * Emits when the currently selected date changes.\n       */\n\n      this.selectedChange = new EventEmitter();\n      /**\n       * Emits the year chosen in multiyear view.\n       * This doesn't imply a change on the selected date.\n       */\n\n      this.yearSelected = new EventEmitter();\n      /**\n       * Emits the month chosen in year view.\n       * This doesn't imply a change on the selected date.\n       */\n\n      this.monthSelected = new EventEmitter();\n      /**\n       * Emits when any date is selected.\n       */\n\n      this._userSelection = new EventEmitter();\n      /**\n       * Emits whenever there is a state change that the header may need to respond to.\n       */\n\n      this.stateChanges = new Subject();\n\n      if (!this._dateAdapter) {\n        throw createMissingDateImplError('DateAdapter');\n      }\n\n      if (!this._dateFormats) {\n        throw createMissingDateImplError('MAT_DATE_FORMATS');\n      }\n\n      this._intlChanges = _intl.changes.subscribe(function () {\n        _changeDetectorRef.markForCheck();\n\n        _this4.stateChanges.next();\n      });\n    }\n    /**\n     * A date representing the period (month or year) to start the calendar in.\n     * @return {?}\n     */\n\n\n    _createClass(MatCalendar, [{\n      key: \"startAt\",\n      get: function get() {\n        return this._startAt;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._startAt = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n      }\n      /**\n       * The currently selected date.\n       * @return {?}\n       */\n\n    }, {\n      key: \"selected\",\n      get: function get() {\n        return this._selected;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n      }\n      /**\n       * The minimum selectable date.\n       * @return {?}\n       */\n\n    }, {\n      key: \"minDate\",\n      get: function get() {\n        return this._minDate;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n      }\n      /**\n       * The maximum selectable date.\n       * @return {?}\n       */\n\n    }, {\n      key: \"maxDate\",\n      get: function get() {\n        return this._maxDate;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n      }\n      /**\n       * The current active date. This determines which time period is shown and which date is\n       * highlighted when using keyboard navigation.\n       * @return {?}\n       */\n\n    }, {\n      key: \"activeDate\",\n      get: function get() {\n        return this._clampedActiveDate;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._clampedActiveDate = this._dateAdapter.clampDate(value, this.minDate, this.maxDate);\n        this.stateChanges.next();\n      }\n      /**\n       * Whether the calendar is in month view.\n       * @return {?}\n       */\n\n    }, {\n      key: \"currentView\",\n      get: function get() {\n        return this._currentView;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._currentView = value;\n        this._moveFocusOnNextTick = true;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngAfterContentInit\",\n      value: function ngAfterContentInit() {\n        this._calendarHeaderPortal = new ComponentPortal(this.headerComponent || MatCalendarHeader);\n        this.activeDate = this.startAt || this._dateAdapter.today(); // Assign to the private property since we don't want to move focus on init.\n\n        this._currentView = this.startView;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngAfterViewChecked\",\n      value: function ngAfterViewChecked() {\n        if (this._moveFocusOnNextTick) {\n          this._moveFocusOnNextTick = false;\n          this.focusActiveCell();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this._intlChanges.unsubscribe();\n\n        this.stateChanges.complete();\n      }\n      /**\n       * @param {?} changes\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        /** @type {?} */\n        var change = changes[\"minDate\"] || changes[\"maxDate\"] || changes[\"dateFilter\"];\n\n        if (change && !change.firstChange) {\n          /** @type {?} */\n          var view = this._getCurrentViewComponent();\n\n          if (view) {\n            // We need to `detectChanges` manually here, because the `minDate`, `maxDate` etc. are\n            // passed down to the view via data bindings which won't be up-to-date when we call `_init`.\n            this._changeDetectorRef.detectChanges();\n\n            view._init();\n          }\n        }\n\n        this.stateChanges.next();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"focusActiveCell\",\n      value: function focusActiveCell() {\n        this._getCurrentViewComponent()._focusActiveCell();\n      }\n      /**\n       * Updates today's date after an update of the active date\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateTodaysDate\",\n      value: function updateTodaysDate() {\n        /** @type {?} */\n        var view = this.currentView == 'month' ? this.monthView : this.currentView == 'year' ? this.yearView : this.multiYearView;\n        view.ngAfterContentInit();\n      }\n      /**\n       * Handles date selection in the month view.\n       * @param {?} date\n       * @return {?}\n       */\n\n    }, {\n      key: \"_dateSelected\",\n      value: function _dateSelected(date) {\n        if (!this._dateAdapter.sameDate(date, this.selected)) {\n          this.selectedChange.emit(date);\n        }\n      }\n      /**\n       * Handles year selection in the multiyear view.\n       * @param {?} normalizedYear\n       * @return {?}\n       */\n\n    }, {\n      key: \"_yearSelectedInMultiYearView\",\n      value: function _yearSelectedInMultiYearView(normalizedYear) {\n        this.yearSelected.emit(normalizedYear);\n      }\n      /**\n       * Handles month selection in the year view.\n       * @param {?} normalizedMonth\n       * @return {?}\n       */\n\n    }, {\n      key: \"_monthSelectedInYearView\",\n      value: function _monthSelectedInYearView(normalizedMonth) {\n        this.monthSelected.emit(normalizedMonth);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"_userSelected\",\n      value: function _userSelected() {\n        this._userSelection.emit();\n      }\n      /**\n       * Handles year/month selection in the multi-year/year views.\n       * @param {?} date\n       * @param {?} view\n       * @return {?}\n       */\n\n    }, {\n      key: \"_goToDateInView\",\n      value: function _goToDateInView(date, view) {\n        this.activeDate = date;\n        this.currentView = view;\n      }\n      /**\n       * @param {?} obj The object to check.\n       * @return {?} The given object if it is both a date instance and valid, otherwise null.\n       */\n\n    }, {\n      key: \"_getValidDateOrNull\",\n      value: function _getValidDateOrNull(obj) {\n        return this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj) ? obj : null;\n      }\n      /**\n       * Returns the component instance that corresponds to the current calendar view.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_getCurrentViewComponent\",\n      value: function _getCurrentViewComponent() {\n        return this.monthView || this.yearView || this.multiYearView;\n      }\n    }]);\n\n    return MatCalendar;\n  }();\n\n  MatCalendar.ɵfac = function MatCalendar_Factory(t) {\n    return new (t || MatCalendar)(ɵngcc0.ɵɵdirectiveInject(MatDatepickerIntl), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.DateAdapter, 8), ɵngcc0.ɵɵdirectiveInject(MAT_DATE_FORMATS, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  MatCalendar.ɵcmp =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineComponent({\n    type: MatCalendar,\n    selectors: [[\"mat-calendar\"]],\n    viewQuery: function MatCalendar_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(MatMonthView, 5);\n        ɵngcc0.ɵɵviewQuery(MatYearView, 5);\n        ɵngcc0.ɵɵviewQuery(MatMultiYearView, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.monthView = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.yearView = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.multiYearView = _t.first);\n      }\n    },\n    hostAttrs: [1, \"mat-calendar\"],\n    inputs: {\n      startView: \"startView\",\n      startAt: \"startAt\",\n      selected: \"selected\",\n      minDate: \"minDate\",\n      maxDate: \"maxDate\",\n      headerComponent: \"headerComponent\",\n      dateFilter: \"dateFilter\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\",\n      yearSelected: \"yearSelected\",\n      monthSelected: \"monthSelected\",\n      _userSelection: \"_userSelection\"\n    },\n    exportAs: [\"matCalendar\"],\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 5,\n    vars: 5,\n    consts: [[3, \"cdkPortalOutlet\"], [\"cdkMonitorSubtreeFocus\", \"\", \"tabindex\", \"-1\", 1, \"mat-calendar-content\", 3, \"ngSwitch\"], [3, \"activeDate\", \"selected\", \"dateFilter\", \"maxDate\", \"minDate\", \"activeDateChange\", \"selectedChange\", \"_userSelection\", 4, \"ngSwitchCase\"], [3, \"activeDate\", \"selected\", \"dateFilter\", \"maxDate\", \"minDate\", \"activeDateChange\", \"monthSelected\", \"selectedChange\", 4, \"ngSwitchCase\"], [3, \"activeDate\", \"selected\", \"dateFilter\", \"maxDate\", \"minDate\", \"activeDateChange\", \"yearSelected\", \"selectedChange\", 4, \"ngSwitchCase\"], [3, \"activeDate\", \"selected\", \"dateFilter\", \"maxDate\", \"minDate\", \"activeDateChange\", \"selectedChange\", \"_userSelection\"], [3, \"activeDate\", \"selected\", \"dateFilter\", \"maxDate\", \"minDate\", \"activeDateChange\", \"monthSelected\", \"selectedChange\"], [3, \"activeDate\", \"selected\", \"dateFilter\", \"maxDate\", \"minDate\", \"activeDateChange\", \"yearSelected\", \"selectedChange\"]],\n    template: function MatCalendar_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, MatCalendar_ng_template_0_Template, 0, 0, \"ng-template\", 0);\n        ɵngcc0.ɵɵelementStart(1, \"div\", 1);\n        ɵngcc0.ɵɵtemplate(2, MatCalendar_mat_month_view_2_Template, 1, 5, \"mat-month-view\", 2);\n        ɵngcc0.ɵɵtemplate(3, MatCalendar_mat_year_view_3_Template, 1, 5, \"mat-year-view\", 3);\n        ɵngcc0.ɵɵtemplate(4, MatCalendar_mat_multi_year_view_4_Template, 1, 5, \"mat-multi-year-view\", 4);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"cdkPortalOutlet\", ctx._calendarHeaderPortal);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngSwitch\", ctx.currentView);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngSwitchCase\", \"month\");\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngSwitchCase\", \"year\");\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngSwitchCase\", \"multi-year\");\n      }\n    },\n    directives: [ɵngcc6.CdkPortalOutlet, ɵngcc5.CdkMonitorFocus, ɵngcc1.NgSwitch, ɵngcc1.NgSwitchCase, MatMonthView, MatYearView, MatMultiYearView],\n    styles: [\".mat-calendar{display:block}.mat-calendar-header{padding:8px 8px 0 8px}.mat-calendar-content{padding:0 8px 8px 8px;outline:0}.mat-calendar-controls{display:flex;margin:5% calc(33% / 7 - 16px)}.mat-calendar-spacer{flex:1 1 auto}.mat-calendar-period-button{min-width:0}.mat-calendar-arrow{display:inline-block;width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top-width:5px;border-top-style:solid;margin:0 0 0 5px;vertical-align:middle}.mat-calendar-arrow.mat-calendar-invert{transform:rotate(180deg)}[dir=rtl] .mat-calendar-arrow{margin:0 5px 0 0}.mat-calendar-next-button,.mat-calendar-previous-button{position:relative}.mat-calendar-next-button::after,.mat-calendar-previous-button::after{top:0;left:0;right:0;bottom:0;position:absolute;content:'';margin:15.5px;border:0 solid currentColor;border-top-width:2px}[dir=rtl] .mat-calendar-next-button,[dir=rtl] .mat-calendar-previous-button{transform:rotate(180deg)}.mat-calendar-previous-button::after{border-left-width:2px;transform:translateX(2px) rotate(-45deg)}.mat-calendar-next-button::after{border-right-width:2px;transform:translateX(-2px) rotate(45deg)}.mat-calendar-table{border-spacing:0;border-collapse:collapse;width:100%}.mat-calendar-table-header th{text-align:center;padding:0 0 8px 0}.mat-calendar-table-header-divider{position:relative;height:1px}.mat-calendar-table-header-divider::after{content:'';position:absolute;top:0;left:-8px;right:-8px;height:1px}\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MatCalendar;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** *\n * Animations used by the Material datepicker.\n * \\@docs-private\n  @type {?} */\n\n\nvar matDatepickerAnimations = {\n  /** Transforms the height of the datepicker's calendar. */\n  transformPanel: /*@__PURE__*/trigger('transformPanel', [/*@__PURE__*/state('void', /*@__PURE__*/style({\n    opacity: 0,\n    transform: 'scale(1, 0.8)'\n  })), /*@__PURE__*/transition('void => enter', /*@__PURE__*/animate('120ms cubic-bezier(0, 0, 0.2, 1)', /*@__PURE__*/style({\n    opacity: 1,\n    transform: 'scale(1, 1)'\n  }))), /*@__PURE__*/transition('* => void', /*@__PURE__*/animate('100ms linear', /*@__PURE__*/style({\n    opacity: 0\n  })))]),\n\n  /** Fades in the content of the calendar. */\n  fadeInCalendar: /*@__PURE__*/trigger('fadeInCalendar', [/*@__PURE__*/state('void', /*@__PURE__*/style({\n    opacity: 0\n  })), /*@__PURE__*/state('enter', /*@__PURE__*/style({\n    opacity: 1\n  })), // TODO(crisbeto): this animation should be removed since it isn't quite on spec, but we\n  // need to keep it until #12440 gets in, otherwise the exit animation will look glitchy.\n\n  /*@__PURE__*/\n  transition('void => *', /*@__PURE__*/animate('120ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)'))])\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** *\n * Used to generate a unique ID for each datepicker instance.\n  @type {?} */\n\nvar datepickerUid = 0;\n/** *\n * Injection token that determines the scroll handling while the calendar is open.\n  @type {?} */\n\nvar MAT_DATEPICKER_SCROLL_STRATEGY = /*@__PURE__*/new InjectionToken('mat-datepicker-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\n\nfunction MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY(overlay) {\n  return function () {\n    return overlay.scrollStrategies.reposition();\n  };\n}\n/** *\n * \\@docs-private\n  @type {?} */\n\n\nvar MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n  provide: MAT_DATEPICKER_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY\n};\n/**\n * \\@docs-private\n */\n\nvar MatDatepickerContentBase =\n/**\n * @param {?} _elementRef\n */\nfunction MatDatepickerContentBase(_elementRef) {\n  _classCallCheck(this, MatDatepickerContentBase);\n\n  this._elementRef = _elementRef;\n};\n/** @type {?} */\n\n\nvar _MatDatepickerContentMixinBase = /*@__PURE__*/mixinColor(MatDatepickerContentBase);\n\nvar MatDatepickerContent = /*@__PURE__*/function () {\n  var MatDatepickerContent = /*#__PURE__*/function (_MatDatepickerContent) {\n    _inherits(MatDatepickerContent, _MatDatepickerContent);\n\n    var _super = _createSuper(MatDatepickerContent);\n\n    /**\n     * @param {?} elementRef\n     */\n    function MatDatepickerContent(elementRef) {\n      _classCallCheck(this, MatDatepickerContent);\n\n      return _super.call(this, elementRef);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(MatDatepickerContent, [{\n      key: \"ngAfterViewInit\",\n      value: function ngAfterViewInit() {\n        this._calendar.focusActiveCell();\n      }\n    }]);\n\n    return MatDatepickerContent;\n  }(_MatDatepickerContentMixinBase);\n\n  MatDatepickerContent.ɵfac = function MatDatepickerContent_Factory(t) {\n    return new (t || MatDatepickerContent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MatDatepickerContent.ɵcmp =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineComponent({\n    type: MatDatepickerContent,\n    selectors: [[\"mat-datepicker-content\"]],\n    viewQuery: function MatDatepickerContent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(MatCalendar, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._calendar = _t.first);\n      }\n    },\n    hostAttrs: [1, \"mat-datepicker-content\"],\n    hostVars: 3,\n    hostBindings: function MatDatepickerContent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵsyntheticHostProperty(\"@transformPanel\", \"enter\");\n        ɵngcc0.ɵɵclassProp(\"mat-datepicker-content-touch\", ctx.datepicker.touchUi);\n      }\n    },\n    inputs: {\n      color: \"color\"\n    },\n    exportAs: [\"matDatepickerContent\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    decls: 1,\n    vars: 10,\n    consts: [[\"cdkTrapFocus\", \"\", 3, \"id\", \"ngClass\", \"startAt\", \"startView\", \"minDate\", \"maxDate\", \"dateFilter\", \"headerComponent\", \"selected\", \"selectedChange\", \"yearSelected\", \"monthSelected\", \"_userSelection\"]],\n    template: function MatDatepickerContent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"mat-calendar\", 0);\n        ɵngcc0.ɵɵlistener(\"selectedChange\", function MatDatepickerContent_Template_mat_calendar_selectedChange_0_listener($event) {\n          return ctx.datepicker.select($event);\n        })(\"yearSelected\", function MatDatepickerContent_Template_mat_calendar_yearSelected_0_listener($event) {\n          return ctx.datepicker._selectYear($event);\n        })(\"monthSelected\", function MatDatepickerContent_Template_mat_calendar_monthSelected_0_listener($event) {\n          return ctx.datepicker._selectMonth($event);\n        })(\"_userSelection\", function MatDatepickerContent_Template_mat_calendar__userSelection_0_listener() {\n          return ctx.datepicker.close();\n        });\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"id\", ctx.datepicker.id)(\"ngClass\", ctx.datepicker.panelClass)(\"startAt\", ctx.datepicker.startAt)(\"startView\", ctx.datepicker.startView)(\"minDate\", ctx.datepicker._minDate)(\"maxDate\", ctx.datepicker._maxDate)(\"dateFilter\", ctx.datepicker._dateFilter)(\"headerComponent\", ctx.datepicker.calendarHeaderComponent)(\"selected\", ctx.datepicker._selected)(\"@fadeInCalendar\", \"enter\");\n      }\n    },\n    directives: [MatCalendar, ɵngcc5.CdkTrapFocus, ɵngcc1.NgClass],\n    styles: [\".mat-datepicker-content{display:block;border-radius:4px}.mat-datepicker-content .mat-calendar{width:296px;height:354px}.mat-datepicker-content-touch{display:block;max-height:80vh;overflow:auto;margin:-24px}.mat-datepicker-content-touch .mat-calendar{min-width:250px;min-height:312px;max-width:750px;max-height:788px}@media all and (orientation:landscape){.mat-datepicker-content-touch .mat-calendar{width:64vh;height:80vh}}@media all and (orientation:portrait){.mat-datepicker-content-touch .mat-calendar{width:80vw;height:100vw}}\"],\n    encapsulation: 2,\n    data: {\n      animation: [matDatepickerAnimations.transformPanel, matDatepickerAnimations.fadeInCalendar]\n    },\n    changeDetection: 0\n  });\n  return MatDatepickerContent;\n}();\n\nvar MatDatepicker = /*@__PURE__*/function () {\n  var MatDatepicker = /*#__PURE__*/function () {\n    /**\n     * @param {?} _dialog\n     * @param {?} _overlay\n     * @param {?} _ngZone\n     * @param {?} _viewContainerRef\n     * @param {?} scrollStrategy\n     * @param {?} _dateAdapter\n     * @param {?} _dir\n     * @param {?} _document\n     */\n    function MatDatepicker(_dialog, _overlay, _ngZone, _viewContainerRef, scrollStrategy, _dateAdapter, _dir, _document) {\n      _classCallCheck(this, MatDatepicker);\n\n      this._dialog = _dialog;\n      this._overlay = _overlay;\n      this._ngZone = _ngZone;\n      this._viewContainerRef = _viewContainerRef;\n      this._dateAdapter = _dateAdapter;\n      this._dir = _dir;\n      this._document = _document;\n      /**\n       * The view that the calendar should start in.\n       */\n\n      this.startView = 'month';\n      this._touchUi = false;\n      /**\n       * Emits selected year in multiyear view.\n       * This doesn't imply a change on the selected date.\n       */\n\n      this.yearSelected = new EventEmitter();\n      /**\n       * Emits selected month in year view.\n       * This doesn't imply a change on the selected date.\n       */\n\n      this.monthSelected = new EventEmitter();\n      /**\n       * Emits when the datepicker has been opened.\n       */\n\n      this.openedStream = new EventEmitter();\n      /**\n       * Emits when the datepicker has been closed.\n       */\n\n      this.closedStream = new EventEmitter();\n      this._opened = false;\n      /**\n       * The id for the datepicker calendar.\n       */\n\n      this.id = \"mat-datepicker-\".concat(datepickerUid++);\n      this._validSelected = null;\n      /**\n       * The element that was focused before the datepicker was opened.\n       */\n\n      this._focusedElementBeforeOpen = null;\n      /**\n       * Subscription to value changes in the associated input element.\n       */\n\n      this._inputSubscription = Subscription.EMPTY;\n      /**\n       * Emits when the datepicker is disabled.\n       */\n\n      this._disabledChange = new Subject();\n      /**\n       * Emits new selected date when selected date changes.\n       */\n\n      this._selectedChanged = new Subject();\n\n      if (!this._dateAdapter) {\n        throw createMissingDateImplError('DateAdapter');\n      }\n\n      this._scrollStrategy = scrollStrategy;\n    }\n    /**\n     * The date to open the calendar to initially.\n     * @return {?}\n     */\n\n\n    _createClass(MatDatepicker, [{\n      key: \"startAt\",\n      get: function get() {\n        // If an explicit startAt is set we start there, otherwise we start at whatever the currently\n        // selected value is.\n        return this._startAt || (this._datepickerInput ? this._datepickerInput.value : null);\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._startAt = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n      }\n      /**\n       * Color palette to use on the datepicker's calendar.\n       * @return {?}\n       */\n\n    }, {\n      key: \"color\",\n      get: function get() {\n        return this._color || (this._datepickerInput ? this._datepickerInput._getThemePalette() : undefined);\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._color = value;\n      }\n      /**\n       * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather\n       * than a popup and elements have more padding to allow for bigger touch targets.\n       * @return {?}\n       */\n\n    }, {\n      key: \"touchUi\",\n      get: function get() {\n        return this._touchUi;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._touchUi = coerceBooleanProperty(value);\n      }\n      /**\n       * Whether the datepicker pop-up should be disabled.\n       * @return {?}\n       */\n\n    }, {\n      key: \"disabled\",\n      get: function get() {\n        return this._disabled === undefined && this._datepickerInput ? this._datepickerInput.disabled : !!this._disabled;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        /** @type {?} */\n        var newValue = coerceBooleanProperty(value);\n\n        if (newValue !== this._disabled) {\n          this._disabled = newValue;\n\n          this._disabledChange.next(newValue);\n        }\n      }\n      /**\n       * Whether the calendar is open.\n       * @return {?}\n       */\n\n    }, {\n      key: \"opened\",\n      get: function get() {\n        return this._opened;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        value ? this.open() : this.close();\n      }\n      /**\n       * The currently selected date.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_selected\",\n      get: function get() {\n        return this._validSelected;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._validSelected = value;\n      }\n      /**\n       * The minimum selectable date.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_minDate\",\n      get: function get() {\n        return this._datepickerInput && this._datepickerInput.min;\n      }\n      /**\n       * The maximum selectable date.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_maxDate\",\n      get: function get() {\n        return this._datepickerInput && this._datepickerInput.max;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"_dateFilter\",\n      get: function get() {\n        return this._datepickerInput && this._datepickerInput._dateFilter;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.close();\n\n        this._inputSubscription.unsubscribe();\n\n        this._disabledChange.complete();\n\n        if (this._popupRef) {\n          this._popupRef.dispose();\n\n          this._popupComponentRef = null;\n        }\n      }\n      /**\n       * Selects the given date\n       * @param {?} date\n       * @return {?}\n       */\n\n    }, {\n      key: \"select\",\n      value: function select(date) {\n        /** @type {?} */\n        var oldValue = this._selected;\n        this._selected = date;\n\n        if (!this._dateAdapter.sameDate(oldValue, this._selected)) {\n          this._selectedChanged.next(date);\n        }\n      }\n      /**\n       * Emits the selected year in multiyear view\n       * @param {?} normalizedYear\n       * @return {?}\n       */\n\n    }, {\n      key: \"_selectYear\",\n      value: function _selectYear(normalizedYear) {\n        this.yearSelected.emit(normalizedYear);\n      }\n      /**\n       * Emits selected month in year view\n       * @param {?} normalizedMonth\n       * @return {?}\n       */\n\n    }, {\n      key: \"_selectMonth\",\n      value: function _selectMonth(normalizedMonth) {\n        this.monthSelected.emit(normalizedMonth);\n      }\n      /**\n       * Register an input with this datepicker.\n       * @param {?} input The datepicker input to register with this datepicker.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_registerInput\",\n      value: function _registerInput(input) {\n        var _this5 = this;\n\n        if (this._datepickerInput) {\n          throw Error('A MatDatepicker can only be associated with a single input.');\n        }\n\n        this._datepickerInput = input;\n        this._inputSubscription = this._datepickerInput._valueChange.subscribe(function (value) {\n          return _this5._selected = value;\n        });\n      }\n      /**\n       * Open the calendar.\n       * @return {?}\n       */\n\n    }, {\n      key: \"open\",\n      value: function open() {\n        if (this._opened || this.disabled) {\n          return;\n        }\n\n        if (!this._datepickerInput) {\n          throw Error('Attempted to open an MatDatepicker with no associated input.');\n        }\n\n        if (this._document) {\n          this._focusedElementBeforeOpen = this._document.activeElement;\n        }\n\n        this.touchUi ? this._openAsDialog() : this._openAsPopup();\n        this._opened = true;\n        this.openedStream.emit();\n      }\n      /**\n       * Close the calendar.\n       * @return {?}\n       */\n\n    }, {\n      key: \"close\",\n      value: function close() {\n        var _this6 = this;\n\n        if (!this._opened) {\n          return;\n        }\n\n        if (this._popupRef && this._popupRef.hasAttached()) {\n          this._popupRef.detach();\n        }\n\n        if (this._dialogRef) {\n          this._dialogRef.close();\n\n          this._dialogRef = null;\n        }\n\n        if (this._calendarPortal && this._calendarPortal.isAttached) {\n          this._calendarPortal.detach();\n        }\n        /** @type {?} */\n\n\n        var completeClose = function completeClose() {\n          // The `_opened` could've been reset already if\n          // we got two events in quick succession.\n          if (_this6._opened) {\n            _this6._opened = false;\n\n            _this6.closedStream.emit();\n\n            _this6._focusedElementBeforeOpen = null;\n          }\n        };\n\n        if (this._focusedElementBeforeOpen && typeof this._focusedElementBeforeOpen.focus === 'function') {\n          // Because IE moves focus asynchronously, we can't count on it being restored before we've\n          // marked the datepicker as closed. If the event fires out of sequence and the element that\n          // we're refocusing opens the datepicker on focus, the user could be stuck with not being\n          // able to close the calendar at all. We work around it by making the logic, that marks\n          // the datepicker as closed, async as well.\n          this._focusedElementBeforeOpen.focus();\n\n          setTimeout(completeClose);\n        } else {\n          completeClose();\n        }\n      }\n      /**\n       * Open the calendar as a dialog.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_openAsDialog\",\n      value: function _openAsDialog() {\n        var _this7 = this;\n\n        // Usually this would be handled by `open` which ensures that we can only have one overlay\n        // open at a time, however since we reset the variables in async handlers some overlays\n        // may slip through if the user opens and closes multiple times in quick succession (e.g.\n        // by holding down the enter key).\n        if (this._dialogRef) {\n          this._dialogRef.close();\n        }\n\n        this._dialogRef = this._dialog.open(MatDatepickerContent, {\n          direction: this._dir ? this._dir.value : 'ltr',\n          viewContainerRef: this._viewContainerRef,\n          panelClass: 'mat-datepicker-dialog'\n        });\n\n        this._dialogRef.afterClosed().subscribe(function () {\n          return _this7.close();\n        });\n\n        this._dialogRef.componentInstance.datepicker = this;\n\n        this._setColor();\n      }\n      /**\n       * Open the calendar as a popup.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_openAsPopup\",\n      value: function _openAsPopup() {\n        var _this8 = this;\n\n        if (!this._calendarPortal) {\n          this._calendarPortal = new ComponentPortal(MatDatepickerContent, this._viewContainerRef);\n        }\n\n        if (!this._popupRef) {\n          this._createPopup();\n        }\n\n        if (!this._popupRef.hasAttached()) {\n          this._popupComponentRef = this._popupRef.attach(this._calendarPortal);\n          this._popupComponentRef.instance.datepicker = this;\n\n          this._setColor(); // Update the position once the calendar has rendered.\n\n\n          this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(function () {\n            _this8._popupRef.updatePosition();\n          });\n        }\n      }\n      /**\n       * Create the popup.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_createPopup\",\n      value: function _createPopup() {\n        var _this9 = this;\n\n        /** @type {?} */\n        var overlayConfig = new OverlayConfig({\n          positionStrategy: this._createPopupPositionStrategy(),\n          hasBackdrop: true,\n          backdropClass: 'mat-overlay-transparent-backdrop',\n          direction: this._dir,\n          scrollStrategy: this._scrollStrategy(),\n          panelClass: 'mat-datepicker-popup'\n        });\n        this._popupRef = this._overlay.create(overlayConfig);\n\n        this._popupRef.overlayElement.setAttribute('role', 'dialog');\n\n        merge(this._popupRef.backdropClick(), this._popupRef.detachments(), this._popupRef.keydownEvents().pipe(filter(function (event) {\n          // Closing on alt + up is only valid when there's an input associated with the datepicker.\n          return event.keyCode === ESCAPE || _this9._datepickerInput && event.altKey && event.keyCode === UP_ARROW;\n        }))).subscribe(function () {\n          return _this9.close();\n        });\n      }\n      /**\n       * Create the popup PositionStrategy.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_createPopupPositionStrategy\",\n      value: function _createPopupPositionStrategy() {\n        return this._overlay.position().flexibleConnectedTo(this._datepickerInput.getConnectedOverlayOrigin()).withTransformOriginOn('.mat-datepicker-content').withFlexibleDimensions(false).withViewportMargin(8).withLockedPosition().withPositions([{\n          originX: 'start',\n          originY: 'bottom',\n          overlayX: 'start',\n          overlayY: 'top'\n        }, {\n          originX: 'start',\n          originY: 'top',\n          overlayX: 'start',\n          overlayY: 'bottom'\n        }, {\n          originX: 'end',\n          originY: 'bottom',\n          overlayX: 'end',\n          overlayY: 'top'\n        }, {\n          originX: 'end',\n          originY: 'top',\n          overlayX: 'end',\n          overlayY: 'bottom'\n        }]);\n      }\n      /**\n       * @param {?} obj The object to check.\n       * @return {?} The given object if it is both a date instance and valid, otherwise null.\n       */\n\n    }, {\n      key: \"_getValidDateOrNull\",\n      value: function _getValidDateOrNull(obj) {\n        return this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj) ? obj : null;\n      }\n      /**\n       * Passes the current theme color along to the calendar overlay.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_setColor\",\n      value: function _setColor() {\n        /** @type {?} */\n        var color = this.color;\n\n        if (this._popupComponentRef) {\n          this._popupComponentRef.instance.color = color;\n        }\n\n        if (this._dialogRef) {\n          this._dialogRef.componentInstance.color = color;\n        }\n      }\n    }]);\n\n    return MatDatepicker;\n  }();\n\n  MatDatepicker.ɵfac = function MatDatepicker_Factory(t) {\n    return new (t || MatDatepicker)(ɵngcc0.ɵɵdirectiveInject(ɵngcc7.MatDialog), ɵngcc0.ɵɵdirectiveInject(ɵngcc8.Overlay), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(MAT_DATEPICKER_SCROLL_STRATEGY), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.DateAdapter, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Directionality, 8), ɵngcc0.ɵɵdirectiveInject(DOCUMENT, 8));\n  };\n\n  MatDatepicker.ɵcmp =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineComponent({\n    type: MatDatepicker,\n    selectors: [[\"mat-datepicker\"]],\n    inputs: {\n      startView: \"startView\",\n      startAt: \"startAt\",\n      color: \"color\",\n      touchUi: \"touchUi\",\n      disabled: \"disabled\",\n      opened: \"opened\",\n      calendarHeaderComponent: \"calendarHeaderComponent\",\n      panelClass: \"panelClass\"\n    },\n    outputs: {\n      yearSelected: \"yearSelected\",\n      monthSelected: \"monthSelected\",\n      openedStream: \"opened\",\n      closedStream: \"closed\"\n    },\n    exportAs: [\"matDatepicker\"],\n    decls: 0,\n    vars: 0,\n    template: function MatDatepicker_Template(rf, ctx) {},\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MatDatepicker;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** *\n * \\@docs-private\n  @type {?} */\n\n\nvar MAT_DATEPICKER_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: /*@__PURE__*/forwardRef(function () {\n    return MatDatepickerInput;\n  }),\n  multi: true\n};\n/** *\n * \\@docs-private\n  @type {?} */\n\nvar MAT_DATEPICKER_VALIDATORS = {\n  provide: NG_VALIDATORS,\n  useExisting: /*@__PURE__*/forwardRef(function () {\n    return MatDatepickerInput;\n  }),\n  multi: true\n};\n/**\n * An event used for datepicker input and change events. We don't always have access to a native\n * input or change event because the event may have been triggered by the user clicking on the\n * calendar popup. For consistency, we always use MatDatepickerInputEvent instead.\n * @template D\n */\n\nvar MatDatepickerInputEvent =\n/**\n * @param {?} target\n * @param {?} targetElement\n */\nfunction MatDatepickerInputEvent(target, targetElement) {\n  _classCallCheck(this, MatDatepickerInputEvent);\n\n  this.target = target;\n  this.targetElement = targetElement;\n  this.value = this.target.value;\n};\n\nvar MatDatepickerInput = /*@__PURE__*/function () {\n  var MatDatepickerInput = /*#__PURE__*/function () {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _dateAdapter\n     * @param {?} _dateFormats\n     * @param {?} _formField\n     */\n    function MatDatepickerInput(_elementRef, _dateAdapter, _dateFormats, _formField) {\n      var _this10 = this;\n\n      _classCallCheck(this, MatDatepickerInput);\n\n      this._elementRef = _elementRef;\n      this._dateAdapter = _dateAdapter;\n      this._dateFormats = _dateFormats;\n      this._formField = _formField;\n      /**\n       * Emits when a `change` event is fired on this `<input>`.\n       */\n\n      this.dateChange = new EventEmitter();\n      /**\n       * Emits when an `input` event is fired on this `<input>`.\n       */\n\n      this.dateInput = new EventEmitter();\n      /**\n       * Emits when the value changes (either due to user input or programmatic change).\n       */\n\n      this._valueChange = new EventEmitter();\n      /**\n       * Emits when the disabled state has changed\n       */\n\n      this._disabledChange = new EventEmitter();\n\n      this._onTouched = function () {};\n\n      this._cvaOnChange = function () {};\n\n      this._validatorOnChange = function () {};\n\n      this._datepickerSubscription = Subscription.EMPTY;\n      this._localeSubscription = Subscription.EMPTY;\n      /**\n       * The form control validator for whether the input parses.\n       */\n\n      this._parseValidator = function () {\n        return _this10._lastValueValid ? null : {\n          'matDatepickerParse': {\n            'text': _this10._elementRef.nativeElement.value\n          }\n        };\n      };\n      /**\n       * The form control validator for the min date.\n       */\n\n\n      this._minValidator = function (control) {\n        /** @type {?} */\n        var controlValue = _this10._getValidDateOrNull(_this10._dateAdapter.deserialize(control.value));\n\n        return !_this10.min || !controlValue || _this10._dateAdapter.compareDate(_this10.min, controlValue) <= 0 ? null : {\n          'matDatepickerMin': {\n            'min': _this10.min,\n            'actual': controlValue\n          }\n        };\n      };\n      /**\n       * The form control validator for the max date.\n       */\n\n\n      this._maxValidator = function (control) {\n        /** @type {?} */\n        var controlValue = _this10._getValidDateOrNull(_this10._dateAdapter.deserialize(control.value));\n\n        return !_this10.max || !controlValue || _this10._dateAdapter.compareDate(_this10.max, controlValue) >= 0 ? null : {\n          'matDatepickerMax': {\n            'max': _this10.max,\n            'actual': controlValue\n          }\n        };\n      };\n      /**\n       * The form control validator for the date filter.\n       */\n\n\n      this._filterValidator = function (control) {\n        /** @type {?} */\n        var controlValue = _this10._getValidDateOrNull(_this10._dateAdapter.deserialize(control.value));\n\n        return !_this10._dateFilter || !controlValue || _this10._dateFilter(controlValue) ? null : {\n          'matDatepickerFilter': true\n        };\n      };\n      /**\n       * The combined form control validator for this input.\n       */\n\n\n      this._validator = Validators.compose([this._parseValidator, this._minValidator, this._maxValidator, this._filterValidator]);\n      /**\n       * Whether the last value set on the input was valid.\n       */\n\n      this._lastValueValid = false;\n\n      if (!this._dateAdapter) {\n        throw createMissingDateImplError('DateAdapter');\n      }\n\n      if (!this._dateFormats) {\n        throw createMissingDateImplError('MAT_DATE_FORMATS');\n      } // Update the displayed date when the locale changes.\n\n\n      this._localeSubscription = _dateAdapter.localeChanges.subscribe(function () {\n        _this10.value = _this10.value;\n      });\n    }\n    /**\n     * The datepicker that this input is associated with.\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    _createClass(MatDatepickerInput, [{\n      key: \"matDatepicker\",\n      set: function set(value) {\n        var _this11 = this;\n\n        if (!value) {\n          return;\n        }\n\n        this._datepicker = value;\n\n        this._datepicker._registerInput(this);\n\n        this._datepickerSubscription.unsubscribe();\n\n        this._datepickerSubscription = this._datepicker._selectedChanged.subscribe(function (selected) {\n          _this11.value = selected;\n\n          _this11._cvaOnChange(selected);\n\n          _this11._onTouched();\n\n          _this11.dateInput.emit(new MatDatepickerInputEvent(_this11, _this11._elementRef.nativeElement));\n\n          _this11.dateChange.emit(new MatDatepickerInputEvent(_this11, _this11._elementRef.nativeElement));\n        });\n      }\n      /**\n       * Function that can be used to filter out dates within the datepicker.\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"matDatepickerFilter\",\n      set: function set(value) {\n        this._dateFilter = value;\n\n        this._validatorOnChange();\n      }\n      /**\n       * The value of the input.\n       * @return {?}\n       */\n\n    }, {\n      key: \"value\",\n      get: function get() {\n        return this._value;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        value = this._dateAdapter.deserialize(value);\n        this._lastValueValid = !value || this._dateAdapter.isValid(value);\n        value = this._getValidDateOrNull(value);\n        /** @type {?} */\n\n        var oldDate = this.value;\n        this._value = value;\n\n        this._formatValue(value);\n\n        if (!this._dateAdapter.sameDate(oldDate, value)) {\n          this._valueChange.emit(value);\n        }\n      }\n      /**\n       * The minimum valid date.\n       * @return {?}\n       */\n\n    }, {\n      key: \"min\",\n      get: function get() {\n        return this._min;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._min = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n\n        this._validatorOnChange();\n      }\n      /**\n       * The maximum valid date.\n       * @return {?}\n       */\n\n    }, {\n      key: \"max\",\n      get: function get() {\n        return this._max;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._max = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n\n        this._validatorOnChange();\n      }\n      /**\n       * Whether the datepicker-input is disabled.\n       * @return {?}\n       */\n\n    }, {\n      key: \"disabled\",\n      get: function get() {\n        return !!this._disabled;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        /** @type {?} */\n        var newValue = coerceBooleanProperty(value);\n        /** @type {?} */\n\n        var element = this._elementRef.nativeElement;\n\n        if (this._disabled !== newValue) {\n          this._disabled = newValue;\n\n          this._disabledChange.emit(newValue);\n        } // We need to null check the `blur` method, because it's undefined during SSR.\n\n\n        if (newValue && element.blur) {\n          // Normally, native input elements automatically blur if they turn disabled. This behavior\n          // is problematic, because it would mean that it triggers another change detection cycle,\n          // which then causes a changed after checked error if the input element was focused before.\n          element.blur();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this._datepickerSubscription.unsubscribe();\n\n        this._localeSubscription.unsubscribe();\n\n        this._valueChange.complete();\n\n        this._disabledChange.complete();\n      }\n      /**\n       * \\@docs-private\n       * @param {?} fn\n       * @return {?}\n       */\n\n    }, {\n      key: \"registerOnValidatorChange\",\n      value: function registerOnValidatorChange(fn) {\n        this._validatorOnChange = fn;\n      }\n      /**\n       * \\@docs-private\n       * @param {?} c\n       * @return {?}\n       */\n\n    }, {\n      key: \"validate\",\n      value: function validate(c) {\n        return this._validator ? this._validator(c) : null;\n      }\n      /**\n       * @deprecated\n       * \\@breaking-change 8.0.0 Use `getConnectedOverlayOrigin` instead\n       * @return {?}\n       */\n\n    }, {\n      key: \"getPopupConnectionElementRef\",\n      value: function getPopupConnectionElementRef() {\n        return this.getConnectedOverlayOrigin();\n      }\n      /**\n       * Gets the element that the datepicker popup should be connected to.\n       * @return {?} The element to connect the popup to.\n       */\n\n    }, {\n      key: \"getConnectedOverlayOrigin\",\n      value: function getConnectedOverlayOrigin() {\n        return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"writeValue\",\n      value: function writeValue(value) {\n        this.value = value;\n      }\n      /**\n       * @param {?} fn\n       * @return {?}\n       */\n\n    }, {\n      key: \"registerOnChange\",\n      value: function registerOnChange(fn) {\n        this._cvaOnChange = fn;\n      }\n      /**\n       * @param {?} fn\n       * @return {?}\n       */\n\n    }, {\n      key: \"registerOnTouched\",\n      value: function registerOnTouched(fn) {\n        this._onTouched = fn;\n      }\n      /**\n       * @param {?} isDisabled\n       * @return {?}\n       */\n\n    }, {\n      key: \"setDisabledState\",\n      value: function setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"_onKeydown\",\n      value: function _onKeydown(event) {\n        /** @type {?} */\n        var isAltDownArrow = event.altKey && event.keyCode === DOWN_ARROW;\n\n        if (this._datepicker && isAltDownArrow && !this._elementRef.nativeElement.readOnly) {\n          this._datepicker.open();\n\n          event.preventDefault();\n        }\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"_onInput\",\n      value: function _onInput(value) {\n        /** @type {?} */\n        var date = this._dateAdapter.parse(value, this._dateFormats.parse.dateInput);\n\n        this._lastValueValid = !date || this._dateAdapter.isValid(date);\n        date = this._getValidDateOrNull(date);\n\n        if (!this._dateAdapter.sameDate(date, this._value)) {\n          this._value = date;\n\n          this._cvaOnChange(date);\n\n          this._valueChange.emit(date);\n\n          this.dateInput.emit(new MatDatepickerInputEvent(this, this._elementRef.nativeElement));\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"_onChange\",\n      value: function _onChange() {\n        this.dateChange.emit(new MatDatepickerInputEvent(this, this._elementRef.nativeElement));\n      }\n      /**\n       * Returns the palette used by the input's form field, if any.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_getThemePalette\",\n      value: function _getThemePalette() {\n        return this._formField ? this._formField.color : undefined;\n      }\n      /**\n       * Handles blur events on the input.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_onBlur\",\n      value: function _onBlur() {\n        // Reformat the input only if we have a valid value.\n        if (this.value) {\n          this._formatValue(this.value);\n        }\n\n        this._onTouched();\n      }\n      /**\n       * Formats a value and sets it on the input element.\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"_formatValue\",\n      value: function _formatValue(value) {\n        this._elementRef.nativeElement.value = value ? this._dateAdapter.format(value, this._dateFormats.display.dateInput) : '';\n      }\n      /**\n       * @param {?} obj The object to check.\n       * @return {?} The given object if it is both a date instance and valid, otherwise null.\n       */\n\n    }, {\n      key: \"_getValidDateOrNull\",\n      value: function _getValidDateOrNull(obj) {\n        return this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj) ? obj : null;\n      }\n    }]);\n\n    return MatDatepickerInput;\n  }();\n\n  MatDatepickerInput.ɵfac = function MatDatepickerInput_Factory(t) {\n    return new (t || MatDatepickerInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.DateAdapter, 8), ɵngcc0.ɵɵdirectiveInject(MAT_DATE_FORMATS, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc9.MatFormField, 8));\n  };\n\n  MatDatepickerInput.ɵdir =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineDirective({\n    type: MatDatepickerInput,\n    selectors: [[\"input\", \"matDatepicker\", \"\"]],\n    hostVars: 5,\n    hostBindings: function MatDatepickerInput_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"input\", function MatDatepickerInput_input_HostBindingHandler($event) {\n          return ctx._onInput($event.target.value);\n        })(\"change\", function MatDatepickerInput_change_HostBindingHandler() {\n          return ctx._onChange();\n        })(\"blur\", function MatDatepickerInput_blur_HostBindingHandler() {\n          return ctx._onBlur();\n        })(\"keydown\", function MatDatepickerInput_keydown_HostBindingHandler($event) {\n          return ctx._onKeydown($event);\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵhostProperty(\"disabled\", ctx.disabled);\n        ɵngcc0.ɵɵattribute(\"aria-haspopup\", true)(\"aria-owns\", (ctx._datepicker == null ? null : ctx._datepicker.opened) && ctx._datepicker.id || null)(\"min\", ctx.min ? ctx._dateAdapter.toIso8601(ctx.min) : null)(\"max\", ctx.max ? ctx._dateAdapter.toIso8601(ctx.max) : null);\n      }\n    },\n    inputs: {\n      value: \"value\",\n      matDatepicker: \"matDatepicker\",\n      matDatepickerFilter: \"matDatepickerFilter\",\n      min: \"min\",\n      max: \"max\",\n      disabled: \"disabled\"\n    },\n    outputs: {\n      dateChange: \"dateChange\",\n      dateInput: \"dateInput\"\n    },\n    exportAs: [\"matDatepickerInput\"],\n    features: [/*@__PURE__*/ɵngcc0.ɵɵProvidersFeature([MAT_DATEPICKER_VALUE_ACCESSOR, MAT_DATEPICKER_VALIDATORS, {\n      provide: MAT_INPUT_VALUE_ACCESSOR,\n      useExisting: MatDatepickerInput\n    }])]\n  });\n  return MatDatepickerInput;\n}();\n\nvar MatDatepickerToggleIcon = /*@__PURE__*/function () {\n  var MatDatepickerToggleIcon = function MatDatepickerToggleIcon() {\n    _classCallCheck(this, MatDatepickerToggleIcon);\n  };\n\n  MatDatepickerToggleIcon.ɵfac = function MatDatepickerToggleIcon_Factory(t) {\n    return new (t || MatDatepickerToggleIcon)();\n  };\n\n  MatDatepickerToggleIcon.ɵdir =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineDirective({\n    type: MatDatepickerToggleIcon,\n    selectors: [[\"\", \"matDatepickerToggleIcon\", \"\"]]\n  });\n  return MatDatepickerToggleIcon;\n}();\n\nvar MatDatepickerToggle = /*@__PURE__*/function () {\n  var MatDatepickerToggle = /*#__PURE__*/function () {\n    /**\n     * @param {?} _intl\n     * @param {?} _changeDetectorRef\n     * @param {?} defaultTabIndex\n     */\n    function MatDatepickerToggle(_intl, _changeDetectorRef, defaultTabIndex) {\n      _classCallCheck(this, MatDatepickerToggle);\n\n      this._intl = _intl;\n      this._changeDetectorRef = _changeDetectorRef;\n      this._stateChanges = Subscription.EMPTY;\n      /** @type {?} */\n\n      var parsedTabIndex = Number(defaultTabIndex);\n      this.tabIndex = parsedTabIndex || parsedTabIndex === 0 ? parsedTabIndex : null;\n    }\n    /**\n     * Whether the toggle button is disabled.\n     * @return {?}\n     */\n\n\n    _createClass(MatDatepickerToggle, [{\n      key: \"disabled\",\n      get: function get() {\n        return this._disabled === undefined ? this.datepicker.disabled : !!this._disabled;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._disabled = coerceBooleanProperty(value);\n      }\n      /**\n       * @param {?} changes\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        if (changes[\"datepicker\"]) {\n          this._watchStateChanges();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this._stateChanges.unsubscribe();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngAfterContentInit\",\n      value: function ngAfterContentInit() {\n        this._watchStateChanges();\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"_open\",\n      value: function _open(event) {\n        if (this.datepicker && !this.disabled) {\n          this.datepicker.open();\n          event.stopPropagation();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"_watchStateChanges\",\n      value: function _watchStateChanges() {\n        var _this12 = this;\n\n        /** @type {?} */\n        var datepickerDisabled = this.datepicker ? this.datepicker._disabledChange : of();\n        /** @type {?} */\n\n        var inputDisabled = this.datepicker && this.datepicker._datepickerInput ? this.datepicker._datepickerInput._disabledChange : of();\n        /** @type {?} */\n\n        var datepickerToggled = this.datepicker ? merge(this.datepicker.openedStream, this.datepicker.closedStream) : of();\n\n        this._stateChanges.unsubscribe();\n\n        this._stateChanges = merge(this._intl.changes, datepickerDisabled, inputDisabled, datepickerToggled).subscribe(function () {\n          return _this12._changeDetectorRef.markForCheck();\n        });\n      }\n    }]);\n\n    return MatDatepickerToggle;\n  }();\n\n  MatDatepickerToggle.ɵfac = function MatDatepickerToggle_Factory(t) {\n    return new (t || MatDatepickerToggle)(ɵngcc0.ɵɵdirectiveInject(MatDatepickerIntl), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵinjectAttribute('tabindex'));\n  };\n\n  MatDatepickerToggle.ɵcmp =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineComponent({\n    type: MatDatepickerToggle,\n    selectors: [[\"mat-datepicker-toggle\"]],\n    contentQueries: function MatDatepickerToggle_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MatDatepickerToggleIcon, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._customIcon = _t.first);\n      }\n    },\n    hostAttrs: [1, \"mat-datepicker-toggle\"],\n    hostVars: 7,\n    hostBindings: function MatDatepickerToggle_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"tabindex\", null);\n        ɵngcc0.ɵɵclassProp(\"mat-datepicker-toggle-active\", ctx.datepicker && ctx.datepicker.opened)(\"mat-accent\", ctx.datepicker && ctx.datepicker.color === \"accent\")(\"mat-warn\", ctx.datepicker && ctx.datepicker.color === \"warn\");\n      }\n    },\n    inputs: {\n      tabIndex: \"tabIndex\",\n      disabled: \"disabled\",\n      datepicker: [\"for\", \"datepicker\"]\n    },\n    exportAs: [\"matDatepickerToggle\"],\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c3,\n    decls: 3,\n    vars: 4,\n    consts: [[\"mat-icon-button\", \"\", \"type\", \"button\", \"aria-haspopup\", \"true\", 3, \"disabled\", \"click\"], [\"class\", \"mat-datepicker-toggle-default-icon\", \"viewBox\", \"0 0 24 24\", \"width\", \"24px\", \"height\", \"24px\", \"fill\", \"currentColor\", \"focusable\", \"false\", 4, \"ngIf\"], [\"viewBox\", \"0 0 24 24\", \"width\", \"24px\", \"height\", \"24px\", \"fill\", \"currentColor\", \"focusable\", \"false\", 1, \"mat-datepicker-toggle-default-icon\"], [\"d\", \"M0 0h24v24H0z\", \"fill\", \"none\"], [\"d\", \"M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z\"]],\n    template: function MatDatepickerToggle_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef(_c2);\n        ɵngcc0.ɵɵelementStart(0, \"button\", 0);\n        ɵngcc0.ɵɵlistener(\"click\", function MatDatepickerToggle_Template_button_click_0_listener($event) {\n          return ctx._open($event);\n        });\n        ɵngcc0.ɵɵtemplate(1, MatDatepickerToggle__svg_svg_1_Template, 3, 0, \"svg\", 1);\n        ɵngcc0.ɵɵprojection(2);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"disabled\", ctx.disabled);\n        ɵngcc0.ɵɵattribute(\"aria-label\", ctx._intl.openCalendarLabel)(\"tabindex\", ctx.disabled ? -1 : ctx.tabIndex);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx._customIcon);\n      }\n    },\n    directives: [ɵngcc4.MatButton, ɵngcc1.NgIf],\n    styles: [\".mat-form-field-appearance-legacy .mat-form-field-prefix .mat-datepicker-toggle-default-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-datepicker-toggle-default-icon{width:1em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-datepicker-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-datepicker-toggle-default-icon{display:block;width:1.5em;height:1.5em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-datepicker-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-datepicker-toggle-default-icon{margin:auto}\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MatDatepickerToggle;\n}();\n\nvar MatDatepickerModule = /*@__PURE__*/function () {\n  var MatDatepickerModule = function MatDatepickerModule() {\n    _classCallCheck(this, MatDatepickerModule);\n  };\n\n  MatDatepickerModule.ɵfac = function MatDatepickerModule_Factory(t) {\n    return new (t || MatDatepickerModule)();\n  };\n\n  MatDatepickerModule.ɵmod =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineNgModule({\n    type: MatDatepickerModule\n  });\n  MatDatepickerModule.ɵinj =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineInjector({\n    providers: [MatDatepickerIntl, MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER],\n    imports: [[CommonModule, MatButtonModule, MatDialogModule, OverlayModule, A11yModule, PortalModule]]\n  });\n  return MatDatepickerModule;\n}();\n/*@__PURE__*/\n\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatDatepickerModule, {\n    declarations: function declarations() {\n      return [MatCalendar, MatCalendarBody, MatDatepicker, MatDatepickerContent, MatDatepickerInput, MatDatepickerToggle, MatDatepickerToggleIcon, MatMonthView, MatYearView, MatMultiYearView, MatCalendarHeader];\n    },\n    imports: function imports() {\n      return [CommonModule, MatButtonModule, MatDialogModule, OverlayModule, A11yModule, PortalModule];\n    },\n    exports: function exports() {\n      return [MatCalendar, MatCalendarBody, MatDatepicker, MatDatepickerContent, MatDatepickerInput, MatDatepickerToggle, MatDatepickerToggleIcon, MatMonthView, MatYearView, MatMultiYearView, MatCalendarHeader];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nexport { MatDatepickerModule, MatCalendarHeader, MatCalendar, MatCalendarCell, MatCalendarBody, MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY, MAT_DATEPICKER_SCROLL_STRATEGY, MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER, MatDatepickerContentBase, _MatDatepickerContentMixinBase, MatDatepickerContent, MatDatepicker, matDatepickerAnimations, MAT_DATEPICKER_VALUE_ACCESSOR, MAT_DATEPICKER_VALIDATORS, MatDatepickerInputEvent, MatDatepickerInput, MatDatepickerIntl, MatDatepickerToggleIcon, MatDatepickerToggle, MatMonthView, MatYearView, MatMultiYearView as ɵa34 }; //# sourceMappingURL=datepicker.js.map","map":null,"metadata":{},"sourceType":"module"}