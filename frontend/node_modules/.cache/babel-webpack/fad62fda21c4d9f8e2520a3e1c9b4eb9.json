{"ast":null,"code":"import _createClass from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { InjectionToken, Attribute, ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, forwardRef, Inject, Input, NgZone, Optional, Output, ViewChild, ViewEncapsulation, Directive, NgModule } from '@angular/core';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { NG_VALUE_ACCESSOR, CheckboxRequiredValidator, NG_VALIDATORS } from '@angular/forms';\nimport { MatRipple, mixinColor, mixinDisabled, mixinDisableRipple, mixinTabIndex, MatCommonModule, MatRippleModule } from '@angular/material/core';\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\nimport { ObserversModule } from '@angular/cdk/observers';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** *\n * Injection token that can be used to specify the checkbox click behavior.\n  @type {?} */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/a11y';\nimport * as ɵngcc2 from '@angular/material/core';\nimport * as ɵngcc3 from '@angular/cdk/observers';\nvar _c0 = [\"input\"];\n\nvar _c1 = function _c1() {\n  return {\n    enterDuration: 150\n  };\n};\n\nvar _c2 = [\"*\"];\nvar MAT_CHECKBOX_CLICK_ACTION = /*@__PURE__*/new InjectionToken('mat-checkbox-click-action');\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\nvar nextUniqueId = 0;\n/** @type {?} */\n\nvar calculatedRippleRadius = 0;\n/** *\n * Provider Expression that allows mat-checkbox to register as a ControlValueAccessor.\n * This allows it to support [(ngModel)].\n * \\@docs-private\n  @type {?} */\n\nvar MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: /*@__PURE__*/forwardRef(function () {\n    return MatCheckbox;\n  }),\n  multi: true\n};\n/** @enum {number} */\n\nvar TransitionCheckState = {\n  /** The initial state of the component before any user interaction. */\n  Init: 0,\n\n  /** The state representing the component when it's becoming checked. */\n  Checked: 1,\n\n  /** The state representing the component when it's becoming unchecked. */\n  Unchecked: 2,\n\n  /** The state representing the component when it's becoming indeterminate. */\n  Indeterminate: 3\n};\nTransitionCheckState[TransitionCheckState.Init] = 'Init';\nTransitionCheckState[TransitionCheckState.Checked] = 'Checked';\nTransitionCheckState[TransitionCheckState.Unchecked] = 'Unchecked';\nTransitionCheckState[TransitionCheckState.Indeterminate] = 'Indeterminate';\n/**\n * Change event object emitted by MatCheckbox.\n */\n\nvar MatCheckboxChange = function MatCheckboxChange() {\n  _classCallCheck(this, MatCheckboxChange);\n};\n/**\n * \\@docs-private\n */\n\n\nvar MatCheckboxBase =\n/**\n * @param {?} _elementRef\n */\nfunction MatCheckboxBase(_elementRef) {\n  _classCallCheck(this, MatCheckboxBase);\n\n  this._elementRef = _elementRef;\n};\n/** @type {?} */\n\n\nvar _MatCheckboxMixinBase = /*@__PURE__*/mixinTabIndex( /*@__PURE__*/mixinColor( /*@__PURE__*/mixinDisableRipple( /*@__PURE__*/mixinDisabled(MatCheckboxBase)), 'accent'));\n\nvar MatCheckbox = /*@__PURE__*/function () {\n  var MatCheckbox = /*#__PURE__*/function (_MatCheckboxMixinBase2) {\n    _inherits(MatCheckbox, _MatCheckboxMixinBase2);\n\n    var _super = _createSuper(MatCheckbox);\n\n    /**\n     * @param {?} elementRef\n     * @param {?} _changeDetectorRef\n     * @param {?} _focusMonitor\n     * @param {?} _ngZone\n     * @param {?} tabIndex\n     * @param {?} _clickAction\n     * @param {?=} _animationMode\n     */\n    function MatCheckbox(elementRef, _changeDetectorRef, _focusMonitor, _ngZone, tabIndex, _clickAction, _animationMode) {\n      var _this;\n\n      _classCallCheck(this, MatCheckbox);\n\n      _this = _super.call(this, elementRef);\n      _this._changeDetectorRef = _changeDetectorRef;\n      _this._focusMonitor = _focusMonitor;\n      _this._ngZone = _ngZone;\n      _this._clickAction = _clickAction;\n      _this._animationMode = _animationMode;\n      /**\n       * Attached to the aria-label attribute of the host element. In most cases, arial-labelledby will\n       * take precedence so this may be omitted.\n       */\n\n      _this.ariaLabel = '';\n      /**\n       * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element\n       */\n\n      _this.ariaLabelledby = null;\n      _this._uniqueId = \"mat-checkbox-\".concat(++nextUniqueId);\n      /**\n       * A unique id for the checkbox input. If none is supplied, it will be auto-generated.\n       */\n\n      _this.id = _this._uniqueId;\n      /**\n       * Whether the label should appear after or before the checkbox. Defaults to 'after'\n       */\n\n      _this.labelPosition = 'after';\n      /**\n       * Name value will be applied to the input element if present\n       */\n\n      _this.name = null;\n      /**\n       * Event emitted when the checkbox's `checked` value changes.\n       */\n\n      _this.change = new EventEmitter();\n      /**\n       * Event emitted when the checkbox's `indeterminate` value changes.\n       */\n\n      _this.indeterminateChange = new EventEmitter();\n      /**\n       * Called when the checkbox is blurred. Needed to properly implement ControlValueAccessor.\n       * \\@docs-private\n       */\n\n      _this._onTouched = function () {};\n\n      _this._currentAnimationClass = '';\n      _this._currentCheckState = TransitionCheckState.Init;\n\n      _this._controlValueAccessorChangeFn = function () {};\n\n      _this._checked = false;\n      _this._disabled = false;\n      _this._indeterminate = false;\n      _this.tabIndex = parseInt(tabIndex) || 0;\n\n      _this._focusMonitor.monitor(elementRef, true).subscribe(function (focusOrigin) {\n        if (!focusOrigin) {\n          // When a focused element becomes disabled, the browser *immediately* fires a blur event.\n          // Angular does not expect events to be raised during change detection, so any state change\n          // (such as a form control's 'ng-touched') will cause a changed-after-checked error.\n          // See https://github.com/angular/angular/issues/17793. To work around this, we defer\n          // telling the form control it has been touched until the next tick.\n          Promise.resolve().then(function () {\n            return _this._onTouched();\n          });\n        }\n      });\n\n      return _this;\n    }\n    /**\n     * Returns the unique id for the visual hidden input.\n     * @return {?}\n     */\n\n\n    _createClass(MatCheckbox, [{\n      key: \"inputId\",\n      get: function get() {\n        return \"\".concat(this.id || this._uniqueId, \"-input\");\n      }\n      /**\n       * Whether the checkbox is required.\n       * @return {?}\n       */\n\n    }, {\n      key: \"required\",\n      get: function get() {\n        return this._required;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._required = coerceBooleanProperty(value);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngAfterViewChecked\",\n      value: function ngAfterViewChecked() {\n        this._calculateRippleRadius();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this._focusMonitor.stopMonitoring(this._elementRef);\n      }\n      /**\n       * Whether the checkbox is checked.\n       * @return {?}\n       */\n\n    }, {\n      key: \"checked\",\n      get: function get() {\n        return this._checked;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        if (value != this.checked) {\n          this._checked = value;\n\n          this._changeDetectorRef.markForCheck();\n        }\n      }\n      /**\n       * Whether the checkbox is disabled. This fully overrides the implementation provided by\n       * mixinDisabled, but the mixin is still required because mixinTabIndex requires it.\n       * @return {?}\n       */\n\n    }, {\n      key: \"disabled\",\n      get: function get() {\n        return this._disabled;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        if (value != this.disabled) {\n          this._disabled = value;\n\n          this._changeDetectorRef.markForCheck();\n        }\n      }\n      /**\n       * Whether the checkbox is indeterminate. This is also known as \"mixed\" mode and can be used to\n       * represent a checkbox with three states, e.g. a checkbox that represents a nested list of\n       * checkable items. Note that whenever checkbox is manually clicked, indeterminate is immediately\n       * set to false.\n       * @return {?}\n       */\n\n    }, {\n      key: \"indeterminate\",\n      get: function get() {\n        return this._indeterminate;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        /** @type {?} */\n        var changed = value != this._indeterminate;\n        this._indeterminate = value;\n\n        if (changed) {\n          if (this._indeterminate) {\n            this._transitionCheckState(TransitionCheckState.Indeterminate);\n          } else {\n            this._transitionCheckState(this.checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked);\n          }\n\n          this.indeterminateChange.emit(this._indeterminate);\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"_isRippleDisabled\",\n      value: function _isRippleDisabled() {\n        return this.disableRipple || this.disabled;\n      }\n      /**\n       * Method being called whenever the label text changes.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_onLabelTextChange\",\n      value: function _onLabelTextChange() {\n        // Since the event of the `cdkObserveContent` directive runs outside of the zone, the checkbox\n        // component will be only marked for check, but no actual change detection runs automatically.\n        // Instead of going back into the zone in order to trigger a change detection which causes\n        // *all* components to be checked (if explicitly marked or not using OnPush), we only trigger\n        // an explicit change detection for the checkbox view and it's children.\n        this._changeDetectorRef.detectChanges();\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"writeValue\",\n      value: function writeValue(value) {\n        this.checked = !!value;\n      }\n      /**\n       * @param {?} fn\n       * @return {?}\n       */\n\n    }, {\n      key: \"registerOnChange\",\n      value: function registerOnChange(fn) {\n        this._controlValueAccessorChangeFn = fn;\n      }\n      /**\n       * @param {?} fn\n       * @return {?}\n       */\n\n    }, {\n      key: \"registerOnTouched\",\n      value: function registerOnTouched(fn) {\n        this._onTouched = fn;\n      }\n      /**\n       * @param {?} isDisabled\n       * @return {?}\n       */\n\n    }, {\n      key: \"setDisabledState\",\n      value: function setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"_getAriaChecked\",\n      value: function _getAriaChecked() {\n        return this.checked ? 'true' : this.indeterminate ? 'mixed' : 'false';\n      }\n      /**\n       * @param {?} newState\n       * @return {?}\n       */\n\n    }, {\n      key: \"_transitionCheckState\",\n      value: function _transitionCheckState(newState) {\n        /** @type {?} */\n        var oldState = this._currentCheckState;\n        /** @type {?} */\n\n        var element = this._elementRef.nativeElement;\n\n        if (oldState === newState) {\n          return;\n        }\n\n        if (this._currentAnimationClass.length > 0) {\n          element.classList.remove(this._currentAnimationClass);\n        }\n\n        this._currentAnimationClass = this._getAnimationClassForCheckStateTransition(oldState, newState);\n        this._currentCheckState = newState;\n\n        if (this._currentAnimationClass.length > 0) {\n          element.classList.add(this._currentAnimationClass);\n          /** @type {?} */\n\n          var animationClass = this._currentAnimationClass;\n\n          this._ngZone.runOutsideAngular(function () {\n            setTimeout(function () {\n              element.classList.remove(animationClass);\n            }, 1000);\n          });\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"_emitChangeEvent\",\n      value: function _emitChangeEvent() {\n        /** @type {?} */\n        var event = new MatCheckboxChange();\n        event.source = this;\n        event.checked = this.checked;\n\n        this._controlValueAccessorChangeFn(this.checked);\n\n        this.change.emit(event);\n      }\n      /**\n       * Toggles the `checked` state of the checkbox.\n       * @return {?}\n       */\n\n    }, {\n      key: \"toggle\",\n      value: function toggle() {\n        this.checked = !this.checked;\n      }\n      /**\n       * Event handler for checkbox input element.\n       * Toggles checked state if element is not disabled.\n       * Do not toggle on (change) event since IE doesn't fire change event when\n       *   indeterminate checkbox is clicked.\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"_onInputClick\",\n      value: function _onInputClick(event) {\n        var _this2 = this;\n\n        // We have to stop propagation for click events on the visual hidden input element.\n        // By default, when a user clicks on a label element, a generated click event will be\n        // dispatched on the associated input element. Since we are using a label element as our\n        // root container, the click event on the `checkbox` will be executed twice.\n        // The real click event will bubble up, and the generated click event also tries to bubble up.\n        // This will lead to multiple click events.\n        // Preventing bubbling for the second event will solve that issue.\n        event.stopPropagation(); // If resetIndeterminate is false, and the current state is indeterminate, do nothing on click\n\n        if (!this.disabled && this._clickAction !== 'noop') {\n          // When user manually click on the checkbox, `indeterminate` is set to false.\n          if (this.indeterminate && this._clickAction !== 'check') {\n            Promise.resolve().then(function () {\n              _this2._indeterminate = false;\n\n              _this2.indeterminateChange.emit(_this2._indeterminate);\n            });\n          }\n\n          this.toggle();\n\n          this._transitionCheckState(this._checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked); // Emit our custom change event if the native input emitted one.\n          // It is important to only emit it, if the native input triggered one, because\n          // we don't want to trigger a change event, when the `checked` variable changes for example.\n\n\n          this._emitChangeEvent();\n        } else if (!this.disabled && this._clickAction === 'noop') {\n          // Reset native input when clicked with noop. The native checkbox becomes checked after\n          // click, reset it to be align with `checked` value of `mat-checkbox`.\n          this._inputElement.nativeElement.checked = this.checked;\n          this._inputElement.nativeElement.indeterminate = this.indeterminate;\n        }\n      }\n      /**\n       * Focuses the checkbox.\n       * @return {?}\n       */\n\n    }, {\n      key: \"focus\",\n      value: function focus() {\n        this._focusMonitor.focusVia(this._inputElement, 'keyboard');\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"_onInteractionEvent\",\n      value: function _onInteractionEvent(event) {\n        // We always have to stop propagation on the change event.\n        // Otherwise the change event, from the input element, will bubble up and\n        // emit its event object to the `change` output.\n        event.stopPropagation();\n      }\n      /**\n       * @param {?} oldState\n       * @param {?} newState\n       * @return {?}\n       */\n\n    }, {\n      key: \"_getAnimationClassForCheckStateTransition\",\n      value: function _getAnimationClassForCheckStateTransition(oldState, newState) {\n        // Don't transition if animations are disabled.\n        if (this._animationMode === 'NoopAnimations') {\n          return '';\n        }\n        /** @type {?} */\n\n\n        var animSuffix = '';\n\n        switch (oldState) {\n          case TransitionCheckState.Init:\n            // Handle edge case where user interacts with checkbox that does not have [(ngModel)] or\n            // [checked] bound to it.\n            if (newState === TransitionCheckState.Checked) {\n              animSuffix = 'unchecked-checked';\n            } else if (newState == TransitionCheckState.Indeterminate) {\n              animSuffix = 'unchecked-indeterminate';\n            } else {\n              return '';\n            }\n\n            break;\n\n          case TransitionCheckState.Unchecked:\n            animSuffix = newState === TransitionCheckState.Checked ? 'unchecked-checked' : 'unchecked-indeterminate';\n            break;\n\n          case TransitionCheckState.Checked:\n            animSuffix = newState === TransitionCheckState.Unchecked ? 'checked-unchecked' : 'checked-indeterminate';\n            break;\n\n          case TransitionCheckState.Indeterminate:\n            animSuffix = newState === TransitionCheckState.Checked ? 'indeterminate-checked' : 'indeterminate-unchecked';\n            break;\n        }\n\n        return \"mat-checkbox-anim-\".concat(animSuffix);\n      }\n      /**\n       * Calculate the radius for the ripple based on the ripple elements width.  Only calculated once\n       * for the application.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_calculateRippleRadius\",\n      value: function _calculateRippleRadius() {\n        if (!calculatedRippleRadius) {\n          /** @type {?} */\n          var rippleWidth = this._elementRef.nativeElement.querySelector('.mat-checkbox-ripple').clientWidth || 0;\n          calculatedRippleRadius = rippleWidth / 2;\n        }\n\n        this.ripple.radius = calculatedRippleRadius;\n      }\n    }]);\n\n    return MatCheckbox;\n  }(_MatCheckboxMixinBase);\n\n  MatCheckbox.ɵfac = function MatCheckbox_Factory(t) {\n    return new (t || MatCheckbox)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.FocusMonitor), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵinjectAttribute('tabindex'), ɵngcc0.ɵɵdirectiveInject(MAT_CHECKBOX_CLICK_ACTION, 8), ɵngcc0.ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8));\n  };\n\n  MatCheckbox.ɵcmp =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineComponent({\n    type: MatCheckbox,\n    selectors: [[\"mat-checkbox\"]],\n    viewQuery: function MatCheckbox_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 5);\n        ɵngcc0.ɵɵviewQuery(MatRipple, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputElement = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ripple = _t.first);\n      }\n    },\n    hostAttrs: [1, \"mat-checkbox\"],\n    hostVars: 12,\n    hostBindings: function MatCheckbox_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵhostProperty(\"id\", ctx.id);\n        ɵngcc0.ɵɵattribute(\"tabindex\", null);\n        ɵngcc0.ɵɵclassProp(\"mat-checkbox-indeterminate\", ctx.indeterminate)(\"mat-checkbox-checked\", ctx.checked)(\"mat-checkbox-disabled\", ctx.disabled)(\"mat-checkbox-label-before\", ctx.labelPosition == \"before\")(\"_mat-animation-noopable\", ctx._animationMode === \"NoopAnimations\");\n      }\n    },\n    inputs: {\n      disableRipple: \"disableRipple\",\n      color: \"color\",\n      tabIndex: \"tabIndex\",\n      ariaLabel: [\"aria-label\", \"ariaLabel\"],\n      ariaLabelledby: [\"aria-labelledby\", \"ariaLabelledby\"],\n      id: \"id\",\n      labelPosition: \"labelPosition\",\n      name: \"name\",\n      required: \"required\",\n      checked: \"checked\",\n      disabled: \"disabled\",\n      indeterminate: \"indeterminate\",\n      value: \"value\"\n    },\n    outputs: {\n      change: \"change\",\n      indeterminateChange: \"indeterminateChange\"\n    },\n    exportAs: [\"matCheckbox\"],\n    features: [/*@__PURE__*/ɵngcc0.ɵɵProvidersFeature([MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c2,\n    decls: 17,\n    vars: 20,\n    consts: [[1, \"mat-checkbox-layout\"], [\"label\", \"\"], [1, \"mat-checkbox-inner-container\"], [\"type\", \"checkbox\", 1, \"mat-checkbox-input\", \"cdk-visually-hidden\", 3, \"id\", \"required\", \"checked\", \"disabled\", \"tabIndex\", \"indeterminate\", \"change\", \"click\"], [\"input\", \"\"], [\"matRipple\", \"\", 1, \"mat-checkbox-ripple\", 3, \"matRippleTrigger\", \"matRippleDisabled\", \"matRippleRadius\", \"matRippleCentered\", \"matRippleAnimation\"], [1, \"mat-ripple-element\", \"mat-checkbox-persistent-ripple\"], [1, \"mat-checkbox-frame\"], [1, \"mat-checkbox-background\"], [\"version\", \"1.1\", \"focusable\", \"false\", \"viewBox\", \"0 0 24 24\", 0, \"xml\", \"space\", \"preserve\", 1, \"mat-checkbox-checkmark\"], [\"fill\", \"none\", \"stroke\", \"white\", \"d\", \"M4.1,12.7 9,17.6 20.3,6.3\", 1, \"mat-checkbox-checkmark-path\"], [1, \"mat-checkbox-mixedmark\"], [1, \"mat-checkbox-label\", 3, \"cdkObserveContent\"], [\"checkboxLabel\", \"\"], [2, \"display\", \"none\"]],\n    template: function MatCheckbox_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"label\", 0, 1);\n        ɵngcc0.ɵɵelementStart(2, \"div\", 2);\n        ɵngcc0.ɵɵelementStart(3, \"input\", 3, 4);\n        ɵngcc0.ɵɵlistener(\"change\", function MatCheckbox_Template_input_change_3_listener($event) {\n          return ctx._onInteractionEvent($event);\n        })(\"click\", function MatCheckbox_Template_input_click_3_listener($event) {\n          return ctx._onInputClick($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(5, \"div\", 5);\n        ɵngcc0.ɵɵelement(6, \"div\", 6);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelement(7, \"div\", 7);\n        ɵngcc0.ɵɵelementStart(8, \"div\", 8);\n        ɵngcc0.ɵɵnamespaceSVG();\n        ɵngcc0.ɵɵelementStart(9, \"svg\", 9);\n        ɵngcc0.ɵɵelement(10, \"path\", 10);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵnamespaceHTML();\n        ɵngcc0.ɵɵelement(11, \"div\", 11);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(12, \"span\", 12, 13);\n        ɵngcc0.ɵɵlistener(\"cdkObserveContent\", function MatCheckbox_Template_span_cdkObserveContent_12_listener() {\n          return ctx._onLabelTextChange();\n        });\n        ɵngcc0.ɵɵelementStart(14, \"span\", 14);\n        ɵngcc0.ɵɵtext(15, \"\\xA0\");\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵprojection(16);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        var _r0 = ɵngcc0.ɵɵreference(1);\n\n        var _r2 = ɵngcc0.ɵɵreference(13);\n\n        ɵngcc0.ɵɵattribute(\"for\", ctx.inputId);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵclassProp(\"mat-checkbox-inner-container-no-side-margin\", !_r2.textContent || !_r2.textContent.trim());\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"id\", ctx.inputId)(\"required\", ctx.required)(\"checked\", ctx.checked)(\"disabled\", ctx.disabled)(\"tabIndex\", ctx.tabIndex)(\"indeterminate\", ctx.indeterminate);\n        ɵngcc0.ɵɵattribute(\"value\", ctx.value)(\"name\", ctx.name)(\"aria-label\", ctx.ariaLabel || null)(\"aria-labelledby\", ctx.ariaLabelledby)(\"aria-checked\", ctx._getAriaChecked());\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"matRippleTrigger\", _r0)(\"matRippleDisabled\", ctx._isRippleDisabled())(\"matRippleRadius\", 20)(\"matRippleCentered\", true)(\"matRippleAnimation\", ɵngcc0.ɵɵpureFunction0(19, _c1));\n      }\n    },\n    directives: [ɵngcc2.MatRipple, ɵngcc3.CdkObserveContent],\n    styles: [\"@keyframes mat-checkbox-fade-in-background{0%{opacity:0}50%{opacity:1}}@keyframes mat-checkbox-fade-out-background{0%,50%{opacity:1}100%{opacity:0}}@keyframes mat-checkbox-unchecked-checked-checkmark-path{0%,50%{stroke-dashoffset:22.91026}50%{animation-timing-function:cubic-bezier(0,0,.2,.1)}100%{stroke-dashoffset:0}}@keyframes mat-checkbox-unchecked-indeterminate-mixedmark{0%,68.2%{transform:scaleX(0)}68.2%{animation-timing-function:cubic-bezier(0,0,0,1)}100%{transform:scaleX(1)}}@keyframes mat-checkbox-checked-unchecked-checkmark-path{from{animation-timing-function:cubic-bezier(.4,0,1,1);stroke-dashoffset:0}to{stroke-dashoffset:-22.91026}}@keyframes mat-checkbox-checked-indeterminate-checkmark{from{animation-timing-function:cubic-bezier(0,0,.2,.1);opacity:1;transform:rotate(0)}to{opacity:0;transform:rotate(45deg)}}@keyframes mat-checkbox-indeterminate-checked-checkmark{from{animation-timing-function:cubic-bezier(.14,0,0,1);opacity:0;transform:rotate(45deg)}to{opacity:1;transform:rotate(360deg)}}@keyframes mat-checkbox-checked-indeterminate-mixedmark{from{animation-timing-function:cubic-bezier(0,0,.2,.1);opacity:0;transform:rotate(-45deg)}to{opacity:1;transform:rotate(0)}}@keyframes mat-checkbox-indeterminate-checked-mixedmark{from{animation-timing-function:cubic-bezier(.14,0,0,1);opacity:1;transform:rotate(0)}to{opacity:0;transform:rotate(315deg)}}@keyframes mat-checkbox-indeterminate-unchecked-mixedmark{0%{animation-timing-function:linear;opacity:1;transform:scaleX(1)}100%,32.8%{opacity:0;transform:scaleX(0)}}.mat-checkbox-background,.mat-checkbox-frame{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:2px;box-sizing:border-box;pointer-events:none}.mat-checkbox{transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1);cursor:pointer;-webkit-tap-highlight-color:transparent}._mat-animation-noopable.mat-checkbox{transition:none;animation:none}.mat-checkbox .mat-ripple-element:not(.mat-checkbox-persistent-ripple){opacity:.16}.mat-checkbox-layout{cursor:inherit;align-items:baseline;vertical-align:middle;display:inline-flex;white-space:nowrap}.mat-checkbox-inner-container{display:inline-block;height:16px;line-height:0;margin:auto;margin-right:8px;order:0;position:relative;vertical-align:middle;white-space:nowrap;width:16px;flex-shrink:0}[dir=rtl] .mat-checkbox-inner-container{margin-left:8px;margin-right:auto}.mat-checkbox-inner-container-no-side-margin{margin-left:0;margin-right:0}.mat-checkbox-frame{background-color:transparent;transition:border-color 90ms cubic-bezier(0,0,.2,.1);border-width:2px;border-style:solid}._mat-animation-noopable .mat-checkbox-frame{transition:none}.mat-checkbox-background{align-items:center;display:inline-flex;justify-content:center;transition:background-color 90ms cubic-bezier(0,0,.2,.1),opacity 90ms cubic-bezier(0,0,.2,.1)}._mat-animation-noopable .mat-checkbox-background{transition:none}.mat-checkbox-persistent-ripple{width:100%;height:100%;transform:none}.mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{opacity:.04}.mat-checkbox.cdk-keyboard-focused .mat-checkbox-persistent-ripple{opacity:.12}.mat-checkbox-persistent-ripple,.mat-checkbox.mat-disabled .mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{opacity:0}.mat-checkbox-checkmark{top:0;left:0;right:0;bottom:0;position:absolute;width:100%}.mat-checkbox-checkmark-path{stroke-dashoffset:22.91026;stroke-dasharray:22.91026;stroke-width:2.13333px}.mat-checkbox-mixedmark{width:calc(100% - 6px);height:2px;opacity:0;transform:scaleX(0) rotate(0);border-radius:2px}@media screen and (-ms-high-contrast:active){.mat-checkbox-mixedmark{height:0;border-top:solid 2px;margin-top:2px}}.mat-checkbox-label-before .mat-checkbox-inner-container{order:1;margin-left:8px;margin-right:auto}[dir=rtl] .mat-checkbox-label-before .mat-checkbox-inner-container{margin-left:auto;margin-right:8px}.mat-checkbox-checked .mat-checkbox-checkmark{opacity:1}.mat-checkbox-checked .mat-checkbox-checkmark-path{stroke-dashoffset:0}.mat-checkbox-checked .mat-checkbox-mixedmark{transform:scaleX(1) rotate(-45deg)}.mat-checkbox-indeterminate .mat-checkbox-checkmark{opacity:0;transform:rotate(45deg)}.mat-checkbox-indeterminate .mat-checkbox-checkmark-path{stroke-dashoffset:0}.mat-checkbox-indeterminate .mat-checkbox-mixedmark{opacity:1;transform:scaleX(1) rotate(0)}.mat-checkbox-indeterminate.mat-checkbox-disabled .mat-checkbox-inner-container{opacity:.5}.mat-checkbox-unchecked .mat-checkbox-background{background-color:transparent}.mat-checkbox-disabled{cursor:default}.mat-checkbox-anim-unchecked-checked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-checked .mat-checkbox-checkmark-path{animation:180ms linear 0s mat-checkbox-unchecked-checked-checkmark-path}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0s mat-checkbox-unchecked-indeterminate-mixedmark}.mat-checkbox-anim-checked-unchecked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-out-background}.mat-checkbox-anim-checked-unchecked .mat-checkbox-checkmark-path{animation:90ms linear 0s mat-checkbox-checked-unchecked-checkmark-path}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-checkmark{animation:90ms linear 0s mat-checkbox-checked-indeterminate-checkmark}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0s mat-checkbox-checked-indeterminate-mixedmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-checkmark{animation:.5s linear 0s mat-checkbox-indeterminate-checked-checkmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-mixedmark{animation:.5s linear 0s mat-checkbox-indeterminate-checked-mixedmark}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-out-background}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-mixedmark{animation:.3s linear 0s mat-checkbox-indeterminate-unchecked-mixedmark}.mat-checkbox-input{bottom:0;left:50%}.mat-checkbox .mat-checkbox-ripple{position:absolute;left:calc(50% - 20px);top:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MatCheckbox;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar MAT_CHECKBOX_REQUIRED_VALIDATOR = {\n  provide: NG_VALIDATORS,\n  useExisting: /*@__PURE__*/forwardRef(function () {\n    return MatCheckboxRequiredValidator;\n  }),\n  multi: true\n};\n\nvar MatCheckboxRequiredValidator = /*@__PURE__*/function () {\n  var MatCheckboxRequiredValidator = /*#__PURE__*/function (_CheckboxRequiredVali) {\n    _inherits(MatCheckboxRequiredValidator, _CheckboxRequiredVali);\n\n    var _super2 = _createSuper(MatCheckboxRequiredValidator);\n\n    function MatCheckboxRequiredValidator() {\n      _classCallCheck(this, MatCheckboxRequiredValidator);\n\n      return _super2.apply(this, arguments);\n    }\n\n    return MatCheckboxRequiredValidator;\n  }(CheckboxRequiredValidator);\n\n  MatCheckboxRequiredValidator.ɵfac =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  function () {\n    var ɵMatCheckboxRequiredValidator_BaseFactory;\n    return function MatCheckboxRequiredValidator_Factory(t) {\n      return (ɵMatCheckboxRequiredValidator_BaseFactory || (ɵMatCheckboxRequiredValidator_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(MatCheckboxRequiredValidator)))(t || MatCheckboxRequiredValidator);\n    };\n  }();\n\n  MatCheckboxRequiredValidator.ɵdir =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineDirective({\n    type: MatCheckboxRequiredValidator,\n    selectors: [[\"mat-checkbox\", \"required\", \"\", \"formControlName\", \"\"], [\"mat-checkbox\", \"required\", \"\", \"formControl\", \"\"], [\"mat-checkbox\", \"required\", \"\", \"ngModel\", \"\"]],\n    hostVars: 1,\n    hostBindings: function MatCheckboxRequiredValidator_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"required\", ctx.required ? \"\" : null);\n      }\n    },\n    features: [/*@__PURE__*/ɵngcc0.ɵɵProvidersFeature([MAT_CHECKBOX_REQUIRED_VALIDATOR]), ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  return MatCheckboxRequiredValidator;\n}();\n\nvar MatCheckboxModule = /*@__PURE__*/function () {\n  var MatCheckboxModule = function MatCheckboxModule() {\n    _classCallCheck(this, MatCheckboxModule);\n  };\n\n  MatCheckboxModule.ɵfac = function MatCheckboxModule_Factory(t) {\n    return new (t || MatCheckboxModule)();\n  };\n\n  MatCheckboxModule.ɵmod =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineNgModule({\n    type: MatCheckboxModule\n  });\n  MatCheckboxModule.ɵinj =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, MatRippleModule, MatCommonModule, ObserversModule], MatCommonModule]\n  });\n  return MatCheckboxModule;\n}();\n/*@__PURE__*/\n\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatCheckboxModule, {\n    declarations: function declarations() {\n      return [MatCheckbox, MatCheckboxRequiredValidator];\n    },\n    imports: function imports() {\n      return [CommonModule, MatRippleModule, MatCommonModule, ObserversModule];\n    },\n    exports: function exports() {\n      return [MatCheckbox, MatCheckboxRequiredValidator, MatCommonModule];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nexport { MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR, TransitionCheckState, MatCheckboxChange, MatCheckboxBase, _MatCheckboxMixinBase, MatCheckbox, MAT_CHECKBOX_CLICK_ACTION, MatCheckboxModule, MAT_CHECKBOX_REQUIRED_VALIDATOR, MatCheckboxRequiredValidator }; //# sourceMappingURL=checkbox.js.map","map":null,"metadata":{},"sourceType":"module"}