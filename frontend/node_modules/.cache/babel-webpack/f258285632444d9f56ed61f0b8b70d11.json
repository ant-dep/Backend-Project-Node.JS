{"ast":null,"code":"import _toConsumableArray from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _createClass from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ActiveDescendantKeyManager } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, ElementRef, EventEmitter, Inject, InjectionToken, Input, Output, TemplateRef, ViewChild, ViewEncapsulation, Directive, forwardRef, Host, NgZone, Optional, ViewContainerRef, NgModule } from '@angular/core';\nimport { MAT_OPTION_PARENT_COMPONENT, MatOptgroup, MatOption, mixinDisableRipple, _countGroupLabelsBeforeOption, _getOptionScrollPosition, MatOptionSelectionChange, MatOptionModule, MatCommonModule } from '@angular/material/core';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { DOWN_ARROW, ENTER, ESCAPE, TAB, UP_ARROW } from '@angular/cdk/keycodes';\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { filter, take, switchMap, delay, tap, map } from 'rxjs/operators';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { MatFormField } from '@angular/material/form-field';\nimport { Subscription, defer, fromEvent, merge, of, Subject } from 'rxjs';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** *\n * Autocomplete IDs need to be unique across components, so this counter exists outside of\n * the component definition.\n  @type {?} */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nimport * as ɵngcc2 from '@angular/cdk/overlay';\nimport * as ɵngcc3 from '@angular/cdk/bidi';\nimport * as ɵngcc4 from '@angular/material/form-field';\nimport * as ɵngcc5 from '@angular/cdk/scrolling';\nvar _c0 = [\"panel\"];\n\nfunction MatAutocomplete_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\", 0, 1);\n    ɵngcc0.ɵɵprojection(2);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"id\", ctx_r0.id)(\"ngClass\", ctx_r0._classList);\n  }\n}\n\nvar _c1 = [\"*\"];\nvar _uniqueAutocompleteIdCounter = 0;\n/**\n * Event object that is emitted when an autocomplete option is selected.\n */\n\nvar MatAutocompleteSelectedEvent =\n/**\n * @param {?} source\n * @param {?} option\n */\nfunction MatAutocompleteSelectedEvent(source, option) {\n  _classCallCheck(this, MatAutocompleteSelectedEvent);\n\n  this.source = source;\n  this.option = option;\n};\n/**\n * \\@docs-private\n */\n\n\nvar MatAutocompleteBase = function MatAutocompleteBase() {\n  _classCallCheck(this, MatAutocompleteBase);\n};\n/** @type {?} */\n\n\nvar _MatAutocompleteMixinBase = /*@__PURE__*/mixinDisableRipple(MatAutocompleteBase);\n/** *\n * Injection token to be used to override the default options for `mat-autocomplete`.\n  @type {?} */\n\n\nvar MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = /*@__PURE__*/new InjectionToken('mat-autocomplete-default-options', {\n  providedIn: 'root',\n  factory: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY\n});\n/**\n * \\@docs-private\n * @return {?}\n */\n\nfunction MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY() {\n  return {\n    autoActiveFirstOption: false\n  };\n}\n\nvar MatAutocomplete = /*@__PURE__*/function () {\n  var MatAutocomplete = /*#__PURE__*/function (_MatAutocompleteMixin) {\n    _inherits(MatAutocomplete, _MatAutocompleteMixin);\n\n    var _super = _createSuper(MatAutocomplete);\n\n    /**\n     * @param {?} _changeDetectorRef\n     * @param {?} _elementRef\n     * @param {?} defaults\n     */\n    function MatAutocomplete(_changeDetectorRef, _elementRef, defaults) {\n      var _this;\n\n      _classCallCheck(this, MatAutocomplete);\n\n      _this = _super.call(this);\n      _this._changeDetectorRef = _changeDetectorRef;\n      _this._elementRef = _elementRef;\n      /**\n       * Whether the autocomplete panel should be visible, depending on option length.\n       */\n\n      _this.showPanel = false;\n      _this._isOpen = false;\n      /**\n       * Function that maps an option's control value to its display value in the trigger.\n       */\n\n      _this.displayWith = null;\n      /**\n       * Event that is emitted whenever an option from the list is selected.\n       */\n\n      _this.optionSelected = new EventEmitter();\n      /**\n       * Event that is emitted when the autocomplete panel is opened.\n       */\n\n      _this.opened = new EventEmitter();\n      /**\n       * Event that is emitted when the autocomplete panel is closed.\n       */\n\n      _this.closed = new EventEmitter();\n      _this._classList = {};\n      /**\n       * Unique ID to be used by autocomplete trigger's \"aria-owns\" property.\n       */\n\n      _this.id = \"mat-autocomplete-\".concat(_uniqueAutocompleteIdCounter++);\n      _this._autoActiveFirstOption = !!defaults.autoActiveFirstOption;\n      return _this;\n    }\n    /**\n     * Whether the autocomplete panel is open.\n     * @return {?}\n     */\n\n\n    _createClass(MatAutocomplete, [{\n      key: \"isOpen\",\n      get: function get() {\n        return this._isOpen && this.showPanel;\n      }\n      /**\n       * Whether the first option should be highlighted when the autocomplete panel is opened.\n       * Can be configured globally through the `MAT_AUTOCOMPLETE_DEFAULT_OPTIONS` token.\n       * @return {?}\n       */\n\n    }, {\n      key: \"autoActiveFirstOption\",\n      get: function get() {\n        return this._autoActiveFirstOption;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._autoActiveFirstOption = coerceBooleanProperty(value);\n      }\n      /**\n       * Takes classes set on the host mat-autocomplete element and applies them to the panel\n       * inside the overlay container to allow for easy styling.\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"classList\",\n      set: function set(value) {\n        var _this2 = this;\n\n        if (value && value.length) {\n          value.split(' ').forEach(function (className) {\n            return _this2._classList[className.trim()] = true;\n          });\n          this._elementRef.nativeElement.className = '';\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngAfterContentInit\",\n      value: function ngAfterContentInit() {\n        this._keyManager = new ActiveDescendantKeyManager(this.options).withWrap(); // Set the initial visibility state.\n\n        this._setVisibility();\n      }\n      /**\n       * Sets the panel scrollTop. This allows us to manually scroll to display options\n       * above or below the fold, as they are not actually being focused when active.\n       * @param {?} scrollTop\n       * @return {?}\n       */\n\n    }, {\n      key: \"_setScrollTop\",\n      value: function _setScrollTop(scrollTop) {\n        if (this.panel) {\n          this.panel.nativeElement.scrollTop = scrollTop;\n        }\n      }\n      /**\n       * Returns the panel's scrollTop.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_getScrollTop\",\n      value: function _getScrollTop() {\n        return this.panel ? this.panel.nativeElement.scrollTop : 0;\n      }\n      /**\n       * Panel should hide itself when the option list is empty.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_setVisibility\",\n      value: function _setVisibility() {\n        this.showPanel = !!this.options.length;\n        this._classList['mat-autocomplete-visible'] = this.showPanel;\n        this._classList['mat-autocomplete-hidden'] = !this.showPanel;\n\n        this._changeDetectorRef.markForCheck();\n      }\n      /**\n       * Emits the `select` event.\n       * @param {?} option\n       * @return {?}\n       */\n\n    }, {\n      key: \"_emitSelectEvent\",\n      value: function _emitSelectEvent(option) {\n        /** @type {?} */\n        var event = new MatAutocompleteSelectedEvent(this, option);\n        this.optionSelected.emit(event);\n      }\n    }]);\n\n    return MatAutocomplete;\n  }(_MatAutocompleteMixinBase);\n\n  MatAutocomplete.ɵfac = function MatAutocomplete_Factory(t) {\n    return new (t || MatAutocomplete)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MAT_AUTOCOMPLETE_DEFAULT_OPTIONS));\n  };\n\n  MatAutocomplete.ɵcmp =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineComponent({\n    type: MatAutocomplete,\n    selectors: [[\"mat-autocomplete\"]],\n    contentQueries: function MatAutocomplete_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MatOption, 5);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MatOptgroup, 4);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.options = _t);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.optionGroups = _t);\n      }\n    },\n    viewQuery: function MatAutocomplete_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(TemplateRef, 5);\n        ɵngcc0.ɵɵviewQuery(_c0, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.panel = _t.first);\n      }\n    },\n    hostAttrs: [1, \"mat-autocomplete\"],\n    inputs: {\n      disableRipple: \"disableRipple\",\n      displayWith: \"displayWith\",\n      autoActiveFirstOption: \"autoActiveFirstOption\",\n      classList: [\"class\", \"classList\"],\n      panelWidth: \"panelWidth\"\n    },\n    outputs: {\n      optionSelected: \"optionSelected\",\n      opened: \"opened\",\n      closed: \"closed\"\n    },\n    exportAs: [\"matAutocomplete\"],\n    features: [/*@__PURE__*/ɵngcc0.ɵɵProvidersFeature([{\n      provide: MAT_OPTION_PARENT_COMPONENT,\n      useExisting: MatAutocomplete\n    }]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    consts: [[\"role\", \"listbox\", 1, \"mat-autocomplete-panel\", 3, \"id\", \"ngClass\"], [\"panel\", \"\"]],\n    template: function MatAutocomplete_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MatAutocomplete_ng_template_0_Template, 3, 2, \"ng-template\");\n      }\n    },\n    directives: [ɵngcc1.NgClass],\n    styles: [\".mat-autocomplete-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;visibility:hidden;max-width:none;max-height:256px;position:relative;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px}.mat-autocomplete-panel.mat-autocomplete-visible{visibility:visible}.mat-autocomplete-panel.mat-autocomplete-hidden{visibility:hidden}.mat-autocomplete-panel-above .mat-autocomplete-panel{border-radius:0;border-top-left-radius:4px;border-top-right-radius:4px}.mat-autocomplete-panel .mat-divider-horizontal{margin-top:-1px}@media screen and (-ms-high-contrast:active){.mat-autocomplete-panel{outline:solid 1px}}\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MatAutocomplete;\n}();\n\nvar MatAutocompleteOrigin = /*@__PURE__*/function () {\n  var MatAutocompleteOrigin =\n  /**\n   * @param {?} elementRef\n   */\n  function MatAutocompleteOrigin(elementRef) {\n    _classCallCheck(this, MatAutocompleteOrigin);\n\n    this.elementRef = elementRef;\n  };\n\n  MatAutocompleteOrigin.ɵfac = function MatAutocompleteOrigin_Factory(t) {\n    return new (t || MatAutocompleteOrigin)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MatAutocompleteOrigin.ɵdir =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineDirective({\n    type: MatAutocompleteOrigin,\n    selectors: [[\"\", \"matAutocompleteOrigin\", \"\"]],\n    exportAs: [\"matAutocompleteOrigin\"]\n  });\n  return MatAutocompleteOrigin;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** *\n * The height of each autocomplete option.\n  @type {?} */\n\n\nvar AUTOCOMPLETE_OPTION_HEIGHT = 48;\n/** *\n * The total height of the autocomplete panel.\n  @type {?} */\n\nvar AUTOCOMPLETE_PANEL_HEIGHT = 256;\n/** *\n * Injection token that determines the scroll handling while the autocomplete panel is open.\n  @type {?} */\n\nvar MAT_AUTOCOMPLETE_SCROLL_STRATEGY = /*@__PURE__*/new InjectionToken('mat-autocomplete-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\n\nfunction MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay) {\n  return function () {\n    return overlay.scrollStrategies.reposition();\n  };\n}\n/** *\n * \\@docs-private\n  @type {?} */\n\n\nvar MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n  provide: MAT_AUTOCOMPLETE_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY\n};\n/** *\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\n * \\@docs-private\n  @type {?} */\n\nvar MAT_AUTOCOMPLETE_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: /*@__PURE__*/forwardRef(function () {\n    return MatAutocompleteTrigger;\n  }),\n  multi: true\n};\n/**\n * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\n * \\@docs-private\n * @return {?}\n */\n\nfunction getMatAutocompleteMissingPanelError() {\n  return Error('Attempting to open an undefined instance of `mat-autocomplete`. ' + 'Make sure that the id passed to the `matAutocomplete` is correct and that ' + 'you\\'re attempting to open it after the ngAfterContentInit hook.');\n}\n\nvar MatAutocompleteTrigger = /*@__PURE__*/function () {\n  var MatAutocompleteTrigger = /*#__PURE__*/function () {\n    /**\n     * @param {?} _element\n     * @param {?} _overlay\n     * @param {?} _viewContainerRef\n     * @param {?} _zone\n     * @param {?} _changeDetectorRef\n     * @param {?} scrollStrategy\n     * @param {?} _dir\n     * @param {?} _formField\n     * @param {?} _document\n     * @param {?=} _viewportRuler\n     */\n    function MatAutocompleteTrigger(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, scrollStrategy, _dir, _formField, _document, _viewportRuler) {\n      var _this3 = this;\n\n      _classCallCheck(this, MatAutocompleteTrigger);\n\n      this._element = _element;\n      this._overlay = _overlay;\n      this._viewContainerRef = _viewContainerRef;\n      this._zone = _zone;\n      this._changeDetectorRef = _changeDetectorRef;\n      this._dir = _dir;\n      this._formField = _formField;\n      this._document = _document;\n      this._viewportRuler = _viewportRuler;\n      this._componentDestroyed = false;\n      this._autocompleteDisabled = false;\n      /**\n       * Whether or not the label state is being overridden.\n       */\n\n      this._manuallyFloatingLabel = false;\n      /**\n       * Subscription to viewport size changes.\n       */\n\n      this._viewportSubscription = Subscription.EMPTY;\n      /**\n       * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\n       * closed autocomplete from being reopened if the user switches to another browser tab and then\n       * comes back.\n       */\n\n      this._canOpenOnNextFocus = true;\n      /**\n       * Stream of keyboard events that can close the panel.\n       */\n\n      this._closeKeyEventStream = new Subject();\n      /**\n       * Event handler for when the window is blurred. Needs to be an\n       * arrow function in order to preserve the context.\n       */\n\n      this._windowBlurHandler = function () {\n        // If the user blurred the window while the autocomplete is focused, it means that it'll be\n        // refocused when they come back. In this case we want to skip the first focus event, if the\n        // pane was closed, in order to avoid reopening it unintentionally.\n        _this3._canOpenOnNextFocus = document.activeElement !== _this3._element.nativeElement || _this3.panelOpen;\n      };\n      /**\n       * `View -> model callback called when value changes`\n       */\n\n\n      this._onChange = function () {};\n      /**\n       * `View -> model callback called when autocomplete has been touched`\n       */\n\n\n      this._onTouched = function () {};\n      /**\n       * `autocomplete` attribute to be set on the input element.\n       * \\@docs-private\n       */\n\n\n      this.autocompleteAttribute = 'off';\n      this._overlayAttached = false;\n      /**\n       * Stream of autocomplete option selections.\n       */\n\n      this.optionSelections = defer(function () {\n        if (_this3.autocomplete && _this3.autocomplete.options) {\n          return merge.apply(void 0, _toConsumableArray(_this3.autocomplete.options.map(function (option) {\n            return option.onSelectionChange;\n          })));\n        } // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.\n        // Return a stream that we'll replace with the real one once everything is in place.\n\n\n        return _this3._zone.onStable.asObservable().pipe(take(1), switchMap(function () {\n          return _this3.optionSelections;\n        }));\n      });\n\n      if (typeof window !== 'undefined') {\n        _zone.runOutsideAngular(function () {\n          window.addEventListener('blur', _this3._windowBlurHandler);\n        });\n      }\n\n      this._scrollStrategy = scrollStrategy;\n    }\n    /**\n     * Whether the autocomplete is disabled. When disabled, the element will\n     * act as a regular input and the user won't be able to open the panel.\n     * @return {?}\n     */\n\n\n    _createClass(MatAutocompleteTrigger, [{\n      key: \"autocompleteDisabled\",\n      get: function get() {\n        return this._autocompleteDisabled;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._autocompleteDisabled = coerceBooleanProperty(value);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        if (typeof window !== 'undefined') {\n          window.removeEventListener('blur', this._windowBlurHandler);\n        }\n\n        this._viewportSubscription.unsubscribe();\n\n        this._componentDestroyed = true;\n\n        this._destroyPanel();\n\n        this._closeKeyEventStream.complete();\n      }\n      /**\n       * Whether or not the autocomplete panel is open.\n       * @return {?}\n       */\n\n    }, {\n      key: \"panelOpen\",\n      get: function get() {\n        return this._overlayAttached && this.autocomplete.showPanel;\n      }\n      /**\n       * Opens the autocomplete suggestion panel.\n       * @return {?}\n       */\n\n    }, {\n      key: \"openPanel\",\n      value: function openPanel() {\n        this._attachOverlay();\n\n        this._floatLabel();\n      }\n      /**\n       * Closes the autocomplete suggestion panel.\n       * @return {?}\n       */\n\n    }, {\n      key: \"closePanel\",\n      value: function closePanel() {\n        this._resetLabel();\n\n        if (!this._overlayAttached) {\n          return;\n        }\n\n        if (this.panelOpen) {\n          // Only emit if the panel was visible.\n          this.autocomplete.closed.emit();\n        }\n\n        this.autocomplete._isOpen = this._overlayAttached = false;\n\n        if (this._overlayRef && this._overlayRef.hasAttached()) {\n          this._overlayRef.detach();\n\n          this._closingActionsSubscription.unsubscribe();\n        } // Note that in some cases this can end up being called after the component is destroyed.\n        // Add a check to ensure that we don't try to run change detection on a destroyed view.\n\n\n        if (!this._componentDestroyed) {\n          // We need to trigger change detection manually, because\n          // `fromEvent` doesn't seem to do it at the proper time.\n          // This ensures that the label is reset when the\n          // user clicks outside.\n          this._changeDetectorRef.detectChanges();\n        }\n      }\n      /**\n       * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\n       * within the viewport.\n       * @return {?}\n       */\n\n    }, {\n      key: \"updatePosition\",\n      value: function updatePosition() {\n        if (this._overlayAttached) {\n          /** @type {?} */\n          this._overlayRef.updatePosition();\n        }\n      }\n      /**\n       * A stream of actions that should close the autocomplete panel, including\n       * when an option is selected, on blur, and when TAB is pressed.\n       * @return {?}\n       */\n\n    }, {\n      key: \"panelClosingActions\",\n      get: function get() {\n        var _this4 = this;\n\n        return merge(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(filter(function () {\n          return _this4._overlayAttached;\n        })), this._closeKeyEventStream, this._getOutsideClickStream(), this._overlayRef ? this._overlayRef.detachments().pipe(filter(function () {\n          return _this4._overlayAttached;\n        })) : of()).pipe( // Normalize the output so we return a consistent type.\n        map(function (event) {\n          return event instanceof MatOptionSelectionChange ? event : null;\n        }));\n      }\n      /**\n       * The currently active option, coerced to MatOption type.\n       * @return {?}\n       */\n\n    }, {\n      key: \"activeOption\",\n      get: function get() {\n        if (this.autocomplete && this.autocomplete._keyManager) {\n          return this.autocomplete._keyManager.activeItem;\n        }\n\n        return null;\n      }\n      /**\n       * Stream of clicks outside of the autocomplete panel.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_getOutsideClickStream\",\n      value: function _getOutsideClickStream() {\n        var _this5 = this;\n\n        if (!this._document) {\n          return of(null);\n        }\n\n        return merge(fromEvent(this._document, 'click'), fromEvent(this._document, 'touchend')).pipe(filter(function (event) {\n          /** @type {?} */\n          var clickTarget =\n          /** @type {?} */\n          event.target;\n          /** @type {?} */\n\n          var formField = _this5._formField ? _this5._formField._elementRef.nativeElement : null;\n          return _this5._overlayAttached && clickTarget !== _this5._element.nativeElement && (!formField || !formField.contains(clickTarget)) && !!_this5._overlayRef && !_this5._overlayRef.overlayElement.contains(clickTarget);\n        }));\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"writeValue\",\n      value: function writeValue(value) {\n        var _this6 = this;\n\n        Promise.resolve(null).then(function () {\n          return _this6._setTriggerValue(value);\n        });\n      }\n      /**\n       * @param {?} fn\n       * @return {?}\n       */\n\n    }, {\n      key: \"registerOnChange\",\n      value: function registerOnChange(fn) {\n        this._onChange = fn;\n      }\n      /**\n       * @param {?} fn\n       * @return {?}\n       */\n\n    }, {\n      key: \"registerOnTouched\",\n      value: function registerOnTouched(fn) {\n        this._onTouched = fn;\n      }\n      /**\n       * @param {?} isDisabled\n       * @return {?}\n       */\n\n    }, {\n      key: \"setDisabledState\",\n      value: function setDisabledState(isDisabled) {\n        this._element.nativeElement.disabled = isDisabled;\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"_handleKeydown\",\n      value: function _handleKeydown(event) {\n        /** @type {?} */\n        var keyCode = event.keyCode; // Prevent the default action on all escape key presses. This is here primarily to bring IE\n        // in line with other browsers. By default, pressing escape on IE will cause it to revert\n        // the input value to the one that it had on focus, however it won't dispatch any events\n        // which means that the model value will be out of sync with the view.\n\n        if (keyCode === ESCAPE) {\n          event.preventDefault();\n        }\n\n        if (this.activeOption && keyCode === ENTER && this.panelOpen) {\n          this.activeOption._selectViaInteraction();\n\n          this._resetActiveItem();\n\n          event.preventDefault();\n        } else if (this.autocomplete) {\n          /** @type {?} */\n          var prevActiveItem = this.autocomplete._keyManager.activeItem;\n          /** @type {?} */\n\n          var isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;\n\n          if (this.panelOpen || keyCode === TAB) {\n            this.autocomplete._keyManager.onKeydown(event);\n          } else if (isArrowKey && this._canOpen()) {\n            this.openPanel();\n          }\n\n          if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {\n            this._scrollToOption();\n          }\n        }\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"_handleInput\",\n      value: function _handleInput(event) {\n        /** @type {?} */\n        var target =\n        /** @type {?} */\n        event.target;\n        /** @type {?} */\n\n        var value = target.value; // Based on `NumberValueAccessor` from forms.\n\n        if (target.type === 'number') {\n          value = value == '' ? null : parseFloat(value);\n        } // If the input has a placeholder, IE will fire the `input` event on page load,\n        // focus and blur, in addition to when the user actually changed the value. To\n        // filter out all of the extra events, we save the value on focus and between\n        // `input` events, and we check whether it changed.\n        // See: https://connect.microsoft.com/IE/feedback/details/885747/\n\n\n        if (this._previousValue !== value && document.activeElement === event.target) {\n          this._previousValue = value;\n\n          this._onChange(value);\n\n          if (this._canOpen()) {\n            this.openPanel();\n          }\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"_handleFocus\",\n      value: function _handleFocus() {\n        if (!this._canOpenOnNextFocus) {\n          this._canOpenOnNextFocus = true;\n        } else if (this._canOpen()) {\n          this._previousValue = this._element.nativeElement.value;\n\n          this._attachOverlay();\n\n          this._floatLabel(true);\n        }\n      }\n      /**\n       * In \"auto\" mode, the label will animate down as soon as focus is lost.\n       * This causes the value to jump when selecting an option with the mouse.\n       * This method manually floats the label until the panel can be closed.\n       * @param {?=} shouldAnimate Whether the label should be animated when it is floated.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_floatLabel\",\n      value: function _floatLabel() {\n        var shouldAnimate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n        if (this._formField && this._formField.floatLabel === 'auto') {\n          if (shouldAnimate) {\n            this._formField._animateAndLockLabel();\n          } else {\n            this._formField.floatLabel = 'always';\n          }\n\n          this._manuallyFloatingLabel = true;\n        }\n      }\n      /**\n       * If the label has been manually elevated, return it to its normal state.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_resetLabel\",\n      value: function _resetLabel() {\n        if (this._manuallyFloatingLabel) {\n          this._formField.floatLabel = 'auto';\n          this._manuallyFloatingLabel = false;\n        }\n      }\n      /**\n       * Given that we are not actually focusing active options, we must manually adjust scroll\n       * to reveal options below the fold. First, we find the offset of the option from the top\n       * of the panel. If that offset is below the fold, the new scrollTop will be the offset -\n       * the panel height + the option height, so the active option will be just visible at the\n       * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\n       * will become the offset. If that offset is visible within the panel already, the scrollTop is\n       * not adjusted.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_scrollToOption\",\n      value: function _scrollToOption() {\n        /** @type {?} */\n        var index = this.autocomplete._keyManager.activeItemIndex || 0;\n        /** @type {?} */\n\n        var labelCount = _countGroupLabelsBeforeOption(index, this.autocomplete.options, this.autocomplete.optionGroups);\n        /** @type {?} */\n\n\n        var newScrollPosition = _getOptionScrollPosition(index + labelCount, AUTOCOMPLETE_OPTION_HEIGHT, this.autocomplete._getScrollTop(), AUTOCOMPLETE_PANEL_HEIGHT);\n\n        this.autocomplete._setScrollTop(newScrollPosition);\n      }\n      /**\n       * This method listens to a stream of panel closing actions and resets the\n       * stream every time the option list changes.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_subscribeToClosingActions\",\n      value: function _subscribeToClosingActions() {\n        var _this7 = this;\n\n        /** @type {?} */\n        var firstStable = this._zone.onStable.asObservable().pipe(take(1));\n        /** @type {?} */\n\n\n        var optionChanges = this.autocomplete.options.changes.pipe(tap(function () {\n          return _this7._positionStrategy.reapplyLastPosition();\n        }), // Defer emitting to the stream until the next tick, because changing\n        // bindings in here will cause \"changed after checked\" errors.\n        delay(0)); // When the zone is stable initially, and when the option list changes...\n\n        return merge(firstStable, optionChanges).pipe( // create a new stream of panelClosingActions, replacing any previous streams\n        // that were created, and flatten it so our stream only emits closing events...\n        switchMap(function () {\n          _this7._resetActiveItem();\n\n          _this7.autocomplete._setVisibility();\n\n          if (_this7.panelOpen) {\n            /** @type {?} */\n            _this7._overlayRef.updatePosition();\n          }\n\n          return _this7.panelClosingActions;\n        }), // when the first closing event occurs...\n        take(1)) // set the value, close the panel, and complete.\n        .subscribe(function (event) {\n          return _this7._setValueAndClose(event);\n        });\n      }\n      /**\n       * Destroys the autocomplete suggestion panel.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_destroyPanel\",\n      value: function _destroyPanel() {\n        if (this._overlayRef) {\n          this.closePanel();\n\n          this._overlayRef.dispose();\n\n          this._overlayRef = null;\n        }\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"_setTriggerValue\",\n      value: function _setTriggerValue(value) {\n        /** @type {?} */\n        var toDisplay = this.autocomplete && this.autocomplete.displayWith ? this.autocomplete.displayWith(value) : value;\n        /** @type {?} */\n\n        var inputValue = toDisplay != null ? toDisplay : ''; // If it's used within a `MatFormField`, we should set it through the property so it can go\n        // through change detection.\n\n        if (this._formField) {\n          this._formField._control.value = inputValue;\n        } else {\n          this._element.nativeElement.value = inputValue;\n        }\n\n        this._previousValue = inputValue;\n      }\n      /**\n       * This method closes the panel, and if a value is specified, also sets the associated\n       * control to that value. It will also mark the control as dirty if this interaction\n       * stemmed from the user.\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"_setValueAndClose\",\n      value: function _setValueAndClose(event) {\n        if (event && event.source) {\n          this._clearPreviousSelectedOption(event.source);\n\n          this._setTriggerValue(event.source.value);\n\n          this._onChange(event.source.value);\n\n          this._element.nativeElement.focus();\n\n          this.autocomplete._emitSelectEvent(event.source);\n        }\n\n        this.closePanel();\n      }\n      /**\n       * Clear any previous selected option and emit a selection change event for this option\n       * @param {?} skip\n       * @return {?}\n       */\n\n    }, {\n      key: \"_clearPreviousSelectedOption\",\n      value: function _clearPreviousSelectedOption(skip) {\n        this.autocomplete.options.forEach(function (option) {\n          if (option != skip && option.selected) {\n            option.deselect();\n          }\n        });\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"_attachOverlay\",\n      value: function _attachOverlay() {\n        var _this8 = this;\n\n        if (!this.autocomplete) {\n          throw getMatAutocompleteMissingPanelError();\n        }\n\n        if (!this._overlayRef) {\n          this._portal = new TemplatePortal(this.autocomplete.template, this._viewContainerRef);\n          this._overlayRef = this._overlay.create(this._getOverlayConfig()); // Use the `keydownEvents` in order to take advantage of\n          // the overlay event targeting provided by the CDK overlay.\n\n          this._overlayRef.keydownEvents().subscribe(function (event) {\n            // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.\n            // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction\n            if (event.keyCode === ESCAPE || event.keyCode === UP_ARROW && event.altKey) {\n              _this8._resetActiveItem();\n\n              _this8._closeKeyEventStream.next();\n            }\n          });\n\n          if (this._viewportRuler) {\n            this._viewportSubscription = this._viewportRuler.change().subscribe(function () {\n              if (_this8.panelOpen && _this8._overlayRef) {\n                _this8._overlayRef.updateSize({\n                  width: _this8._getPanelWidth()\n                });\n              }\n            });\n          }\n        } else {\n          // Update the panel width and direction, in case anything has changed.\n          this._overlayRef.updateSize({\n            width: this._getPanelWidth()\n          });\n        }\n\n        if (this._overlayRef && !this._overlayRef.hasAttached()) {\n          this._overlayRef.attach(this._portal);\n\n          this._closingActionsSubscription = this._subscribeToClosingActions();\n        }\n        /** @type {?} */\n\n\n        var wasOpen = this.panelOpen;\n\n        this.autocomplete._setVisibility();\n\n        this.autocomplete._isOpen = this._overlayAttached = true; // We need to do an extra `panelOpen` check in here, because the\n        // autocomplete won't be shown if there are no options.\n\n        if (this.panelOpen && wasOpen !== this.panelOpen) {\n          this.autocomplete.opened.emit();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"_getOverlayConfig\",\n      value: function _getOverlayConfig() {\n        return new OverlayConfig({\n          positionStrategy: this._getOverlayPosition(),\n          scrollStrategy: this._scrollStrategy(),\n          width: this._getPanelWidth(),\n          direction: this._dir\n        });\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"_getOverlayPosition\",\n      value: function _getOverlayPosition() {\n        this._positionStrategy = this._overlay.position().flexibleConnectedTo(this._getConnectedElement()).withFlexibleDimensions(false).withPush(false).withPositions([{\n          originX: 'start',\n          originY: 'bottom',\n          overlayX: 'start',\n          overlayY: 'top'\n        }, {\n          originX: 'start',\n          originY: 'top',\n          overlayX: 'start',\n          overlayY: 'bottom',\n          // The overlay edge connected to the trigger should have squared corners, while\n          // the opposite end has rounded corners. We apply a CSS class to swap the\n          // border-radius based on the overlay position.\n          panelClass: 'mat-autocomplete-panel-above'\n        }]);\n        return this._positionStrategy;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"_getConnectedElement\",\n      value: function _getConnectedElement() {\n        if (this.connectedTo) {\n          return this.connectedTo.elementRef;\n        }\n\n        return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"_getPanelWidth\",\n      value: function _getPanelWidth() {\n        return this.autocomplete.panelWidth || this._getHostWidth();\n      }\n      /**\n       * Returns the width of the input element, so the panel width can match it.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_getHostWidth\",\n      value: function _getHostWidth() {\n        return this._getConnectedElement().nativeElement.getBoundingClientRect().width;\n      }\n      /**\n       * Resets the active item to -1 so arrow events will activate the\n       * correct options, or to 0 if the consumer opted into it.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_resetActiveItem\",\n      value: function _resetActiveItem() {\n        this.autocomplete._keyManager.setActiveItem(this.autocomplete.autoActiveFirstOption ? 0 : -1);\n      }\n      /**\n       * Determines whether the panel can be opened.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_canOpen\",\n      value: function _canOpen() {\n        /** @type {?} */\n        var element = this._element.nativeElement;\n        return !element.readOnly && !element.disabled && !this._autocompleteDisabled;\n      }\n    }]);\n\n    return MatAutocompleteTrigger;\n  }();\n\n  MatAutocompleteTrigger.ɵfac = function MatAutocompleteTrigger_Factory(t) {\n    return new (t || MatAutocompleteTrigger)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Overlay), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(MAT_AUTOCOMPLETE_SCROLL_STRATEGY), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Directionality, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.MatFormField, 9), ɵngcc0.ɵɵdirectiveInject(DOCUMENT, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc5.ViewportRuler));\n  };\n\n  MatAutocompleteTrigger.ɵdir =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineDirective({\n    type: MatAutocompleteTrigger,\n    selectors: [[\"input\", \"matAutocomplete\", \"\"], [\"textarea\", \"matAutocomplete\", \"\"]],\n    hostVars: 6,\n    hostBindings: function MatAutocompleteTrigger_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"focusin\", function MatAutocompleteTrigger_focusin_HostBindingHandler() {\n          return ctx._handleFocus();\n        })(\"blur\", function MatAutocompleteTrigger_blur_HostBindingHandler() {\n          return ctx._onTouched();\n        })(\"input\", function MatAutocompleteTrigger_input_HostBindingHandler($event) {\n          return ctx._handleInput($event);\n        })(\"keydown\", function MatAutocompleteTrigger_keydown_HostBindingHandler($event) {\n          return ctx._handleKeydown($event);\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"autocomplete\", ctx.autocompleteAttribute)(\"role\", ctx.autocompleteDisabled ? null : \"combobox\")(\"aria-autocomplete\", ctx.autocompleteDisabled ? null : \"list\")(\"aria-activedescendant\", ctx.activeOption == null ? null : ctx.activeOption.id)(\"aria-expanded\", ctx.autocompleteDisabled ? null : ctx.panelOpen.toString())(\"aria-owns\", ctx.autocompleteDisabled || !ctx.panelOpen ? null : ctx.autocomplete == null ? null : ctx.autocomplete.id);\n      }\n    },\n    inputs: {\n      autocompleteAttribute: [\"autocomplete\", \"autocompleteAttribute\"],\n      autocompleteDisabled: [\"matAutocompleteDisabled\", \"autocompleteDisabled\"],\n      autocomplete: [\"matAutocomplete\", \"autocomplete\"],\n      connectedTo: [\"matAutocompleteConnectedTo\", \"connectedTo\"]\n    },\n    exportAs: [\"matAutocompleteTrigger\"],\n    features: [/*@__PURE__*/ɵngcc0.ɵɵProvidersFeature([MAT_AUTOCOMPLETE_VALUE_ACCESSOR])]\n  });\n  return MatAutocompleteTrigger;\n}();\n\nvar MatAutocompleteModule = /*@__PURE__*/function () {\n  var MatAutocompleteModule = function MatAutocompleteModule() {\n    _classCallCheck(this, MatAutocompleteModule);\n  };\n\n  MatAutocompleteModule.ɵfac = function MatAutocompleteModule_Factory(t) {\n    return new (t || MatAutocompleteModule)();\n  };\n\n  MatAutocompleteModule.ɵmod =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineNgModule({\n    type: MatAutocompleteModule\n  });\n  MatAutocompleteModule.ɵinj =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineInjector({\n    providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER],\n    imports: [[MatOptionModule, OverlayModule, MatCommonModule, CommonModule], MatOptionModule, MatCommonModule]\n  });\n  return MatAutocompleteModule;\n}();\n/*@__PURE__*/\n\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatAutocompleteModule, {\n    declarations: function declarations() {\n      return [MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin];\n    },\n    imports: function imports() {\n      return [MatOptionModule, OverlayModule, MatCommonModule, CommonModule];\n    },\n    exports: function exports() {\n      return [MatAutocomplete, MatOptionModule, MatAutocompleteTrigger, MatAutocompleteOrigin, MatCommonModule];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nexport { MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY, MatAutocompleteSelectedEvent, MatAutocompleteBase, _MatAutocompleteMixinBase, MAT_AUTOCOMPLETE_DEFAULT_OPTIONS, MatAutocomplete, MatAutocompleteModule, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY, getMatAutocompleteMissingPanelError, AUTOCOMPLETE_OPTION_HEIGHT, AUTOCOMPLETE_PANEL_HEIGHT, MAT_AUTOCOMPLETE_SCROLL_STRATEGY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER, MAT_AUTOCOMPLETE_VALUE_ACCESSOR, MatAutocompleteTrigger, MatAutocompleteOrigin as ɵa29 }; //# sourceMappingURL=autocomplete.js.map","map":null,"metadata":{},"sourceType":"module"}