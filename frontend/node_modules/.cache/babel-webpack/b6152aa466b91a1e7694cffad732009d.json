{"ast":null,"code":"'use strict';\n/**\n * @license Angular v12.0.0-next.0\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/*\n * This is necessary for Chrome and Chrome mobile, to enable\n * things like redefining `createdCallback` on an element.\n */\n\nvar zoneSymbol;\n\nvar _defineProperty;\n\nvar _getOwnPropertyDescriptor;\n\nvar _create;\n\nvar unconfigurablesKey;\n\nfunction propertyPatch() {\n  zoneSymbol = Zone.__symbol__;\n  _defineProperty = Object[zoneSymbol('defineProperty')] = Object.defineProperty;\n  _getOwnPropertyDescriptor = Object[zoneSymbol('getOwnPropertyDescriptor')] = Object.getOwnPropertyDescriptor;\n  _create = Object.create;\n  unconfigurablesKey = zoneSymbol('unconfigurables');\n\n  Object.defineProperty = function (obj, prop, desc) {\n    if (isUnconfigurable(obj, prop)) {\n      throw new TypeError('Cannot assign to read only property \\'' + prop + '\\' of ' + obj);\n    }\n\n    var originalConfigurableFlag = desc.configurable;\n\n    if (prop !== 'prototype') {\n      desc = rewriteDescriptor(obj, prop, desc);\n    }\n\n    return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);\n  };\n\n  Object.defineProperties = function (obj, props) {\n    Object.keys(props).forEach(function (prop) {\n      Object.defineProperty(obj, prop, props[prop]);\n    });\n    return obj;\n  };\n\n  Object.create = function (obj, proto) {\n    if (typeof proto === 'object' && !Object.isFrozen(proto)) {\n      Object.keys(proto).forEach(function (prop) {\n        proto[prop] = rewriteDescriptor(obj, prop, proto[prop]);\n      });\n    }\n\n    return _create(obj, proto);\n  };\n\n  Object.getOwnPropertyDescriptor = function (obj, prop) {\n    var desc = _getOwnPropertyDescriptor(obj, prop);\n\n    if (desc && isUnconfigurable(obj, prop)) {\n      desc.configurable = false;\n    }\n\n    return desc;\n  };\n}\n\nfunction _redefineProperty(obj, prop, desc) {\n  var originalConfigurableFlag = desc.configurable;\n  desc = rewriteDescriptor(obj, prop, desc);\n  return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);\n}\n\nfunction isUnconfigurable(obj, prop) {\n  return obj && obj[unconfigurablesKey] && obj[unconfigurablesKey][prop];\n}\n\nfunction rewriteDescriptor(obj, prop, desc) {\n  // issue-927, if the desc is frozen, don't try to change the desc\n  if (!Object.isFrozen(desc)) {\n    desc.configurable = true;\n  }\n\n  if (!desc.configurable) {\n    // issue-927, if the obj is frozen, don't try to set the desc to obj\n    if (!obj[unconfigurablesKey] && !Object.isFrozen(obj)) {\n      _defineProperty(obj, unconfigurablesKey, {\n        writable: true,\n        value: {}\n      });\n    }\n\n    if (obj[unconfigurablesKey]) {\n      obj[unconfigurablesKey][prop] = true;\n    }\n  }\n\n  return desc;\n}\n\nfunction _tryDefineProperty(obj, prop, desc, originalConfigurableFlag) {\n  try {\n    return _defineProperty(obj, prop, desc);\n  } catch (error) {\n    if (desc.configurable) {\n      // In case of errors, when the configurable flag was likely set by rewriteDescriptor(), let's\n      // retry with the original flag value\n      if (typeof originalConfigurableFlag == 'undefined') {\n        delete desc.configurable;\n      } else {\n        desc.configurable = originalConfigurableFlag;\n      }\n\n      try {\n        return _defineProperty(obj, prop, desc);\n      } catch (error) {\n        var swallowError = false;\n\n        if (prop === 'createdCallback' || prop === 'attachedCallback' || prop === 'detachedCallback' || prop === 'attributeChangedCallback') {\n          // We only swallow the error in registerElement patch\n          // this is the work around since some applications\n          // fail if we throw the error\n          swallowError = true;\n        }\n\n        if (!swallowError) {\n          throw error;\n        } // TODO: @JiaLiPassion, Some application such as `registerElement` patch\n        // still need to swallow the error, in the future after these applications\n        // are updated, the following logic can be removed.\n\n\n        var descJson = null;\n\n        try {\n          descJson = JSON.stringify(desc);\n        } catch (error) {\n          descJson = desc.toString();\n        }\n\n        console.log(\"Attempting to configure '\".concat(prop, \"' with descriptor '\").concat(descJson, \"' on object '\").concat(obj, \"' and got error, giving up: \").concat(error));\n      }\n    } else {\n      throw error;\n    }\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction eventTargetLegacyPatch(_global, api) {\n  var _api$getGlobalObjects = api.getGlobalObjects(),\n      eventNames = _api$getGlobalObjects.eventNames,\n      globalSources = _api$getGlobalObjects.globalSources,\n      zoneSymbolEventNames = _api$getGlobalObjects.zoneSymbolEventNames,\n      TRUE_STR = _api$getGlobalObjects.TRUE_STR,\n      FALSE_STR = _api$getGlobalObjects.FALSE_STR,\n      ZONE_SYMBOL_PREFIX = _api$getGlobalObjects.ZONE_SYMBOL_PREFIX;\n\n  var WTF_ISSUE_555 = 'Anchor,Area,Audio,BR,Base,BaseFont,Body,Button,Canvas,Content,DList,Directory,Div,Embed,FieldSet,Font,Form,Frame,FrameSet,HR,Head,Heading,Html,IFrame,Image,Input,Keygen,LI,Label,Legend,Link,Map,Marquee,Media,Menu,Meta,Meter,Mod,OList,Object,OptGroup,Option,Output,Paragraph,Pre,Progress,Quote,Script,Select,Source,Span,Style,TableCaption,TableCell,TableCol,Table,TableRow,TableSection,TextArea,Title,Track,UList,Unknown,Video';\n  var NO_EVENT_TARGET = 'ApplicationCache,EventSource,FileReader,InputMethodContext,MediaController,MessagePort,Node,Performance,SVGElementInstance,SharedWorker,TextTrack,TextTrackCue,TextTrackList,WebKitNamedFlow,Window,Worker,WorkerGlobalScope,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload,IDBRequest,IDBOpenDBRequest,IDBDatabase,IDBTransaction,IDBCursor,DBIndex,WebSocket'.split(',');\n  var EVENT_TARGET = 'EventTarget';\n  var apis = [];\n  var isWtf = _global['wtf'];\n  var WTF_ISSUE_555_ARRAY = WTF_ISSUE_555.split(',');\n\n  if (isWtf) {\n    // Workaround for: https://github.com/google/tracing-framework/issues/555\n    apis = WTF_ISSUE_555_ARRAY.map(function (v) {\n      return 'HTML' + v + 'Element';\n    }).concat(NO_EVENT_TARGET);\n  } else if (_global[EVENT_TARGET]) {\n    apis.push(EVENT_TARGET);\n  } else {\n    // Note: EventTarget is not available in all browsers,\n    // if it's not available, we instead patch the APIs in the IDL that inherit from EventTarget\n    apis = NO_EVENT_TARGET;\n  }\n\n  var isDisableIECheck = _global['__Zone_disable_IE_check'] || false;\n  var isEnableCrossContextCheck = _global['__Zone_enable_cross_context_check'] || false;\n  var ieOrEdge = api.isIEOrEdge();\n  var ADD_EVENT_LISTENER_SOURCE = '.addEventListener:';\n  var FUNCTION_WRAPPER = '[object FunctionWrapper]';\n  var BROWSER_TOOLS = 'function __BROWSERTOOLS_CONSOLE_SAFEFUNC() { [native code] }';\n  var pointerEventsMap = {\n    'MSPointerCancel': 'pointercancel',\n    'MSPointerDown': 'pointerdown',\n    'MSPointerEnter': 'pointerenter',\n    'MSPointerHover': 'pointerhover',\n    'MSPointerLeave': 'pointerleave',\n    'MSPointerMove': 'pointermove',\n    'MSPointerOut': 'pointerout',\n    'MSPointerOver': 'pointerover',\n    'MSPointerUp': 'pointerup'\n  }; //  predefine all __zone_symbol__ + eventName + true/false string\n\n  for (var i = 0; i < eventNames.length; i++) {\n    var eventName = eventNames[i];\n    var falseEventName = eventName + FALSE_STR;\n    var trueEventName = eventName + TRUE_STR;\n    var symbol = ZONE_SYMBOL_PREFIX + falseEventName;\n    var symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;\n    zoneSymbolEventNames[eventName] = {};\n    zoneSymbolEventNames[eventName][FALSE_STR] = symbol;\n    zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;\n  } //  predefine all task.source string\n\n\n  for (var _i = 0; _i < WTF_ISSUE_555_ARRAY.length; _i++) {\n    var target = WTF_ISSUE_555_ARRAY[_i];\n    var targets = globalSources[target] = {};\n\n    for (var j = 0; j < eventNames.length; j++) {\n      var _eventName = eventNames[j];\n      targets[_eventName] = target + ADD_EVENT_LISTENER_SOURCE + _eventName;\n    }\n  }\n\n  var checkIEAndCrossContext = function checkIEAndCrossContext(nativeDelegate, delegate, target, args) {\n    if (!isDisableIECheck && ieOrEdge) {\n      if (isEnableCrossContextCheck) {\n        try {\n          var testString = delegate.toString();\n\n          if (testString === FUNCTION_WRAPPER || testString == BROWSER_TOOLS) {\n            nativeDelegate.apply(target, args);\n            return false;\n          }\n        } catch (error) {\n          nativeDelegate.apply(target, args);\n          return false;\n        }\n      } else {\n        var _testString = delegate.toString();\n\n        if (_testString === FUNCTION_WRAPPER || _testString == BROWSER_TOOLS) {\n          nativeDelegate.apply(target, args);\n          return false;\n        }\n      }\n    } else if (isEnableCrossContextCheck) {\n      try {\n        delegate.toString();\n      } catch (error) {\n        nativeDelegate.apply(target, args);\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  var apiTypes = [];\n\n  for (var _i2 = 0; _i2 < apis.length; _i2++) {\n    var type = _global[apis[_i2]];\n    apiTypes.push(type && type.prototype);\n  } // vh is validateHandler to check event handler\n  // is valid or not(for security check)\n\n\n  api.patchEventTarget(_global, apiTypes, {\n    vh: checkIEAndCrossContext,\n    transferEventName: function transferEventName(eventName) {\n      var pointerEventName = pointerEventsMap[eventName];\n      return pointerEventName || eventName;\n    }\n  });\n  Zone[api.symbol('patchEventTarget')] = !!_global[EVENT_TARGET];\n  return true;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// we have to patch the instance since the proto is non-configurable\n\n\nfunction apply(api, _global) {\n  var _api$getGlobalObjects2 = api.getGlobalObjects(),\n      ADD_EVENT_LISTENER_STR = _api$getGlobalObjects2.ADD_EVENT_LISTENER_STR,\n      REMOVE_EVENT_LISTENER_STR = _api$getGlobalObjects2.REMOVE_EVENT_LISTENER_STR;\n\n  var WS = _global.WebSocket; // On Safari window.EventTarget doesn't exist so need to patch WS add/removeEventListener\n  // On older Chrome, no need since EventTarget was already patched\n\n  if (!_global.EventTarget) {\n    api.patchEventTarget(_global, [WS.prototype]);\n  }\n\n  _global.WebSocket = function (x, y) {\n    var socket = arguments.length > 1 ? new WS(x, y) : new WS(x);\n    var proxySocket;\n    var proxySocketProto; // Safari 7.0 has non-configurable own 'onmessage' and friends properties on the socket instance\n\n    var onmessageDesc = api.ObjectGetOwnPropertyDescriptor(socket, 'onmessage');\n\n    if (onmessageDesc && onmessageDesc.configurable === false) {\n      proxySocket = api.ObjectCreate(socket); // socket have own property descriptor 'onopen', 'onmessage', 'onclose', 'onerror'\n      // but proxySocket not, so we will keep socket as prototype and pass it to\n      // patchOnProperties method\n\n      proxySocketProto = socket;\n      [ADD_EVENT_LISTENER_STR, REMOVE_EVENT_LISTENER_STR, 'send', 'close'].forEach(function (propName) {\n        proxySocket[propName] = function () {\n          var args = api.ArraySlice.call(arguments);\n\n          if (propName === ADD_EVENT_LISTENER_STR || propName === REMOVE_EVENT_LISTENER_STR) {\n            var eventName = args.length > 0 ? args[0] : undefined;\n\n            if (eventName) {\n              var propertySymbol = Zone.__symbol__('ON_PROPERTY' + eventName);\n\n              socket[propertySymbol] = proxySocket[propertySymbol];\n            }\n          }\n\n          return socket[propName].apply(socket, args);\n        };\n      });\n    } else {\n      // we can patch the real socket\n      proxySocket = socket;\n    }\n\n    api.patchOnProperties(proxySocket, ['close', 'error', 'message', 'open'], proxySocketProto);\n    return proxySocket;\n  };\n\n  var globalWebSocket = _global['WebSocket'];\n\n  for (var prop in WS) {\n    globalWebSocket[prop] = WS[prop];\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction propertyDescriptorLegacyPatch(api, _global) {\n  var _api$getGlobalObjects3 = api.getGlobalObjects(),\n      isNode = _api$getGlobalObjects3.isNode,\n      isMix = _api$getGlobalObjects3.isMix;\n\n  if (isNode && !isMix) {\n    return;\n  }\n\n  if (!canPatchViaPropertyDescriptor(api, _global)) {\n    var supportsWebSocket = typeof WebSocket !== 'undefined'; // Safari, Android browsers (Jelly Bean)\n\n    patchViaCapturingAllTheEvents(api);\n    api.patchClass('XMLHttpRequest');\n\n    if (supportsWebSocket) {\n      apply(api, _global);\n    }\n\n    Zone[api.symbol('patchEvents')] = true;\n  }\n}\n\nfunction canPatchViaPropertyDescriptor(api, _global) {\n  var _api$getGlobalObjects4 = api.getGlobalObjects(),\n      isBrowser = _api$getGlobalObjects4.isBrowser,\n      isMix = _api$getGlobalObjects4.isMix;\n\n  if ((isBrowser || isMix) && !api.ObjectGetOwnPropertyDescriptor(HTMLElement.prototype, 'onclick') && typeof Element !== 'undefined') {\n    // WebKit https://bugs.webkit.org/show_bug.cgi?id=134364\n    // IDL interface attributes are not configurable\n    var desc = api.ObjectGetOwnPropertyDescriptor(Element.prototype, 'onclick');\n    if (desc && !desc.configurable) return false; // try to use onclick to detect whether we can patch via propertyDescriptor\n    // because XMLHttpRequest is not available in service worker\n\n    if (desc) {\n      api.ObjectDefineProperty(Element.prototype, 'onclick', {\n        enumerable: true,\n        configurable: true,\n        get: function get() {\n          return true;\n        }\n      });\n      var div = document.createElement('div');\n      var result = !!div.onclick;\n      api.ObjectDefineProperty(Element.prototype, 'onclick', desc);\n      return result;\n    }\n  }\n\n  var XMLHttpRequest = _global['XMLHttpRequest'];\n\n  if (!XMLHttpRequest) {\n    // XMLHttpRequest is not available in service worker\n    return false;\n  }\n\n  var ON_READY_STATE_CHANGE = 'onreadystatechange';\n  var XMLHttpRequestPrototype = XMLHttpRequest.prototype;\n  var xhrDesc = api.ObjectGetOwnPropertyDescriptor(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE); // add enumerable and configurable here because in opera\n  // by default XMLHttpRequest.prototype.onreadystatechange is undefined\n  // without adding enumerable and configurable will cause onreadystatechange\n  // non-configurable\n  // and if XMLHttpRequest.prototype.onreadystatechange is undefined,\n  // we should set a real desc instead a fake one\n\n  if (xhrDesc) {\n    api.ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return true;\n      }\n    });\n    var req = new XMLHttpRequest();\n\n    var _result = !!req.onreadystatechange; // restore original desc\n\n\n    api.ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, xhrDesc || {});\n    return _result;\n  } else {\n    var SYMBOL_FAKE_ONREADYSTATECHANGE = api.symbol('fake');\n    api.ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return this[SYMBOL_FAKE_ONREADYSTATECHANGE];\n      },\n      set: function set(value) {\n        this[SYMBOL_FAKE_ONREADYSTATECHANGE] = value;\n      }\n    });\n\n    var _req = new XMLHttpRequest();\n\n    var detectFunc = function detectFunc() {};\n\n    _req.onreadystatechange = detectFunc;\n\n    var _result2 = _req[SYMBOL_FAKE_ONREADYSTATECHANGE] === detectFunc;\n\n    _req.onreadystatechange = null;\n    return _result2;\n  }\n} // Whenever any eventListener fires, we check the eventListener target and all parents\n// for `onwhatever` properties and replace them with zone-bound functions\n// - Chrome (for now)\n\n\nfunction patchViaCapturingAllTheEvents(api) {\n  var _api$getGlobalObjects5 = api.getGlobalObjects(),\n      eventNames = _api$getGlobalObjects5.eventNames;\n\n  var unboundKey = api.symbol('unbound');\n\n  var _loop = function _loop(i) {\n    var property = eventNames[i];\n    var onproperty = 'on' + property;\n    self.addEventListener(property, function (event) {\n      var elt = event.target,\n          bound,\n          source;\n\n      if (elt) {\n        source = elt.constructor['name'] + '.' + onproperty;\n      } else {\n        source = 'unknown.' + onproperty;\n      }\n\n      while (elt) {\n        if (elt[onproperty] && !elt[onproperty][unboundKey]) {\n          bound = api.wrapWithCurrentZone(elt[onproperty], source);\n          bound[unboundKey] = elt[onproperty];\n          elt[onproperty] = bound;\n        }\n\n        elt = elt.parentElement;\n      }\n    }, true);\n  };\n\n  for (var i = 0; i < eventNames.length; i++) {\n    _loop(i);\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction registerElementPatch(_global, api) {\n  var _api$getGlobalObjects6 = api.getGlobalObjects(),\n      isBrowser = _api$getGlobalObjects6.isBrowser,\n      isMix = _api$getGlobalObjects6.isMix;\n\n  if (!isBrowser && !isMix || !('registerElement' in _global.document)) {\n    return;\n  }\n\n  var callbacks = ['createdCallback', 'attachedCallback', 'detachedCallback', 'attributeChangedCallback'];\n  api.patchCallbacks(api, document, 'Document', 'registerElement', callbacks);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n(function (_global) {\n  var symbolPrefix = _global['__Zone_symbol_prefix'] || '__zone_symbol__';\n\n  function __symbol__(name) {\n    return symbolPrefix + name;\n  }\n\n  _global[__symbol__('legacyPatch')] = function () {\n    var Zone = _global['Zone'];\n\n    Zone.__load_patch('defineProperty', function (global, Zone, api) {\n      api._redefineProperty = _redefineProperty;\n      propertyPatch();\n    });\n\n    Zone.__load_patch('registerElement', function (global, Zone, api) {\n      registerElementPatch(global, api);\n    });\n\n    Zone.__load_patch('EventTargetLegacy', function (global, Zone, api) {\n      eventTargetLegacyPatch(global, api);\n      propertyDescriptorLegacyPatch(api, global);\n    });\n  };\n})(typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {});","map":null,"metadata":{},"sourceType":"script"}