{"ast":null,"code":"import _slicedToArray from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _assertThisInitialized from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, TemplateRef, ComponentFactoryResolver, ApplicationRef, Injector, ViewContainerRef, Inject, InjectionToken, ChangeDetectionStrategy, Component, ElementRef, ViewEncapsulation, Optional, ContentChild, ContentChildren, EventEmitter, Input, NgZone, Output, ViewChild, Self, NgModule } from '@angular/core';\nimport { TemplatePortal, DomPortalOutlet } from '@angular/cdk/portal';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { Subject, merge, Subscription, asapScheduler, of } from 'rxjs';\nimport { trigger, state, style, animate, transition, query, group } from '@angular/animations';\nimport { FocusMonitor, FocusKeyManager, isFakeMousedownFromScreenReader } from '@angular/cdk/a11y';\nimport { mixinDisabled, mixinDisableRipple, MatCommonModule, MatRippleModule } from '@angular/material/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ESCAPE, LEFT_ARROW, RIGHT_ARROW, DOWN_ARROW, UP_ARROW } from '@angular/cdk/keycodes';\nimport { startWith, switchMap, take, delay, filter, takeUntil } from 'rxjs/operators';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * Menu content that will be rendered lazily once the menu is opened.\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/a11y';\nimport * as ɵngcc2 from '@angular/material/core';\nimport * as ɵngcc3 from '@angular/common';\nimport * as ɵngcc4 from '@angular/cdk/overlay';\nimport * as ɵngcc5 from '@angular/cdk/bidi';\nvar _c0 = [\"mat-menu-item\", \"\"];\nvar _c1 = [\"*\"];\n\nfunction MatMenu_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r2 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n    ɵngcc0.ɵɵlistener(\"keydown\", function MatMenu_ng_template_0_Template_div_keydown_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r2);\n      var ctx_r1 = ɵngcc0.ɵɵnextContext();\n      return ctx_r1._handleKeydown($event);\n    })(\"click\", function MatMenu_ng_template_0_Template_div_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r2);\n      var ctx_r3 = ɵngcc0.ɵɵnextContext();\n      return ctx_r3.closed.emit(\"click\");\n    })(\"@transformMenu.start\", function MatMenu_ng_template_0_Template_div_animation_transformMenu_start_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r2);\n      var ctx_r4 = ɵngcc0.ɵɵnextContext();\n      return ctx_r4._isAnimating = true;\n    })(\"@transformMenu.done\", function MatMenu_ng_template_0_Template_div_animation_transformMenu_done_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r2);\n      var ctx_r5 = ɵngcc0.ɵɵnextContext();\n      return ctx_r5._onAnimationDone($event);\n    });\n    ɵngcc0.ɵɵelementStart(1, \"div\", 1);\n    ɵngcc0.ɵɵprojection(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngClass\", ctx_r0._classList)(\"@transformMenu\", ctx_r0._panelAnimationState);\n  }\n}\n\nvar MatMenuContent = /*#__PURE__*/function () {\n  /**\n   * @param {?} _template\n   * @param {?} _componentFactoryResolver\n   * @param {?} _appRef\n   * @param {?} _injector\n   * @param {?} _viewContainerRef\n   * @param {?} _document\n   */\n  function MatMenuContent(_template, _componentFactoryResolver, _appRef, _injector, _viewContainerRef, _document) {\n    _classCallCheck(this, MatMenuContent);\n\n    this._template = _template;\n    this._componentFactoryResolver = _componentFactoryResolver;\n    this._appRef = _appRef;\n    this._injector = _injector;\n    this._viewContainerRef = _viewContainerRef;\n    this._document = _document;\n    /**\n     * Emits when the menu content has been attached.\n     */\n\n    this._attached = new Subject();\n  }\n  /**\n   * Attaches the content with a particular context.\n   * \\@docs-private\n   * @param {?=} context\n   * @return {?}\n   */\n\n\n  _createClass(MatMenuContent, [{\n    key: \"attach\",\n    value: function attach() {\n      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (!this._portal) {\n        this._portal = new TemplatePortal(this._template, this._viewContainerRef);\n      }\n\n      this.detach();\n\n      if (!this._outlet) {\n        this._outlet = new DomPortalOutlet(this._document.createElement('div'), this._componentFactoryResolver, this._appRef, this._injector);\n      }\n      /** @type {?} */\n\n\n      var element = this._template.elementRef.nativeElement;\n      /** @type {?} */\n\n      // Because we support opening the same menu from different triggers (which in turn have their\n      // own `OverlayRef` panel), we have to re-insert the host element every time, otherwise we\n      // risk it staying attached to a pane that's no longer in the DOM.\n      element.parentNode.insertBefore(this._outlet.outletElement, element);\n\n      this._portal.attach(this._outlet, context);\n\n      this._attached.next();\n    }\n    /**\n     * Detaches the content.\n     * \\@docs-private\n     * @return {?}\n     */\n\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      if (this._portal.isAttached) {\n        this._portal.detach();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      if (this._outlet) {\n        this._outlet.dispose();\n      }\n    }\n  }]);\n\n  return MatMenuContent;\n}();\n\nMatMenuContent.ɵfac = function MatMenuContent_Factory(t) {\n  return new (t || MatMenuContent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ApplicationRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT));\n};\n\nMatMenuContent.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: MatMenuContent,\n  selectors: [[\"ng-template\", \"matMenuContent\", \"\"]]\n});\n/** @nocollapse */\n\nMatMenuContent.ctorParameters = function () {\n  return [{\n    type: TemplateRef\n  }, {\n    type: ComponentFactoryResolver\n  }, {\n    type: ApplicationRef\n  }, {\n    type: Injector\n  }, {\n    type: ViewContainerRef\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatMenuContent, [{\n    type: Directive,\n    args: [{\n      selector: 'ng-template[matMenuContent]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.TemplateRef\n    }, {\n      type: ɵngcc0.ComponentFactoryResolver\n    }, {\n      type: ɵngcc0.ApplicationRef\n    }, {\n      type: ɵngcc0.Injector\n    }, {\n      type: ɵngcc0.ViewContainerRef\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** *\n * Animations used by the mat-menu component.\n * Animation duration and timing values are based on:\n * https://material.io/guidelines/components/menus.html#menus-usage\n * \\@docs-private\n  @type {?} */\n\n\nvar matMenuAnimations = {\n  /**\n     * This animation controls the menu panel's entry and exit from the page.\n     *\n     * When the menu panel is added to the DOM, it scales in and fades in its border.\n     *\n     * When the menu panel is removed from the DOM, it simply fades out after a brief\n     * delay to display the ripple.\n     */\n  transformMenu: trigger('transformMenu', [state('void', style({\n    opacity: 0,\n    transform: 'scale(0.8)'\n  })), transition('void => enter', group([query('.mat-menu-content', animate('100ms linear', style({\n    opacity: 1\n  }))), animate('120ms cubic-bezier(0, 0, 0.2, 1)', style({\n    transform: 'scale(1)'\n  }))])), transition('* => void', animate('100ms 25ms linear', style({\n    opacity: 0\n  })))]),\n\n  /**\n     * This animation fades in the background color and content of the menu panel\n     * after its containing element is scaled in.\n     */\n  fadeInItems: trigger('fadeInItems', [// TODO(crisbeto): this is inside the `transformMenu`\n  // now. Remove next time we do breaking changes.\n  state('showing', style({\n    opacity: 1\n  })), transition('void => *', [style({\n    opacity: 0\n  }), animate('400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)')])])\n};\n/** *\n * @deprecated\n * \\@breaking-change 8.0.0\n * \\@docs-private\n  @type {?} */\n\nvar fadeInItems = matMenuAnimations.fadeInItems;\n/** *\n * @deprecated\n * \\@breaking-change 8.0.0\n * \\@docs-private\n  @type {?} */\n\nvar transformMenu = matMenuAnimations.transformMenu;\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * Throws an exception for the case when menu trigger doesn't have a valid mat-menu instance\n * \\@docs-private\n * @return {?}\n */\n\nfunction throwMatMenuMissingError() {\n  throw Error(\"matMenuTriggerFor: must pass in an mat-menu instance.\\n\\n    Example:\\n      <mat-menu #menu=\\\"matMenu\\\"></mat-menu>\\n      <button [matMenuTriggerFor]=\\\"menu\\\"></button>\");\n}\n/**\n * Throws an exception for the case when menu's x-position value isn't valid.\n * In other words, it doesn't match 'before' or 'after'.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction throwMatMenuInvalidPositionX() {\n  throw Error(\"xPosition value must be either 'before' or after'.\\n      Example: <mat-menu xPosition=\\\"before\\\" #menu=\\\"matMenu\\\"></mat-menu>\");\n}\n/**\n * Throws an exception for the case when menu's y-position value isn't valid.\n * In other words, it doesn't match 'above' or 'below'.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction throwMatMenuInvalidPositionY() {\n  throw Error(\"yPosition value must be either 'above' or below'.\\n      Example: <mat-menu yPosition=\\\"above\\\" #menu=\\\"matMenu\\\"></mat-menu>\");\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** *\n * Injection token used to provide the parent menu to menu-specific components.\n * \\@docs-private\n  @type {?} */\n\n\nvar MAT_MENU_PANEL = new InjectionToken('MAT_MENU_PANEL');\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * \\@docs-private\n */\n\nvar MatMenuItemBase = function MatMenuItemBase() {\n  _classCallCheck(this, MatMenuItemBase);\n};\n/** @type {?} */\n\n\nvar _MatMenuItemMixinBase = mixinDisableRipple(mixinDisabled(MatMenuItemBase));\n/**\n * This directive is intended to be used inside an mat-menu tag.\n * It exists mostly to set the role attribute.\n */\n\n\nvar MatMenuItem = /*#__PURE__*/function (_MatMenuItemMixinBase2) {\n  _inherits(MatMenuItem, _MatMenuItemMixinBase2);\n\n  var _super = _createSuper(MatMenuItem);\n\n  /**\n   * @param {?} _elementRef\n   * @param {?=} document\n   * @param {?=} _focusMonitor\n   * @param {?=} _parentMenu\n   */\n  function MatMenuItem(_elementRef, document, _focusMonitor, _parentMenu) {\n    var _this;\n\n    _classCallCheck(this, MatMenuItem);\n\n    // @breaking-change 8.0.0 make `_focusMonitor` and `document` required params.\n    _this = _super.call(this);\n    _this._elementRef = _elementRef;\n    _this._focusMonitor = _focusMonitor;\n    _this._parentMenu = _parentMenu;\n    /**\n     * Stream that emits when the menu item is hovered.\n     */\n\n    _this._hovered = new Subject();\n    /**\n     * Whether the menu item is highlighted.\n     */\n\n    _this._highlighted = false;\n    /**\n     * Whether the menu item acts as a trigger for a sub-menu.\n     */\n\n    _this._triggersSubmenu = false;\n\n    if (_focusMonitor) {\n      // Start monitoring the element so it gets the appropriate focused classes. We want\n      // to show the focus style for menu items only when the focus was not caused by a\n      // mouse or touch interaction.\n      _focusMonitor.monitor(_this._elementRef, false);\n    }\n\n    if (_parentMenu && _parentMenu.addItem) {\n      _parentMenu.addItem(_assertThisInitialized(_this));\n    }\n\n    _this._document = document;\n    return _this;\n  }\n  /**\n   * Focuses the menu item.\n   * @param {?=} origin\n   * @return {?}\n   */\n\n\n  _createClass(MatMenuItem, [{\n    key: \"focus\",\n    value: function focus() {\n      var origin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'program';\n\n      if (this._focusMonitor) {\n        this._focusMonitor.focusVia(this._getHostElement(), origin);\n      } else {\n        this._getHostElement().focus();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      if (this._focusMonitor) {\n        this._focusMonitor.stopMonitoring(this._elementRef);\n      }\n\n      if (this._parentMenu && this._parentMenu.removeItem) {\n        this._parentMenu.removeItem(this);\n      }\n\n      this._hovered.complete();\n    }\n    /**\n     * Used to set the `tabindex`.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_getTabIndex\",\n    value: function _getTabIndex() {\n      return this.disabled ? '-1' : '0';\n    }\n    /**\n     * Returns the host DOM element.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_getHostElement\",\n    value: function _getHostElement() {\n      return this._elementRef.nativeElement;\n    }\n    /**\n     * Prevents the default element actions if it is disabled.\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"_checkDisabled\",\n    value: function _checkDisabled(event) {\n      if (this.disabled) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n    /**\n     * Emits to the hover stream.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_handleMouseEnter\",\n    value: function _handleMouseEnter() {\n      this._hovered.next(this);\n    }\n    /**\n     * Gets the label to be used when determining whether the option should be focused.\n     * @return {?}\n     */\n\n  }, {\n    key: \"getLabel\",\n    value: function getLabel() {\n      /** @type {?} */\n      var element = this._elementRef.nativeElement;\n      /** @type {?} */\n\n      var textNodeType = this._document ? this._document.TEXT_NODE : 3;\n      /** @type {?} */\n\n      var output = '';\n\n      if (element.childNodes) {\n        /** @type {?} */\n        var length = element.childNodes.length; // Go through all the top-level text nodes and extract their text.\n        // We skip anything that's not a text node to prevent the text from\n        // being thrown off by something like an icon.\n\n        for (var i = 0; i < length; i++) {\n          if (element.childNodes[i].nodeType === textNodeType) {\n            output += element.childNodes[i].textContent;\n          }\n        }\n      }\n\n      return output.trim();\n    }\n  }]);\n\n  return MatMenuItem;\n}(_MatMenuItemMixinBase);\n\nMatMenuItem.ɵfac = function MatMenuItem_Factory(t) {\n  return new (t || MatMenuItem)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.FocusMonitor), ɵngcc0.ɵɵdirectiveInject(MAT_MENU_PANEL, 8));\n};\n\nMatMenuItem.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: MatMenuItem,\n  selectors: [[\"\", \"mat-menu-item\", \"\"]],\n  hostAttrs: [\"role\", \"menuitem\", 1, \"mat-menu-item\"],\n  hostVars: 7,\n  hostBindings: function MatMenuItem_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵlistener(\"click\", function MatMenuItem_click_HostBindingHandler($event) {\n        return ctx._checkDisabled($event);\n      })(\"mouseenter\", function MatMenuItem_mouseenter_HostBindingHandler() {\n        return ctx._handleMouseEnter();\n      });\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵattribute(\"tabindex\", ctx._getTabIndex())(\"aria-disabled\", ctx.disabled.toString())(\"disabled\", ctx.disabled || null);\n      ɵngcc0.ɵɵclassProp(\"mat-menu-item-highlighted\", ctx._highlighted)(\"mat-menu-item-submenu-trigger\", ctx._triggersSubmenu);\n    }\n  },\n  inputs: {\n    disabled: \"disabled\",\n    disableRipple: \"disableRipple\"\n  },\n  exportAs: [\"matMenuItem\"],\n  features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n  attrs: _c0,\n  ngContentSelectors: _c1,\n  decls: 2,\n  vars: 2,\n  consts: [[\"matRipple\", \"\", 1, \"mat-menu-ripple\", 3, \"matRippleDisabled\", \"matRippleTrigger\"]],\n  template: function MatMenuItem_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵprojectionDef();\n      ɵngcc0.ɵɵprojection(0);\n      ɵngcc0.ɵɵelement(1, \"div\", 0);\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵadvance(1);\n      ɵngcc0.ɵɵproperty(\"matRippleDisabled\", ctx.disableRipple || ctx.disabled)(\"matRippleTrigger\", ctx._getHostElement());\n    }\n  },\n  directives: [ɵngcc2.MatRipple],\n  encapsulation: 2,\n  changeDetection: 0\n});\n/** @nocollapse */\n\nMatMenuItem.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }, {\n    type: FocusMonitor\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [MAT_MENU_PANEL]\n    }, {\n      type: Optional\n    }]\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatMenuItem, [{\n    type: Component,\n    args: [{\n      selector: '[mat-menu-item]',\n      exportAs: 'matMenuItem',\n      inputs: ['disabled', 'disableRipple'],\n      host: {\n        'role': 'menuitem',\n        'class': 'mat-menu-item',\n        '[class.mat-menu-item-highlighted]': '_highlighted',\n        '[class.mat-menu-item-submenu-trigger]': '_triggersSubmenu',\n        '[attr.tabindex]': '_getTabIndex()',\n        '[attr.aria-disabled]': 'disabled.toString()',\n        '[attr.disabled]': 'disabled || null',\n        '(click)': '_checkDisabled($event)',\n        '(mouseenter)': '_handleMouseEnter()'\n      },\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      encapsulation: ViewEncapsulation.None,\n      template: \"<ng-content></ng-content><div class=\\\"mat-menu-ripple\\\" matRipple [matRippleDisabled]=\\\"disableRipple || disabled\\\" [matRippleTrigger]=\\\"_getHostElement()\\\"></div>\"\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: ɵngcc1.FocusMonitor\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [MAT_MENU_PANEL]\n      }, {\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** *\n * Injection token to be used to override the default options for `mat-menu`.\n  @type {?} */\n\n\nvar MAT_MENU_DEFAULT_OPTIONS = new InjectionToken('mat-menu-default-options', {\n  providedIn: 'root',\n  factory: MAT_MENU_DEFAULT_OPTIONS_FACTORY\n});\n/**\n * \\@docs-private\n * @return {?}\n */\n\nfunction MAT_MENU_DEFAULT_OPTIONS_FACTORY() {\n  return {\n    overlapTrigger: false,\n    xPosition: 'after',\n    yPosition: 'below',\n    backdropClass: 'cdk-overlay-transparent-backdrop'\n  };\n}\n/** *\n * Start elevation for the menu panel.\n * \\@docs-private\n  @type {?} */\n\n\nvar MAT_MENU_BASE_ELEVATION = 4;\n\nvar MatMenu = /*#__PURE__*/function () {\n  /**\n   * @param {?} _elementRef\n   * @param {?} _ngZone\n   * @param {?} _defaultOptions\n   */\n  function MatMenu(_elementRef, _ngZone, _defaultOptions) {\n    _classCallCheck(this, MatMenu);\n\n    this._elementRef = _elementRef;\n    this._ngZone = _ngZone;\n    this._defaultOptions = _defaultOptions;\n    this._xPosition = this._defaultOptions.xPosition;\n    this._yPosition = this._defaultOptions.yPosition;\n    /**\n     * Menu items inside the current menu.\n     */\n\n    this._items = [];\n    /**\n     * Emits whenever the amount of menu items changes.\n     */\n\n    this._itemChanges = new Subject();\n    /**\n     * Subscription to tab events on the menu panel\n     */\n\n    this._tabSubscription = Subscription.EMPTY;\n    /**\n     * Config object to be passed into the menu's ngClass\n     */\n\n    this._classList = {};\n    /**\n     * Current state of the panel animation.\n     */\n\n    this._panelAnimationState = 'void';\n    /**\n     * Emits whenever an animation on the menu completes.\n     */\n\n    this._animationDone = new Subject();\n    /**\n     * Class to be added to the backdrop element.\n     */\n\n    this.backdropClass = this._defaultOptions.backdropClass;\n    this._overlapTrigger = this._defaultOptions.overlapTrigger;\n    this._hasBackdrop = this._defaultOptions.hasBackdrop;\n    /**\n     * Event emitted when the menu is closed.\n     */\n\n    this.closed = new EventEmitter();\n    /**\n     * Event emitted when the menu is closed.\n     * @deprecated Switch to `closed` instead\n     * \\@breaking-change 8.0.0\n     */\n\n    this.close = this.closed;\n  }\n  /**\n   * Position of the menu in the X axis.\n   * @return {?}\n   */\n\n\n  _createClass(MatMenu, [{\n    key: \"xPosition\",\n    get: function get() {\n      return this._xPosition;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ,\n    set: function set(value) {\n      if (value !== 'before' && value !== 'after') {\n        throwMatMenuInvalidPositionX();\n      }\n\n      this._xPosition = value;\n      this.setPositionClasses();\n    }\n    /**\n     * Position of the menu in the Y axis.\n     * @return {?}\n     */\n\n  }, {\n    key: \"yPosition\",\n    get: function get() {\n      return this._yPosition;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ,\n    set: function set(value) {\n      if (value !== 'above' && value !== 'below') {\n        throwMatMenuInvalidPositionY();\n      }\n\n      this._yPosition = value;\n      this.setPositionClasses();\n    }\n    /**\n     * Whether the menu should overlap its trigger.\n     * @return {?}\n     */\n\n  }, {\n    key: \"overlapTrigger\",\n    get: function get() {\n      return this._overlapTrigger;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ,\n    set: function set(value) {\n      this._overlapTrigger = coerceBooleanProperty(value);\n    }\n    /**\n     * Whether the menu has a backdrop.\n     * @return {?}\n     */\n\n  }, {\n    key: \"hasBackdrop\",\n    get: function get() {\n      return this._hasBackdrop;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ,\n    set: function set(value) {\n      this._hasBackdrop = coerceBooleanProperty(value);\n    }\n    /**\n     * This method takes classes set on the host mat-menu element and applies them on the\n     * menu template that displays in the overlay container.  Otherwise, it's difficult\n     * to style the containing menu from outside the component.\n     * @param {?} classes list of class names\n     * @return {?}\n     */\n\n  }, {\n    key: \"panelClass\",\n    set: function set(classes) {\n      if (classes && classes.length) {\n        this._classList = classes.split(' ').reduce(function (obj, className) {\n          obj[className] = true;\n          return obj;\n        }, {});\n        this._elementRef.nativeElement.className = '';\n      }\n    }\n    /**\n     * This method takes classes set on the host mat-menu element and applies them on the\n     * menu template that displays in the overlay container.  Otherwise, it's difficult\n     * to style the containing menu from outside the component.\n     * @deprecated Use `panelClass` instead.\n     * \\@breaking-change 8.0.0\n     * @return {?}\n     */\n\n  }, {\n    key: \"classList\",\n    get: function get() {\n      return this.panelClass;\n    }\n    /**\n     * @param {?} classes\n     * @return {?}\n     */\n    ,\n    set: function set(classes) {\n      this.panelClass = classes;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      this.setPositionClasses();\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngAfterContentInit\",\n    value: function ngAfterContentInit() {\n      var _this2 = this;\n\n      this._keyManager = new FocusKeyManager(this._items).withWrap().withTypeAhead();\n      this._tabSubscription = this._keyManager.tabOut.subscribe(function () {\n        return _this2.closed.emit('tab');\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this._tabSubscription.unsubscribe();\n\n      this.closed.complete();\n    }\n    /**\n     * Stream that emits whenever the hovered menu item changes.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_hovered\",\n    value: function _hovered() {\n      return this._itemChanges.pipe(startWith(this._items), switchMap(function (items) {\n        return merge.apply(void 0, _toConsumableArray(items.map(function (item) {\n          return item._hovered;\n        })));\n      }));\n    }\n    /**\n     * Handle a keyboard event from the menu, delegating to the appropriate action.\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"_handleKeydown\",\n    value: function _handleKeydown(event) {\n      /** @type {?} */\n      var keyCode = event.keyCode;\n\n      switch (keyCode) {\n        case ESCAPE:\n          this.closed.emit('keydown');\n          break;\n\n        case LEFT_ARROW:\n          if (this.parentMenu && this.direction === 'ltr') {\n            this.closed.emit('keydown');\n          }\n\n          break;\n\n        case RIGHT_ARROW:\n          if (this.parentMenu && this.direction === 'rtl') {\n            this.closed.emit('keydown');\n          }\n\n          break;\n\n        default:\n          if (keyCode === UP_ARROW || keyCode === DOWN_ARROW) {\n            this._keyManager.setFocusOrigin('keyboard');\n          }\n\n          this._keyManager.onKeydown(event);\n\n      }\n    }\n    /**\n     * Focus the first item in the menu.\n     * @param {?=} origin Action from which the focus originated. Used to set the correct styling.\n     * @return {?}\n     */\n\n  }, {\n    key: \"focusFirstItem\",\n    value: function focusFirstItem() {\n      var _this3 = this;\n\n      var origin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'program';\n\n      // When the content is rendered lazily, it takes a bit before the items are inside the DOM.\n      if (this.lazyContent) {\n        this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(function () {\n          return _this3._keyManager.setFocusOrigin(origin).setFirstItemActive();\n        });\n      } else {\n        this._keyManager.setFocusOrigin(origin).setFirstItemActive();\n      }\n    }\n    /**\n     * Resets the active item in the menu. This is used when the menu is opened, allowing\n     * the user to start from the first option when pressing the down arrow.\n     * @return {?}\n     */\n\n  }, {\n    key: \"resetActiveItem\",\n    value: function resetActiveItem() {\n      this._keyManager.setActiveItem(-1);\n    }\n    /**\n     * Sets the menu panel elevation.\n     * @param {?} depth Number of parent menus that come before the menu.\n     * @return {?}\n     */\n\n  }, {\n    key: \"setElevation\",\n    value: function setElevation(depth) {\n      /** @type {?} */\n      var newElevation = \"mat-elevation-z\".concat(MAT_MENU_BASE_ELEVATION + depth);\n      /** @type {?} */\n\n      var customElevation = Object.keys(this._classList).find(function (c) {\n        return c.startsWith('mat-elevation-z');\n      });\n\n      if (!customElevation || customElevation === this._previousElevation) {\n        if (this._previousElevation) {\n          this._classList[this._previousElevation] = false;\n        }\n\n        this._classList[newElevation] = true;\n        this._previousElevation = newElevation;\n      }\n    }\n    /**\n     * Registers a menu item with the menu.\n     * \\@docs-private\n     * @param {?} item\n     * @return {?}\n     */\n\n  }, {\n    key: \"addItem\",\n    value: function addItem(item) {\n      // We register the items through this method, rather than picking them up through\n      // `ContentChildren`, because we need the items to be picked up by their closest\n      // `mat-menu` ancestor. If we used `@ContentChildren(MatMenuItem, {descendants: true})`,\n      // all descendant items will bleed into the top-level menu in the case where the consumer\n      // has `mat-menu` instances nested inside each other.\n      if (this._items.indexOf(item) === -1) {\n        this._items.push(item);\n\n        this._itemChanges.next(this._items);\n      }\n    }\n    /**\n     * Removes an item from the menu.\n     * \\@docs-private\n     * @param {?} item\n     * @return {?}\n     */\n\n  }, {\n    key: \"removeItem\",\n    value: function removeItem(item) {\n      /** @type {?} */\n      var index = this._items.indexOf(item);\n\n      if (this._items.indexOf(item) > -1) {\n        this._items.splice(index, 1);\n\n        this._itemChanges.next(this._items);\n      }\n    }\n    /**\n     * Adds classes to the menu panel based on its position. Can be used by\n     * consumers to add specific styling based on the position.\n     * \\@docs-private\n     * @param {?=} posX Position of the menu along the x axis.\n     * @param {?=} posY Position of the menu along the y axis.\n     * @return {?}\n     */\n\n  }, {\n    key: \"setPositionClasses\",\n    value: function setPositionClasses() {\n      var posX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.xPosition;\n      var posY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.yPosition;\n\n      /** @type {?} */\n      var classes = this._classList;\n      classes['mat-menu-before'] = posX === 'before';\n      classes['mat-menu-after'] = posX === 'after';\n      classes['mat-menu-above'] = posY === 'above';\n      classes['mat-menu-below'] = posY === 'below';\n    }\n    /**\n     * Starts the enter animation.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_startAnimation\",\n    value: function _startAnimation() {\n      // @breaking-change 8.0.0 Combine with _resetAnimation.\n      this._panelAnimationState = 'enter';\n    }\n    /**\n     * Resets the panel animation to its initial state.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_resetAnimation\",\n    value: function _resetAnimation() {\n      // @breaking-change 8.0.0 Combine with _startAnimation.\n      this._panelAnimationState = 'void';\n    }\n    /**\n     * Callback that is invoked when the panel animation completes.\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"_onAnimationDone\",\n    value: function _onAnimationDone(event) {\n      this._animationDone.next(event);\n\n      this._isAnimating = false; // Scroll the content element to the top once the animation is done. This is necessary, because\n      // we move focus to the first item while it's still being animated, which can throw the browser\n      // off when it determines the scroll position. Alternatively we can move focus when the\n      // animation is done, however moving focus asynchronously will interrupt screen readers\n      // which are in the process of reading out the menu already. We take the `element` from\n      // the `event` since we can't use a `ViewChild` to access the pane.\n\n      if (event.toState === 'enter' && this._keyManager.activeItemIndex === 0) {\n        event.element.scrollTop = 0;\n      }\n    }\n  }]);\n\n  return MatMenu;\n}();\n\nMatMenu.ɵfac = function MatMenu_Factory(t) {\n  return new (t || MatMenu)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MAT_MENU_DEFAULT_OPTIONS));\n};\n\nMatMenu.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: MatMenu,\n  selectors: [[\"mat-menu\"]],\n  contentQueries: function MatMenu_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵcontentQuery(dirIndex, MatMenuContent, 5);\n      ɵngcc0.ɵɵcontentQuery(dirIndex, MatMenuItem, 4);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.lazyContent = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.items = _t);\n    }\n  },\n  viewQuery: function MatMenu_Query(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵviewQuery(TemplateRef, 5);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templateRef = _t.first);\n    }\n  },\n  inputs: {\n    backdropClass: \"backdropClass\",\n    xPosition: \"xPosition\",\n    yPosition: \"yPosition\",\n    overlapTrigger: \"overlapTrigger\",\n    hasBackdrop: \"hasBackdrop\",\n    panelClass: [\"class\", \"panelClass\"],\n    classList: \"classList\"\n  },\n  outputs: {\n    closed: \"closed\",\n    close: \"close\"\n  },\n  exportAs: [\"matMenu\"],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: MAT_MENU_PANEL,\n    useExisting: MatMenu\n  }])],\n  ngContentSelectors: _c1,\n  decls: 1,\n  vars: 0,\n  consts: [[\"tabindex\", \"-1\", \"role\", \"menu\", 1, \"mat-menu-panel\", 3, \"ngClass\", \"keydown\", \"click\"], [1, \"mat-menu-content\"]],\n  template: function MatMenu_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵprojectionDef();\n      ɵngcc0.ɵɵtemplate(0, MatMenu_ng_template_0_Template, 3, 2, \"ng-template\");\n    }\n  },\n  directives: [ɵngcc3.NgClass],\n  styles: [\".mat-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh - 48px);border-radius:4px;outline:0}@media screen and (-ms-high-contrast:active){.mat-menu-panel{outline:solid 1px}}.mat-menu-content:not(:empty){padding-top:8px;padding-bottom:8px}.mat-menu-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative}.mat-menu-item::-moz-focus-inner{border:0}.mat-menu-item[disabled]{cursor:default}[dir=rtl] .mat-menu-item{text-align:right}.mat-menu-item .mat-icon{margin-right:16px;vertical-align:middle}.mat-menu-item .mat-icon svg{vertical-align:top}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px;margin-right:0}@media screen and (-ms-high-contrast:active){.mat-menu-item-highlighted,.mat-menu-item.cdk-keyboard-focused,.mat-menu-item.cdk-program-focused{outline:dotted 1px}}.mat-menu-item-submenu-trigger{padding-right:32px}.mat-menu-item-submenu-trigger::after{width:0;height:0;border-style:solid;border-width:5px 0 5px 5px;border-color:transparent transparent transparent currentColor;content:'';display:inline-block;position:absolute;top:50%;right:16px;transform:translateY(-50%)}[dir=rtl] .mat-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}[dir=rtl] .mat-menu-item-submenu-trigger::after{right:auto;left:16px;transform:rotateY(180deg) translateY(-50%)}.mat-menu-panel.ng-animating .mat-menu-item-submenu-trigger{pointer-events:none}button.mat-menu-item{width:100%}.mat-menu-item .mat-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\"],\n  encapsulation: 2,\n  data: {\n    animation: [matMenuAnimations.transformMenu, matMenuAnimations.fadeInItems]\n  },\n  changeDetection: 0\n});\n/** @nocollapse */\n\nMatMenu.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: NgZone\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [MAT_MENU_DEFAULT_OPTIONS]\n    }]\n  }];\n};\n\nMatMenu.propDecorators = {\n  backdropClass: [{\n    type: Input\n  }],\n  xPosition: [{\n    type: Input\n  }],\n  yPosition: [{\n    type: Input\n  }],\n  templateRef: [{\n    type: ViewChild,\n    args: [TemplateRef]\n  }],\n  items: [{\n    type: ContentChildren,\n    args: [MatMenuItem]\n  }],\n  lazyContent: [{\n    type: ContentChild,\n    args: [MatMenuContent]\n  }],\n  overlapTrigger: [{\n    type: Input\n  }],\n  hasBackdrop: [{\n    type: Input\n  }],\n  panelClass: [{\n    type: Input,\n    args: ['class']\n  }],\n  classList: [{\n    type: Input\n  }],\n  closed: [{\n    type: Output\n  }],\n  close: [{\n    type: Output\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatMenu, [{\n    type: Component,\n    args: [{\n      selector: 'mat-menu',\n      template: \"<ng-template><div class=\\\"mat-menu-panel\\\" [ngClass]=\\\"_classList\\\" (keydown)=\\\"_handleKeydown($event)\\\" (click)=\\\"closed.emit('click')\\\" [@transformMenu]=\\\"_panelAnimationState\\\" (@transformMenu.start)=\\\"_isAnimating = true\\\" (@transformMenu.done)=\\\"_onAnimationDone($event)\\\" tabindex=\\\"-1\\\" role=\\\"menu\\\"><div class=\\\"mat-menu-content\\\"><ng-content></ng-content></div></div></ng-template>\",\n      styles: [\".mat-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh - 48px);border-radius:4px;outline:0}@media screen and (-ms-high-contrast:active){.mat-menu-panel{outline:solid 1px}}.mat-menu-content:not(:empty){padding-top:8px;padding-bottom:8px}.mat-menu-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative}.mat-menu-item::-moz-focus-inner{border:0}.mat-menu-item[disabled]{cursor:default}[dir=rtl] .mat-menu-item{text-align:right}.mat-menu-item .mat-icon{margin-right:16px;vertical-align:middle}.mat-menu-item .mat-icon svg{vertical-align:top}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px;margin-right:0}@media screen and (-ms-high-contrast:active){.mat-menu-item-highlighted,.mat-menu-item.cdk-keyboard-focused,.mat-menu-item.cdk-program-focused{outline:dotted 1px}}.mat-menu-item-submenu-trigger{padding-right:32px}.mat-menu-item-submenu-trigger::after{width:0;height:0;border-style:solid;border-width:5px 0 5px 5px;border-color:transparent transparent transparent currentColor;content:'';display:inline-block;position:absolute;top:50%;right:16px;transform:translateY(-50%)}[dir=rtl] .mat-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}[dir=rtl] .mat-menu-item-submenu-trigger::after{right:auto;left:16px;transform:rotateY(180deg) translateY(-50%)}.mat-menu-panel.ng-animating .mat-menu-item-submenu-trigger{pointer-events:none}button.mat-menu-item{width:100%}.mat-menu-item .mat-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\"],\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      encapsulation: ViewEncapsulation.None,\n      exportAs: 'matMenu',\n      animations: [matMenuAnimations.transformMenu, matMenuAnimations.fadeInItems],\n      providers: [{\n        provide: MAT_MENU_PANEL,\n        useExisting: MatMenu\n      }]\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc0.NgZone\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [MAT_MENU_DEFAULT_OPTIONS]\n      }]\n    }];\n  }, {\n    backdropClass: [{\n      type: Input\n    }],\n    closed: [{\n      type: Output\n    }],\n    close: [{\n      type: Output\n    }],\n    xPosition: [{\n      type: Input\n    }],\n    yPosition: [{\n      type: Input\n    }],\n    overlapTrigger: [{\n      type: Input\n    }],\n    hasBackdrop: [{\n      type: Input\n    }],\n    panelClass: [{\n      type: Input,\n      args: ['class']\n    }],\n    classList: [{\n      type: Input\n    }],\n    templateRef: [{\n      type: ViewChild,\n      args: [TemplateRef]\n    }],\n    items: [{\n      type: ContentChildren,\n      args: [MatMenuItem]\n    }],\n    lazyContent: [{\n      type: ContentChild,\n      args: [MatMenuContent]\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** *\n * Injection token that determines the scroll handling while the menu is open.\n  @type {?} */\n\n\nvar MAT_MENU_SCROLL_STRATEGY = new InjectionToken('mat-menu-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\n\nfunction MAT_MENU_SCROLL_STRATEGY_FACTORY(overlay) {\n  return function () {\n    return overlay.scrollStrategies.reposition();\n  };\n}\n/** *\n * \\@docs-private\n  @type {?} */\n\n\nvar MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n  provide: MAT_MENU_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: MAT_MENU_SCROLL_STRATEGY_FACTORY\n};\n/** *\n * Default top padding of the menu panel.\n  @type {?} */\n\nvar MENU_PANEL_TOP_PADDING = 8;\n/**\n * This directive is intended to be used in conjunction with an mat-menu tag.  It is\n * responsible for toggling the display of the provided menu instance.\n */\n\nvar MatMenuTrigger = /*#__PURE__*/function () {\n  /**\n   * @param {?} _overlay\n   * @param {?} _element\n   * @param {?} _viewContainerRef\n   * @param {?} scrollStrategy\n   * @param {?} _parentMenu\n   * @param {?} _menuItemInstance\n   * @param {?} _dir\n   * @param {?=} _focusMonitor\n   */\n  function MatMenuTrigger(_overlay, _element, _viewContainerRef, scrollStrategy, _parentMenu, _menuItemInstance, _dir, _focusMonitor) {\n    _classCallCheck(this, MatMenuTrigger);\n\n    this._overlay = _overlay;\n    this._element = _element;\n    this._viewContainerRef = _viewContainerRef;\n    this._parentMenu = _parentMenu;\n    this._menuItemInstance = _menuItemInstance;\n    this._dir = _dir;\n    this._focusMonitor = _focusMonitor;\n    this._overlayRef = null;\n    this._menuOpen = false;\n    this._closeSubscription = Subscription.EMPTY;\n    this._hoverSubscription = Subscription.EMPTY; // Tracking input type is necessary so it's possible to only auto-focus\n    // the first item of the list when the menu is opened via the keyboard\n\n    this._openedBy = null;\n    /**\n     * Event emitted when the associated menu is opened.\n     */\n\n    this.menuOpened = new EventEmitter();\n    /**\n     * Event emitted when the associated menu is opened.\n     * @deprecated Switch to `menuOpened` instead\n     * \\@breaking-change 8.0.0\n     */\n\n    this.onMenuOpen = this.menuOpened;\n    /**\n     * Event emitted when the associated menu is closed.\n     */\n\n    this.menuClosed = new EventEmitter();\n    /**\n     * Event emitted when the associated menu is closed.\n     * @deprecated Switch to `menuClosed` instead\n     * \\@breaking-change 8.0.0\n     */\n\n    this.onMenuClose = this.menuClosed;\n\n    if (_menuItemInstance) {\n      _menuItemInstance._triggersSubmenu = this.triggersSubmenu();\n    }\n\n    this._scrollStrategy = scrollStrategy;\n  }\n  /**\n   * @deprecated\n   * \\@breaking-change 8.0.0\n   * @return {?}\n   */\n\n\n  _createClass(MatMenuTrigger, [{\n    key: \"_deprecatedMatMenuTriggerFor\",\n    get: function get() {\n      return this.menu;\n    }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    ,\n    set: function set(v) {\n      this.menu = v;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngAfterContentInit\",\n    value: function ngAfterContentInit() {\n      var _this4 = this;\n\n      this._checkMenu();\n\n      this.menu.close.asObservable().subscribe(function (reason) {\n        _this4._destroyMenu(); // If a click closed the menu, we should close the entire chain of nested menus.\n\n\n        if ((reason === 'click' || reason === 'tab') && _this4._parentMenu) {\n          _this4._parentMenu.closed.emit(reason);\n        }\n      });\n\n      this._handleHover();\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      if (this._overlayRef) {\n        this._overlayRef.dispose();\n\n        this._overlayRef = null;\n      }\n\n      this._cleanUpSubscriptions();\n    }\n    /**\n     * Whether the menu is open.\n     * @return {?}\n     */\n\n  }, {\n    key: \"menuOpen\",\n    get: function get() {\n      return this._menuOpen;\n    }\n    /**\n     * The text direction of the containing app.\n     * @return {?}\n     */\n\n  }, {\n    key: \"dir\",\n    get: function get() {\n      return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n    }\n    /**\n     * Whether the menu triggers a sub-menu or a top-level one.\n     * @return {?}\n     */\n\n  }, {\n    key: \"triggersSubmenu\",\n    value: function triggersSubmenu() {\n      return !!(this._menuItemInstance && this._parentMenu);\n    }\n    /**\n     * Toggles the menu between the open and closed states.\n     * @return {?}\n     */\n\n  }, {\n    key: \"toggleMenu\",\n    value: function toggleMenu() {\n      return this._menuOpen ? this.closeMenu() : this.openMenu();\n    }\n    /**\n     * Opens the menu.\n     * @return {?}\n     */\n\n  }, {\n    key: \"openMenu\",\n    value: function openMenu() {\n      var _this5 = this;\n\n      if (this._menuOpen) {\n        return;\n      }\n\n      this._checkMenu();\n      /** @type {?} */\n\n\n      var overlayRef = this._createOverlay();\n\n      this._setPosition(\n      /** @type {?} */\n      overlayRef.getConfig().positionStrategy);\n\n      overlayRef.attach(this._portal);\n\n      if (this.menu.lazyContent) {\n        this.menu.lazyContent.attach(this.menuData);\n      }\n\n      this._closeSubscription = this._menuClosingActions().subscribe(function () {\n        return _this5.closeMenu();\n      });\n\n      this._initMenu();\n\n      if (this.menu instanceof MatMenu) {\n        this.menu._startAnimation();\n      }\n    }\n    /**\n     * Closes the menu.\n     * @return {?}\n     */\n\n  }, {\n    key: \"closeMenu\",\n    value: function closeMenu() {\n      this.menu.close.emit();\n    }\n    /**\n     * Focuses the menu trigger.\n     * @param {?=} origin Source of the menu trigger's focus.\n     * @return {?}\n     */\n\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      var origin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'program';\n\n      if (this._focusMonitor) {\n        this._focusMonitor.focusVia(this._element, origin);\n      } else {\n        this._element.nativeElement.focus();\n      }\n    }\n    /**\n     * Closes the menu and does the necessary cleanup.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_destroyMenu\",\n    value: function _destroyMenu() {\n      var _this6 = this;\n\n      if (!this._overlayRef || !this.menuOpen) {\n        return;\n      }\n      /** @type {?} */\n\n\n      var menu = this.menu;\n\n      this._closeSubscription.unsubscribe();\n\n      this._overlayRef.detach();\n\n      if (menu instanceof MatMenu) {\n        menu._resetAnimation();\n\n        if (menu.lazyContent) {\n          // Wait for the exit animation to finish before detaching the content.\n          menu._animationDone.pipe(filter(function (event) {\n            return event.toState === 'void';\n          }), take(1), // Interrupt if the content got re-attached.\n          takeUntil(menu.lazyContent._attached)).subscribe(function () {\n            return (\n              /** @type {?} */\n              menu.lazyContent.detach()\n            );\n          }, undefined, function () {\n            // No matter whether the content got re-attached, reset the menu.\n            _this6._resetMenu();\n          });\n        } else {\n          this._resetMenu();\n        }\n      } else {\n        this._resetMenu();\n\n        if (menu.lazyContent) {\n          menu.lazyContent.detach();\n        }\n      }\n    }\n    /**\n     * This method sets the menu state to open and focuses the first item if\n     * the menu was opened via the keyboard.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_initMenu\",\n    value: function _initMenu() {\n      this.menu.parentMenu = this.triggersSubmenu() ? this._parentMenu : undefined;\n      this.menu.direction = this.dir;\n\n      this._setMenuElevation();\n\n      this._setIsMenuOpen(true);\n\n      this.menu.focusFirstItem(this._openedBy || 'program');\n    }\n    /**\n     * Updates the menu elevation based on the amount of parent menus that it has.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_setMenuElevation\",\n    value: function _setMenuElevation() {\n      if (this.menu.setElevation) {\n        /** @type {?} */\n        var depth = 0;\n        /** @type {?} */\n\n        var parentMenu = this.menu.parentMenu;\n\n        while (parentMenu) {\n          depth++;\n          parentMenu = parentMenu.parentMenu;\n        }\n\n        this.menu.setElevation(depth);\n      }\n    }\n    /**\n     * This method resets the menu when it's closed, most importantly restoring\n     * focus to the menu trigger if the menu was opened via the keyboard.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_resetMenu\",\n    value: function _resetMenu() {\n      this._setIsMenuOpen(false); // We should reset focus if the user is navigating using a keyboard or\n      // if we have a top-level trigger which might cause focus to be lost\n      // when clicking on the backdrop.\n\n\n      if (!this._openedBy) {\n        // Note that the focus style will show up both for `program` and\n        // `keyboard` so we don't have to specify which one it is.\n        this.focus();\n      } else if (!this.triggersSubmenu()) {\n        this.focus(this._openedBy);\n      }\n\n      this._openedBy = null;\n    }\n    /**\n     * @param {?} isOpen\n     * @return {?}\n     */\n\n  }, {\n    key: \"_setIsMenuOpen\",\n    value: function _setIsMenuOpen(isOpen) {\n      this._menuOpen = isOpen;\n      this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit();\n\n      if (this.triggersSubmenu()) {\n        this._menuItemInstance._highlighted = isOpen;\n      }\n    }\n    /**\n     * This method checks that a valid instance of MatMenu has been passed into\n     * matMenuTriggerFor. If not, an exception is thrown.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_checkMenu\",\n    value: function _checkMenu() {\n      if (!this.menu) {\n        throwMatMenuMissingError();\n      }\n    }\n    /**\n     * This method creates the overlay from the provided menu's template and saves its\n     * OverlayRef so that it can be attached to the DOM when openMenu is called.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_createOverlay\",\n    value: function _createOverlay() {\n      if (!this._overlayRef) {\n        this._portal = new TemplatePortal(this.menu.templateRef, this._viewContainerRef);\n        /** @type {?} */\n\n        var config = this._getOverlayConfig();\n\n        this._subscribeToPositions(\n        /** @type {?} */\n        config.positionStrategy);\n\n        this._overlayRef = this._overlay.create(config); // Consume the `keydownEvents` in order to prevent them from going to another overlay.\n        // Ideally we'd also have our keyboard event logic in here, however doing so will\n        // break anybody that may have implemented the `MatMenuPanel` themselves.\n\n        this._overlayRef.keydownEvents().subscribe();\n      }\n\n      return this._overlayRef;\n    }\n    /**\n     * This method builds the configuration object needed to create the overlay, the OverlayState.\n     * @return {?} OverlayConfig\n     */\n\n  }, {\n    key: \"_getOverlayConfig\",\n    value: function _getOverlayConfig() {\n      return new OverlayConfig({\n        positionStrategy: this._overlay.position().flexibleConnectedTo(this._element).withLockedPosition().withTransformOriginOn('.mat-menu-panel'),\n        hasBackdrop: this.menu.hasBackdrop == null ? !this.triggersSubmenu() : this.menu.hasBackdrop,\n        backdropClass: this.menu.backdropClass || 'cdk-overlay-transparent-backdrop',\n        scrollStrategy: this._scrollStrategy(),\n        direction: this._dir\n      });\n    }\n    /**\n     * Listens to changes in the position of the overlay and sets the correct classes\n     * on the menu based on the new position. This ensures the animation origin is always\n     * correct, even if a fallback position is used for the overlay.\n     * @param {?} position\n     * @return {?}\n     */\n\n  }, {\n    key: \"_subscribeToPositions\",\n    value: function _subscribeToPositions(position) {\n      var _this7 = this;\n\n      if (this.menu.setPositionClasses) {\n        position.positionChanges.subscribe(function (change) {\n          /** @type {?} */\n          var posX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';\n          /** @type {?} */\n\n          var posY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';\n          /** @type {?} */\n\n          _this7.menu.setPositionClasses(posX, posY);\n        });\n      }\n    }\n    /**\n     * Sets the appropriate positions on a position strategy\n     * so the overlay connects with the trigger correctly.\n     * @param {?} positionStrategy Strategy whose position to update.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_setPosition\",\n    value: function _setPosition(positionStrategy) {\n      var _ref = this.menu.xPosition === 'before' ? ['end', 'start'] : ['start', 'end'],\n          _ref2 = _slicedToArray(_ref, 2),\n          originX = _ref2[0],\n          originFallbackX = _ref2[1];\n\n      var _ref3 = this.menu.yPosition === 'above' ? ['bottom', 'top'] : ['top', 'bottom'],\n          _ref4 = _slicedToArray(_ref3, 2),\n          overlayY = _ref4[0],\n          overlayFallbackY = _ref4[1];\n\n      var originY = overlayY,\n          originFallbackY = overlayFallbackY;\n      var overlayX = originX,\n          overlayFallbackX = originFallbackX;\n      /** @type {?} */\n\n      var offsetY = 0;\n\n      if (this.triggersSubmenu()) {\n        // When the menu is a sub-menu, it should always align itself\n        // to the edges of the trigger, instead of overlapping it.\n        overlayFallbackX = originX = this.menu.xPosition === 'before' ? 'start' : 'end';\n        originFallbackX = overlayX = originX === 'end' ? 'start' : 'end';\n        offsetY = overlayY === 'bottom' ? MENU_PANEL_TOP_PADDING : -MENU_PANEL_TOP_PADDING;\n      } else if (!this.menu.overlapTrigger) {\n        originY = overlayY === 'top' ? 'bottom' : 'top';\n        originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';\n      }\n\n      positionStrategy.withPositions([{\n        originX: originX,\n        originY: originY,\n        overlayX: overlayX,\n        overlayY: overlayY,\n        offsetY: offsetY\n      }, {\n        originX: originFallbackX,\n        originY: originY,\n        overlayX: overlayFallbackX,\n        overlayY: overlayY,\n        offsetY: offsetY\n      }, {\n        originX: originX,\n        originY: originFallbackY,\n        overlayX: overlayX,\n        overlayY: overlayFallbackY,\n        offsetY: -offsetY\n      }, {\n        originX: originFallbackX,\n        originY: originFallbackY,\n        overlayX: overlayFallbackX,\n        overlayY: overlayFallbackY,\n        offsetY: -offsetY\n      }]);\n    }\n    /**\n     * Cleans up the active subscriptions.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_cleanUpSubscriptions\",\n    value: function _cleanUpSubscriptions() {\n      this._closeSubscription.unsubscribe();\n\n      this._hoverSubscription.unsubscribe();\n    }\n    /**\n     * Returns a stream that emits whenever an action that should close the menu occurs.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_menuClosingActions\",\n    value: function _menuClosingActions() {\n      var _this8 = this;\n\n      /** @type {?} */\n      var backdrop =\n      /** @type {?} */\n      this._overlayRef.backdropClick();\n      /** @type {?} */\n\n\n      var detachments =\n      /** @type {?} */\n      this._overlayRef.detachments();\n      /** @type {?} */\n\n\n      var parentClose = this._parentMenu ? this._parentMenu.closed : of();\n      /** @type {?} */\n\n      var hover = this._parentMenu ? this._parentMenu._hovered().pipe(filter(function (active) {\n        return active !== _this8._menuItemInstance;\n      }), filter(function () {\n        return _this8._menuOpen;\n      })) : of();\n      return merge(backdrop, parentClose, hover, detachments);\n    }\n    /**\n     * Handles mouse presses on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"_handleMousedown\",\n    value: function _handleMousedown(event) {\n      if (!isFakeMousedownFromScreenReader(event)) {\n        // Since right or middle button clicks won't trigger the `click` event,\n        // we shouldn't consider the menu as opened by mouse in those cases.\n        this._openedBy = event.button === 0 ? 'mouse' : null; // Since clicking on the trigger won't close the menu if it opens a sub-menu,\n        // we should prevent focus from moving onto it via click to avoid the\n        // highlight from lingering on the menu item.\n\n        if (this.triggersSubmenu()) {\n          event.preventDefault();\n        }\n      }\n    }\n    /**\n     * Handles key presses on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"_handleKeydown\",\n    value: function _handleKeydown(event) {\n      /** @type {?} */\n      var keyCode = event.keyCode;\n\n      if (this.triggersSubmenu() && (keyCode === RIGHT_ARROW && this.dir === 'ltr' || keyCode === LEFT_ARROW && this.dir === 'rtl')) {\n        this.openMenu();\n      }\n    }\n    /**\n     * Handles click events on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"_handleClick\",\n    value: function _handleClick(event) {\n      if (this.triggersSubmenu()) {\n        // Stop event propagation to avoid closing the parent menu.\n        event.stopPropagation();\n        this.openMenu();\n      } else {\n        this.toggleMenu();\n      }\n    }\n    /**\n     * Handles the cases where the user hovers over the trigger.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_handleHover\",\n    value: function _handleHover() {\n      var _this9 = this;\n\n      // Subscribe to changes in the hovered item in order to toggle the panel.\n      if (!this.triggersSubmenu()) {\n        return;\n      }\n\n      this._hoverSubscription = this._parentMenu._hovered() // Since we might have multiple competing triggers for the same menu (e.g. a sub-menu\n      // with different data and triggers), we have to delay it by a tick to ensure that\n      // it won't be closed immediately after it is opened.\n      .pipe(filter(function (active) {\n        return active === _this9._menuItemInstance && !active.disabled;\n      }), delay(0, asapScheduler)).subscribe(function () {\n        _this9._openedBy = 'mouse'; // If the same menu is used between multiple triggers, it might still be animating\n        // while the new trigger tries to re-open it. Wait for the animation to finish\n        // before doing so. Also interrupt if the user moves to another item.\n\n        if (_this9.menu instanceof MatMenu && _this9.menu._isAnimating) {\n          // We need the `delay(0)` here in order to avoid\n          // 'changed after checked' errors in some cases. See #12194.\n          _this9.menu._animationDone.pipe(take(1), delay(0, asapScheduler), takeUntil(_this9._parentMenu._hovered())).subscribe(function () {\n            return _this9.openMenu();\n          });\n        } else {\n          _this9.openMenu();\n        }\n      });\n    }\n  }]);\n\n  return MatMenuTrigger;\n}();\n\nMatMenuTrigger.ɵfac = function MatMenuTrigger_Factory(t) {\n  return new (t || MatMenuTrigger)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.Overlay), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(MAT_MENU_SCROLL_STRATEGY), ɵngcc0.ɵɵdirectiveInject(MatMenu, 8), ɵngcc0.ɵɵdirectiveInject(MatMenuItem, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc5.Directionality, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.FocusMonitor));\n};\n\nMatMenuTrigger.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: MatMenuTrigger,\n  selectors: [[\"\", \"mat-menu-trigger-for\", \"\"], [\"\", \"matMenuTriggerFor\", \"\"]],\n  hostAttrs: [\"aria-haspopup\", \"true\"],\n  hostVars: 1,\n  hostBindings: function MatMenuTrigger_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵlistener(\"mousedown\", function MatMenuTrigger_mousedown_HostBindingHandler($event) {\n        return ctx._handleMousedown($event);\n      })(\"touchstart\", function MatMenuTrigger_touchstart_HostBindingHandler() {\n        return ctx._openedBy = \"touch\";\n      })(\"keydown\", function MatMenuTrigger_keydown_HostBindingHandler($event) {\n        return ctx._handleKeydown($event);\n      })(\"click\", function MatMenuTrigger_click_HostBindingHandler($event) {\n        return ctx._handleClick($event);\n      });\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵattribute(\"aria-expanded\", ctx.menuOpen || null);\n    }\n  },\n  inputs: {\n    _deprecatedMatMenuTriggerFor: [\"mat-menu-trigger-for\", \"_deprecatedMatMenuTriggerFor\"],\n    menu: [\"matMenuTriggerFor\", \"menu\"],\n    menuData: [\"matMenuTriggerData\", \"menuData\"]\n  },\n  outputs: {\n    menuOpened: \"menuOpened\",\n    onMenuOpen: \"onMenuOpen\",\n    menuClosed: \"menuClosed\",\n    onMenuClose: \"onMenuClose\"\n  },\n  exportAs: [\"matMenuTrigger\"]\n});\n/** @nocollapse */\n\nMatMenuTrigger.ctorParameters = function () {\n  return [{\n    type: Overlay\n  }, {\n    type: ElementRef\n  }, {\n    type: ViewContainerRef\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [MAT_MENU_SCROLL_STRATEGY]\n    }]\n  }, {\n    type: MatMenu,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: MatMenuItem,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }]\n  }, {\n    type: Directionality,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: FocusMonitor\n  }];\n};\n\nMatMenuTrigger.propDecorators = {\n  _deprecatedMatMenuTriggerFor: [{\n    type: Input,\n    args: ['mat-menu-trigger-for']\n  }],\n  menu: [{\n    type: Input,\n    args: ['matMenuTriggerFor']\n  }],\n  menuData: [{\n    type: Input,\n    args: ['matMenuTriggerData']\n  }],\n  menuOpened: [{\n    type: Output\n  }],\n  onMenuOpen: [{\n    type: Output\n  }],\n  menuClosed: [{\n    type: Output\n  }],\n  onMenuClose: [{\n    type: Output\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatMenuTrigger, [{\n    type: Directive,\n    args: [{\n      selector: \"[mat-menu-trigger-for], [matMenuTriggerFor]\",\n      host: {\n        'aria-haspopup': 'true',\n        '[attr.aria-expanded]': 'menuOpen || null',\n        '(mousedown)': '_handleMousedown($event)',\n        '(touchstart)': '_openedBy = \"touch\"',\n        '(keydown)': '_handleKeydown($event)',\n        '(click)': '_handleClick($event)'\n      },\n      exportAs: 'matMenuTrigger'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc4.Overlay\n    }, {\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc0.ViewContainerRef\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [MAT_MENU_SCROLL_STRATEGY]\n      }]\n    }, {\n      type: MatMenu,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: MatMenuItem,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Self\n      }]\n    }, {\n      type: ɵngcc5.Directionality,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: ɵngcc1.FocusMonitor\n    }];\n  }, {\n    menuOpened: [{\n      type: Output\n    }],\n    onMenuOpen: [{\n      type: Output\n    }],\n    menuClosed: [{\n      type: Output\n    }],\n    onMenuClose: [{\n      type: Output\n    }],\n    _deprecatedMatMenuTriggerFor: [{\n      type: Input,\n      args: ['mat-menu-trigger-for']\n    }],\n    menu: [{\n      type: Input,\n      args: ['matMenuTriggerFor']\n    }],\n    menuData: [{\n      type: Input,\n      args: ['matMenuTriggerData']\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nvar MatMenuModule = function MatMenuModule() {\n  _classCallCheck(this, MatMenuModule);\n};\n\nMatMenuModule.ɵfac = function MatMenuModule_Factory(t) {\n  return new (t || MatMenuModule)();\n};\n\nMatMenuModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: MatMenuModule\n});\nMatMenuModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n  providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER],\n  imports: [[CommonModule, MatCommonModule, MatRippleModule, OverlayModule], MatCommonModule]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatMenuModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule, MatCommonModule, MatRippleModule, OverlayModule],\n      exports: [MatMenu, MatMenuItem, MatMenuTrigger, MatMenuContent, MatCommonModule],\n      declarations: [MatMenu, MatMenuItem, MatMenuTrigger, MatMenuContent],\n      providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER]\n    }]\n  }], null, null);\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatMenuModule, {\n    declarations: function declarations() {\n      return [MatMenu, MatMenuItem, MatMenuTrigger, MatMenuContent];\n    },\n    imports: function imports() {\n      return [CommonModule, MatCommonModule, MatRippleModule, OverlayModule];\n    },\n    exports: function exports() {\n      return [MatMenu, MatMenuItem, MatMenuTrigger, MatMenuContent, MatCommonModule];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nexport { MAT_MENU_SCROLL_STRATEGY, MatMenuModule, MatMenu, MAT_MENU_DEFAULT_OPTIONS, MatMenuItem, MatMenuTrigger, matMenuAnimations, fadeInItems, transformMenu, MatMenuContent, MAT_MENU_DEFAULT_OPTIONS_FACTORY as ɵa19, MatMenuItemBase as ɵb19, _MatMenuItemMixinBase as ɵc19, MAT_MENU_PANEL as ɵf19, MAT_MENU_SCROLL_STRATEGY_FACTORY as ɵd19, MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER as ɵe19 }; //# sourceMappingURL=menu.js.map","map":{"version":3,"sources":["/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@angular/material/__ivy_ngcc__/esm2015/menu.js"],"names":["Directive","TemplateRef","ComponentFactoryResolver","ApplicationRef","Injector","ViewContainerRef","Inject","InjectionToken","ChangeDetectionStrategy","Component","ElementRef","ViewEncapsulation","Optional","ContentChild","ContentChildren","EventEmitter","Input","NgZone","Output","ViewChild","Self","NgModule","TemplatePortal","DomPortalOutlet","DOCUMENT","CommonModule","Subject","merge","Subscription","asapScheduler","of","trigger","state","style","animate","transition","query","group","FocusMonitor","FocusKeyManager","isFakeMousedownFromScreenReader","mixinDisabled","mixinDisableRipple","MatCommonModule","MatRippleModule","coerceBooleanProperty","ESCAPE","LEFT_ARROW","RIGHT_ARROW","DOWN_ARROW","UP_ARROW","startWith","switchMap","take","delay","filter","takeUntil","Directionality","Overlay","OverlayConfig","OverlayModule","ɵngcc0","ɵngcc1","ɵngcc2","ɵngcc3","ɵngcc4","ɵngcc5","_c0","_c1","MatMenu_ng_template_0_Template","rf","ctx","_r2","ɵɵgetCurrentView","ɵɵelementStart","ɵɵlistener","MatMenu_ng_template_0_Template_div_keydown_0_listener","$event","ɵɵrestoreView","ctx_r1","ɵɵnextContext","_handleKeydown","MatMenu_ng_template_0_Template_div_click_0_listener","ctx_r3","closed","emit","MatMenu_ng_template_0_Template_div_animation_transformMenu_start_0_listener","ctx_r4","_isAnimating","MatMenu_ng_template_0_Template_div_animation_transformMenu_done_0_listener","ctx_r5","_onAnimationDone","ɵɵprojection","ɵɵelementEnd","ctx_r0","ɵɵproperty","_classList","_panelAnimationState","MatMenuContent","_template","_componentFactoryResolver","_appRef","_injector","_viewContainerRef","_document","_attached","context","_portal","detach","_outlet","createElement","element","elementRef","nativeElement","parentNode","insertBefore","outletElement","attach","next","isAttached","dispose","ɵfac","MatMenuContent_Factory","t","ɵɵdirectiveInject","ɵdir","ɵɵdefineDirective","type","selectors","ctorParameters","undefined","decorators","args","ngDevMode","ɵsetClassMetadata","selector","matMenuAnimations","transformMenu","opacity","transform","fadeInItems","throwMatMenuMissingError","Error","throwMatMenuInvalidPositionX","throwMatMenuInvalidPositionY","MAT_MENU_PANEL","MatMenuItemBase","_MatMenuItemMixinBase","MatMenuItem","_elementRef","document","_focusMonitor","_parentMenu","_hovered","_highlighted","_triggersSubmenu","monitor","addItem","origin","focusVia","_getHostElement","focus","stopMonitoring","removeItem","complete","disabled","event","preventDefault","stopPropagation","textNodeType","TEXT_NODE","output","childNodes","length","i","nodeType","textContent","trim","MatMenuItem_Factory","ɵcmp","ɵɵdefineComponent","hostAttrs","hostVars","hostBindings","MatMenuItem_HostBindings","MatMenuItem_click_HostBindingHandler","_checkDisabled","MatMenuItem_mouseenter_HostBindingHandler","_handleMouseEnter","ɵɵattribute","_getTabIndex","toString","ɵɵclassProp","inputs","disableRipple","exportAs","features","ɵɵInheritDefinitionFeature","attrs","ngContentSelectors","decls","vars","consts","template","MatMenuItem_Template","ɵɵprojectionDef","ɵɵelement","ɵɵadvance","directives","MatRipple","encapsulation","changeDetection","host","OnPush","None","MAT_MENU_DEFAULT_OPTIONS","providedIn","factory","MAT_MENU_DEFAULT_OPTIONS_FACTORY","overlapTrigger","xPosition","yPosition","backdropClass","MAT_MENU_BASE_ELEVATION","MatMenu","_ngZone","_defaultOptions","_xPosition","_yPosition","_items","_itemChanges","_tabSubscription","EMPTY","_animationDone","_overlapTrigger","_hasBackdrop","hasBackdrop","close","value","setPositionClasses","classes","split","reduce","obj","className","panelClass","_keyManager","withWrap","withTypeAhead","tabOut","subscribe","unsubscribe","pipe","items","map","item","keyCode","parentMenu","direction","setFocusOrigin","onKeydown","lazyContent","onStable","asObservable","setFirstItemActive","setActiveItem","depth","newElevation","customElevation","Object","keys","find","c","startsWith","_previousElevation","indexOf","push","index","splice","posX","posY","toState","activeItemIndex","scrollTop","MatMenu_Factory","contentQueries","MatMenu_ContentQueries","dirIndex","ɵɵcontentQuery","_t","ɵɵqueryRefresh","ɵɵloadQuery","first","viewQuery","MatMenu_Query","ɵɵviewQuery","templateRef","classList","outputs","ɵɵProvidersFeature","provide","useExisting","MatMenu_Template","ɵɵtemplate","NgClass","styles","data","animation","propDecorators","animations","providers","MAT_MENU_SCROLL_STRATEGY","MAT_MENU_SCROLL_STRATEGY_FACTORY","overlay","scrollStrategies","reposition","MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER","deps","useFactory","MENU_PANEL_TOP_PADDING","MatMenuTrigger","_overlay","_element","scrollStrategy","_menuItemInstance","_dir","_overlayRef","_menuOpen","_closeSubscription","_hoverSubscription","_openedBy","menuOpened","onMenuOpen","menuClosed","onMenuClose","triggersSubmenu","_scrollStrategy","menu","v","_checkMenu","reason","_destroyMenu","_handleHover","_cleanUpSubscriptions","closeMenu","openMenu","overlayRef","_createOverlay","_setPosition","getConfig","positionStrategy","menuData","_menuClosingActions","_initMenu","_startAnimation","menuOpen","_resetAnimation","_resetMenu","dir","_setMenuElevation","_setIsMenuOpen","focusFirstItem","setElevation","isOpen","config","_getOverlayConfig","_subscribeToPositions","create","keydownEvents","position","flexibleConnectedTo","withLockedPosition","withTransformOriginOn","positionChanges","change","connectionPair","overlayX","overlayY","originX","originFallbackX","overlayFallbackY","originY","originFallbackY","overlayFallbackX","offsetY","withPositions","backdrop","backdropClick","detachments","parentClose","hover","active","button","toggleMenu","MatMenuTrigger_Factory","MatMenuTrigger_HostBindings","MatMenuTrigger_mousedown_HostBindingHandler","_handleMousedown","MatMenuTrigger_touchstart_HostBindingHandler","MatMenuTrigger_keydown_HostBindingHandler","MatMenuTrigger_click_HostBindingHandler","_handleClick","_deprecatedMatMenuTriggerFor","MatMenuModule","MatMenuModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","imports","exports","declarations","ngJitMode","ɵɵsetNgModuleScope","ɵa19","ɵb19","ɵc19","ɵf19","ɵd19","ɵe19"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, TemplateRef, ComponentFactoryResolver, ApplicationRef, Injector, ViewContainerRef, Inject, InjectionToken, ChangeDetectionStrategy, Component, ElementRef, ViewEncapsulation, Optional, ContentChild, ContentChildren, EventEmitter, Input, NgZone, Output, ViewChild, Self, NgModule } from '@angular/core';\nimport { TemplatePortal, DomPortalOutlet } from '@angular/cdk/portal';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { Subject, merge, Subscription, asapScheduler, of } from 'rxjs';\nimport { trigger, state, style, animate, transition, query, group } from '@angular/animations';\nimport { FocusMonitor, FocusKeyManager, isFakeMousedownFromScreenReader } from '@angular/cdk/a11y';\nimport { mixinDisabled, mixinDisableRipple, MatCommonModule, MatRippleModule } from '@angular/material/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ESCAPE, LEFT_ARROW, RIGHT_ARROW, DOWN_ARROW, UP_ARROW } from '@angular/cdk/keycodes';\nimport { startWith, switchMap, take, delay, filter, takeUntil } from 'rxjs/operators';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Menu content that will be rendered lazily once the menu is opened.\n */\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/a11y';\nimport * as ɵngcc2 from '@angular/material/core';\nimport * as ɵngcc3 from '@angular/common';\nimport * as ɵngcc4 from '@angular/cdk/overlay';\nimport * as ɵngcc5 from '@angular/cdk/bidi';\n\nconst _c0 = [\"mat-menu-item\", \"\"];\nconst _c1 = [\"*\"];\nfunction MatMenu_ng_template_0_Template(rf, ctx) { if (rf & 1) {\n    const _r2 = ɵngcc0.ɵɵgetCurrentView();\n    ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n    ɵngcc0.ɵɵlistener(\"keydown\", function MatMenu_ng_template_0_Template_div_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1._handleKeydown($event); })(\"click\", function MatMenu_ng_template_0_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.closed.emit(\"click\"); })(\"@transformMenu.start\", function MatMenu_ng_template_0_Template_div_animation_transformMenu_start_0_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4._isAnimating = true; })(\"@transformMenu.done\", function MatMenu_ng_template_0_Template_div_animation_transformMenu_done_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5._onAnimationDone($event); });\n    ɵngcc0.ɵɵelementStart(1, \"div\", 1);\n    ɵngcc0.ɵɵprojection(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n} if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngClass\", ctx_r0._classList)(\"@transformMenu\", ctx_r0._panelAnimationState);\n} }\nclass MatMenuContent {\n    /**\n     * @param {?} _template\n     * @param {?} _componentFactoryResolver\n     * @param {?} _appRef\n     * @param {?} _injector\n     * @param {?} _viewContainerRef\n     * @param {?} _document\n     */\n    constructor(_template, _componentFactoryResolver, _appRef, _injector, _viewContainerRef, _document) {\n        this._template = _template;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._appRef = _appRef;\n        this._injector = _injector;\n        this._viewContainerRef = _viewContainerRef;\n        this._document = _document;\n        /**\n         * Emits when the menu content has been attached.\n         */\n        this._attached = new Subject();\n    }\n    /**\n     * Attaches the content with a particular context.\n     * \\@docs-private\n     * @param {?=} context\n     * @return {?}\n     */\n    attach(context = {}) {\n        if (!this._portal) {\n            this._portal = new TemplatePortal(this._template, this._viewContainerRef);\n        }\n        this.detach();\n        if (!this._outlet) {\n            this._outlet = new DomPortalOutlet(this._document.createElement('div'), this._componentFactoryResolver, this._appRef, this._injector);\n        }\n        /** @type {?} */\n        const element = this._template.elementRef.nativeElement; /** @type {?} */\n        ((\n        // Because we support opening the same menu from different triggers (which in turn have their\n        // own `OverlayRef` panel), we have to re-insert the host element every time, otherwise we\n        // risk it staying attached to a pane that's no longer in the DOM.\n        element.parentNode)).insertBefore(this._outlet.outletElement, element);\n        this._portal.attach(this._outlet, context);\n        this._attached.next();\n    }\n    /**\n     * Detaches the content.\n     * \\@docs-private\n     * @return {?}\n     */\n    detach() {\n        if (this._portal.isAttached) {\n            this._portal.detach();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this._outlet) {\n            this._outlet.dispose();\n        }\n    }\n}\nMatMenuContent.ɵfac = function MatMenuContent_Factory(t) { return new (t || MatMenuContent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ApplicationRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT)); };\nMatMenuContent.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MatMenuContent, selectors: [[\"ng-template\", \"matMenuContent\", \"\"]] });\n/** @nocollapse */\nMatMenuContent.ctorParameters = () => [\n    { type: TemplateRef },\n    { type: ComponentFactoryResolver },\n    { type: ApplicationRef },\n    { type: Injector },\n    { type: ViewContainerRef },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatMenuContent, [{\n        type: Directive,\n        args: [{\n                selector: 'ng-template[matMenuContent]'\n            }]\n    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.ApplicationRef }, { type: ɵngcc0.Injector }, { type: ɵngcc0.ViewContainerRef }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }]; }, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * Animations used by the mat-menu component.\n * Animation duration and timing values are based on:\n * https://material.io/guidelines/components/menus.html#menus-usage\n * \\@docs-private\n  @type {?} */\nconst matMenuAnimations = {\n    /**\n       * This animation controls the menu panel's entry and exit from the page.\n       *\n       * When the menu panel is added to the DOM, it scales in and fades in its border.\n       *\n       * When the menu panel is removed from the DOM, it simply fades out after a brief\n       * delay to display the ripple.\n       */\n    transformMenu: trigger('transformMenu', [\n        state('void', style({\n            opacity: 0,\n            transform: 'scale(0.8)'\n        })),\n        transition('void => enter', group([\n            query('.mat-menu-content', animate('100ms linear', style({ opacity: 1 }))),\n            animate('120ms cubic-bezier(0, 0, 0.2, 1)', style({ transform: 'scale(1)' })),\n        ])),\n        transition('* => void', animate('100ms 25ms linear', style({ opacity: 0 })))\n    ]),\n    /**\n       * This animation fades in the background color and content of the menu panel\n       * after its containing element is scaled in.\n       */\n    fadeInItems: trigger('fadeInItems', [\n        // TODO(crisbeto): this is inside the `transformMenu`\n        // now. Remove next time we do breaking changes.\n        state('showing', style({ opacity: 1 })),\n        transition('void => *', [\n            style({ opacity: 0 }),\n            animate('400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)')\n        ])\n    ])\n};\n/** *\n * @deprecated\n * \\@breaking-change 8.0.0\n * \\@docs-private\n  @type {?} */\nconst fadeInItems = matMenuAnimations.fadeInItems;\n/** *\n * @deprecated\n * \\@breaking-change 8.0.0\n * \\@docs-private\n  @type {?} */\nconst transformMenu = matMenuAnimations.transformMenu;\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * Throws an exception for the case when menu trigger doesn't have a valid mat-menu instance\n * \\@docs-private\n * @return {?}\n */\nfunction throwMatMenuMissingError() {\n    throw Error(`matMenuTriggerFor: must pass in an mat-menu instance.\n\n    Example:\n      <mat-menu #menu=\"matMenu\"></mat-menu>\n      <button [matMenuTriggerFor]=\"menu\"></button>`);\n}\n/**\n * Throws an exception for the case when menu's x-position value isn't valid.\n * In other words, it doesn't match 'before' or 'after'.\n * \\@docs-private\n * @return {?}\n */\nfunction throwMatMenuInvalidPositionX() {\n    throw Error(`xPosition value must be either 'before' or after'.\n      Example: <mat-menu xPosition=\"before\" #menu=\"matMenu\"></mat-menu>`);\n}\n/**\n * Throws an exception for the case when menu's y-position value isn't valid.\n * In other words, it doesn't match 'above' or 'below'.\n * \\@docs-private\n * @return {?}\n */\nfunction throwMatMenuInvalidPositionY() {\n    throw Error(`yPosition value must be either 'above' or below'.\n      Example: <mat-menu yPosition=\"above\" #menu=\"matMenu\"></mat-menu>`);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * Injection token used to provide the parent menu to menu-specific components.\n * \\@docs-private\n  @type {?} */\nconst MAT_MENU_PANEL = new InjectionToken('MAT_MENU_PANEL');\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * \\@docs-private\n */\nclass MatMenuItemBase {\n}\n/** @type {?} */\nconst _MatMenuItemMixinBase = mixinDisableRipple(mixinDisabled(MatMenuItemBase));\n/**\n * This directive is intended to be used inside an mat-menu tag.\n * It exists mostly to set the role attribute.\n */\nclass MatMenuItem extends _MatMenuItemMixinBase {\n    /**\n     * @param {?} _elementRef\n     * @param {?=} document\n     * @param {?=} _focusMonitor\n     * @param {?=} _parentMenu\n     */\n    constructor(_elementRef, document, _focusMonitor, _parentMenu) {\n        // @breaking-change 8.0.0 make `_focusMonitor` and `document` required params.\n        super();\n        this._elementRef = _elementRef;\n        this._focusMonitor = _focusMonitor;\n        this._parentMenu = _parentMenu;\n        /**\n         * Stream that emits when the menu item is hovered.\n         */\n        this._hovered = new Subject();\n        /**\n         * Whether the menu item is highlighted.\n         */\n        this._highlighted = false;\n        /**\n         * Whether the menu item acts as a trigger for a sub-menu.\n         */\n        this._triggersSubmenu = false;\n        if (_focusMonitor) {\n            // Start monitoring the element so it gets the appropriate focused classes. We want\n            // to show the focus style for menu items only when the focus was not caused by a\n            // mouse or touch interaction.\n            _focusMonitor.monitor(this._elementRef, false);\n        }\n        if (_parentMenu && _parentMenu.addItem) {\n            _parentMenu.addItem(this);\n        }\n        this._document = document;\n    }\n    /**\n     * Focuses the menu item.\n     * @param {?=} origin\n     * @return {?}\n     */\n    focus(origin = 'program') {\n        if (this._focusMonitor) {\n            this._focusMonitor.focusVia(this._getHostElement(), origin);\n        }\n        else {\n            this._getHostElement().focus();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this._focusMonitor) {\n            this._focusMonitor.stopMonitoring(this._elementRef);\n        }\n        if (this._parentMenu && this._parentMenu.removeItem) {\n            this._parentMenu.removeItem(this);\n        }\n        this._hovered.complete();\n    }\n    /**\n     * Used to set the `tabindex`.\n     * @return {?}\n     */\n    _getTabIndex() {\n        return this.disabled ? '-1' : '0';\n    }\n    /**\n     * Returns the host DOM element.\n     * @return {?}\n     */\n    _getHostElement() {\n        return this._elementRef.nativeElement;\n    }\n    /**\n     * Prevents the default element actions if it is disabled.\n     * @param {?} event\n     * @return {?}\n     */\n    _checkDisabled(event) {\n        if (this.disabled) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n    }\n    /**\n     * Emits to the hover stream.\n     * @return {?}\n     */\n    _handleMouseEnter() {\n        this._hovered.next(this);\n    }\n    /**\n     * Gets the label to be used when determining whether the option should be focused.\n     * @return {?}\n     */\n    getLabel() {\n        /** @type {?} */\n        const element = this._elementRef.nativeElement;\n        /** @type {?} */\n        const textNodeType = this._document ? this._document.TEXT_NODE : 3;\n        /** @type {?} */\n        let output = '';\n        if (element.childNodes) {\n            /** @type {?} */\n            const length = element.childNodes.length;\n            // Go through all the top-level text nodes and extract their text.\n            // We skip anything that's not a text node to prevent the text from\n            // being thrown off by something like an icon.\n            for (let i = 0; i < length; i++) {\n                if (element.childNodes[i].nodeType === textNodeType) {\n                    output += element.childNodes[i].textContent;\n                }\n            }\n        }\n        return output.trim();\n    }\n}\nMatMenuItem.ɵfac = function MatMenuItem_Factory(t) { return new (t || MatMenuItem)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.FocusMonitor), ɵngcc0.ɵɵdirectiveInject(MAT_MENU_PANEL, 8)); };\nMatMenuItem.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MatMenuItem, selectors: [[\"\", \"mat-menu-item\", \"\"]], hostAttrs: [\"role\", \"menuitem\", 1, \"mat-menu-item\"], hostVars: 7, hostBindings: function MatMenuItem_HostBindings(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function MatMenuItem_click_HostBindingHandler($event) { return ctx._checkDisabled($event); })(\"mouseenter\", function MatMenuItem_mouseenter_HostBindingHandler() { return ctx._handleMouseEnter(); });\n    } if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"tabindex\", ctx._getTabIndex())(\"aria-disabled\", ctx.disabled.toString())(\"disabled\", ctx.disabled || null);\n        ɵngcc0.ɵɵclassProp(\"mat-menu-item-highlighted\", ctx._highlighted)(\"mat-menu-item-submenu-trigger\", ctx._triggersSubmenu);\n    } }, inputs: { disabled: \"disabled\", disableRipple: \"disableRipple\" }, exportAs: [\"matMenuItem\"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], attrs: _c0, ngContentSelectors: _c1, decls: 2, vars: 2, consts: [[\"matRipple\", \"\", 1, \"mat-menu-ripple\", 3, \"matRippleDisabled\", \"matRippleTrigger\"]], template: function MatMenuItem_Template(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n        ɵngcc0.ɵɵelement(1, \"div\", 0);\n    } if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"matRippleDisabled\", ctx.disableRipple || ctx.disabled)(\"matRippleTrigger\", ctx._getHostElement());\n    } }, directives: [ɵngcc2.MatRipple], encapsulation: 2, changeDetection: 0 });\n/** @nocollapse */\nMatMenuItem.ctorParameters = () => [\n    { type: ElementRef },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: FocusMonitor },\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_PANEL,] }, { type: Optional }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatMenuItem, [{\n        type: Component,\n        args: [{ selector: '[mat-menu-item]',\n                exportAs: 'matMenuItem',\n                inputs: ['disabled', 'disableRipple'],\n                host: {\n                    'role': 'menuitem',\n                    'class': 'mat-menu-item',\n                    '[class.mat-menu-item-highlighted]': '_highlighted',\n                    '[class.mat-menu-item-submenu-trigger]': '_triggersSubmenu',\n                    '[attr.tabindex]': '_getTabIndex()',\n                    '[attr.aria-disabled]': 'disabled.toString()',\n                    '[attr.disabled]': 'disabled || null',\n                    '(click)': '_checkDisabled($event)',\n                    '(mouseenter)': '_handleMouseEnter()'\n                },\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                encapsulation: ViewEncapsulation.None,\n                template: \"<ng-content></ng-content><div class=\\\"mat-menu-ripple\\\" matRipple [matRippleDisabled]=\\\"disableRipple || disabled\\\" [matRippleTrigger]=\\\"_getHostElement()\\\"></div>\" }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }, { type: ɵngcc1.FocusMonitor }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [MAT_MENU_PANEL]\n            }, {\n                type: Optional\n            }] }]; }, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * Injection token to be used to override the default options for `mat-menu`.\n  @type {?} */\nconst MAT_MENU_DEFAULT_OPTIONS = new InjectionToken('mat-menu-default-options', {\n    providedIn: 'root',\n    factory: MAT_MENU_DEFAULT_OPTIONS_FACTORY\n});\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction MAT_MENU_DEFAULT_OPTIONS_FACTORY() {\n    return {\n        overlapTrigger: false,\n        xPosition: 'after',\n        yPosition: 'below',\n        backdropClass: 'cdk-overlay-transparent-backdrop',\n    };\n}\n/** *\n * Start elevation for the menu panel.\n * \\@docs-private\n  @type {?} */\nconst MAT_MENU_BASE_ELEVATION = 4;\nclass MatMenu {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _ngZone\n     * @param {?} _defaultOptions\n     */\n    constructor(_elementRef, _ngZone, _defaultOptions) {\n        this._elementRef = _elementRef;\n        this._ngZone = _ngZone;\n        this._defaultOptions = _defaultOptions;\n        this._xPosition = this._defaultOptions.xPosition;\n        this._yPosition = this._defaultOptions.yPosition;\n        /**\n         * Menu items inside the current menu.\n         */\n        this._items = [];\n        /**\n         * Emits whenever the amount of menu items changes.\n         */\n        this._itemChanges = new Subject();\n        /**\n         * Subscription to tab events on the menu panel\n         */\n        this._tabSubscription = Subscription.EMPTY;\n        /**\n         * Config object to be passed into the menu's ngClass\n         */\n        this._classList = {};\n        /**\n         * Current state of the panel animation.\n         */\n        this._panelAnimationState = 'void';\n        /**\n         * Emits whenever an animation on the menu completes.\n         */\n        this._animationDone = new Subject();\n        /**\n         * Class to be added to the backdrop element.\n         */\n        this.backdropClass = this._defaultOptions.backdropClass;\n        this._overlapTrigger = this._defaultOptions.overlapTrigger;\n        this._hasBackdrop = this._defaultOptions.hasBackdrop;\n        /**\n         * Event emitted when the menu is closed.\n         */\n        this.closed = new EventEmitter();\n        /**\n         * Event emitted when the menu is closed.\n         * @deprecated Switch to `closed` instead\n         * \\@breaking-change 8.0.0\n         */\n        this.close = this.closed;\n    }\n    /**\n     * Position of the menu in the X axis.\n     * @return {?}\n     */\n    get xPosition() { return this._xPosition; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set xPosition(value) {\n        if (value !== 'before' && value !== 'after') {\n            throwMatMenuInvalidPositionX();\n        }\n        this._xPosition = value;\n        this.setPositionClasses();\n    }\n    /**\n     * Position of the menu in the Y axis.\n     * @return {?}\n     */\n    get yPosition() { return this._yPosition; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set yPosition(value) {\n        if (value !== 'above' && value !== 'below') {\n            throwMatMenuInvalidPositionY();\n        }\n        this._yPosition = value;\n        this.setPositionClasses();\n    }\n    /**\n     * Whether the menu should overlap its trigger.\n     * @return {?}\n     */\n    get overlapTrigger() { return this._overlapTrigger; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set overlapTrigger(value) {\n        this._overlapTrigger = coerceBooleanProperty(value);\n    }\n    /**\n     * Whether the menu has a backdrop.\n     * @return {?}\n     */\n    get hasBackdrop() { return this._hasBackdrop; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set hasBackdrop(value) {\n        this._hasBackdrop = coerceBooleanProperty(value);\n    }\n    /**\n     * This method takes classes set on the host mat-menu element and applies them on the\n     * menu template that displays in the overlay container.  Otherwise, it's difficult\n     * to style the containing menu from outside the component.\n     * @param {?} classes list of class names\n     * @return {?}\n     */\n    set panelClass(classes) {\n        if (classes && classes.length) {\n            this._classList = classes.split(' ').reduce((obj, className) => {\n                obj[className] = true;\n                return obj;\n            }, {});\n            this._elementRef.nativeElement.className = '';\n        }\n    }\n    /**\n     * This method takes classes set on the host mat-menu element and applies them on the\n     * menu template that displays in the overlay container.  Otherwise, it's difficult\n     * to style the containing menu from outside the component.\n     * @deprecated Use `panelClass` instead.\n     * \\@breaking-change 8.0.0\n     * @return {?}\n     */\n    get classList() { return this.panelClass; }\n    /**\n     * @param {?} classes\n     * @return {?}\n     */\n    set classList(classes) { this.panelClass = classes; }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        this.setPositionClasses();\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        this._keyManager = new FocusKeyManager(this._items).withWrap().withTypeAhead();\n        this._tabSubscription = this._keyManager.tabOut.subscribe(() => this.closed.emit('tab'));\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._tabSubscription.unsubscribe();\n        this.closed.complete();\n    }\n    /**\n     * Stream that emits whenever the hovered menu item changes.\n     * @return {?}\n     */\n    _hovered() {\n        return this._itemChanges.pipe(startWith(this._items), switchMap(items => merge(...items.map(item => item._hovered))));\n    }\n    /**\n     * Handle a keyboard event from the menu, delegating to the appropriate action.\n     * @param {?} event\n     * @return {?}\n     */\n    _handleKeydown(event) {\n        /** @type {?} */\n        const keyCode = event.keyCode;\n        switch (keyCode) {\n            case ESCAPE:\n                this.closed.emit('keydown');\n                break;\n            case LEFT_ARROW:\n                if (this.parentMenu && this.direction === 'ltr') {\n                    this.closed.emit('keydown');\n                }\n                break;\n            case RIGHT_ARROW:\n                if (this.parentMenu && this.direction === 'rtl') {\n                    this.closed.emit('keydown');\n                }\n                break;\n            default:\n                if (keyCode === UP_ARROW || keyCode === DOWN_ARROW) {\n                    this._keyManager.setFocusOrigin('keyboard');\n                }\n                this._keyManager.onKeydown(event);\n        }\n    }\n    /**\n     * Focus the first item in the menu.\n     * @param {?=} origin Action from which the focus originated. Used to set the correct styling.\n     * @return {?}\n     */\n    focusFirstItem(origin = 'program') {\n        // When the content is rendered lazily, it takes a bit before the items are inside the DOM.\n        if (this.lazyContent) {\n            this._ngZone.onStable.asObservable()\n                .pipe(take(1))\n                .subscribe(() => this._keyManager.setFocusOrigin(origin).setFirstItemActive());\n        }\n        else {\n            this._keyManager.setFocusOrigin(origin).setFirstItemActive();\n        }\n    }\n    /**\n     * Resets the active item in the menu. This is used when the menu is opened, allowing\n     * the user to start from the first option when pressing the down arrow.\n     * @return {?}\n     */\n    resetActiveItem() {\n        this._keyManager.setActiveItem(-1);\n    }\n    /**\n     * Sets the menu panel elevation.\n     * @param {?} depth Number of parent menus that come before the menu.\n     * @return {?}\n     */\n    setElevation(depth) {\n        /** @type {?} */\n        const newElevation = `mat-elevation-z${MAT_MENU_BASE_ELEVATION + depth}`;\n        /** @type {?} */\n        const customElevation = Object.keys(this._classList).find(c => c.startsWith('mat-elevation-z'));\n        if (!customElevation || customElevation === this._previousElevation) {\n            if (this._previousElevation) {\n                this._classList[this._previousElevation] = false;\n            }\n            this._classList[newElevation] = true;\n            this._previousElevation = newElevation;\n        }\n    }\n    /**\n     * Registers a menu item with the menu.\n     * \\@docs-private\n     * @param {?} item\n     * @return {?}\n     */\n    addItem(item) {\n        // We register the items through this method, rather than picking them up through\n        // `ContentChildren`, because we need the items to be picked up by their closest\n        // `mat-menu` ancestor. If we used `@ContentChildren(MatMenuItem, {descendants: true})`,\n        // all descendant items will bleed into the top-level menu in the case where the consumer\n        // has `mat-menu` instances nested inside each other.\n        if (this._items.indexOf(item) === -1) {\n            this._items.push(item);\n            this._itemChanges.next(this._items);\n        }\n    }\n    /**\n     * Removes an item from the menu.\n     * \\@docs-private\n     * @param {?} item\n     * @return {?}\n     */\n    removeItem(item) {\n        /** @type {?} */\n        const index = this._items.indexOf(item);\n        if (this._items.indexOf(item) > -1) {\n            this._items.splice(index, 1);\n            this._itemChanges.next(this._items);\n        }\n    }\n    /**\n     * Adds classes to the menu panel based on its position. Can be used by\n     * consumers to add specific styling based on the position.\n     * \\@docs-private\n     * @param {?=} posX Position of the menu along the x axis.\n     * @param {?=} posY Position of the menu along the y axis.\n     * @return {?}\n     */\n    setPositionClasses(posX = this.xPosition, posY = this.yPosition) {\n        /** @type {?} */\n        const classes = this._classList;\n        classes['mat-menu-before'] = posX === 'before';\n        classes['mat-menu-after'] = posX === 'after';\n        classes['mat-menu-above'] = posY === 'above';\n        classes['mat-menu-below'] = posY === 'below';\n    }\n    /**\n     * Starts the enter animation.\n     * @return {?}\n     */\n    _startAnimation() {\n        // @breaking-change 8.0.0 Combine with _resetAnimation.\n        this._panelAnimationState = 'enter';\n    }\n    /**\n     * Resets the panel animation to its initial state.\n     * @return {?}\n     */\n    _resetAnimation() {\n        // @breaking-change 8.0.0 Combine with _startAnimation.\n        this._panelAnimationState = 'void';\n    }\n    /**\n     * Callback that is invoked when the panel animation completes.\n     * @param {?} event\n     * @return {?}\n     */\n    _onAnimationDone(event) {\n        this._animationDone.next(event);\n        this._isAnimating = false;\n        // Scroll the content element to the top once the animation is done. This is necessary, because\n        // we move focus to the first item while it's still being animated, which can throw the browser\n        // off when it determines the scroll position. Alternatively we can move focus when the\n        // animation is done, however moving focus asynchronously will interrupt screen readers\n        // which are in the process of reading out the menu already. We take the `element` from\n        // the `event` since we can't use a `ViewChild` to access the pane.\n        if (event.toState === 'enter' && this._keyManager.activeItemIndex === 0) {\n            event.element.scrollTop = 0;\n        }\n    }\n}\nMatMenu.ɵfac = function MatMenu_Factory(t) { return new (t || MatMenu)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MAT_MENU_DEFAULT_OPTIONS)); };\nMatMenu.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MatMenu, selectors: [[\"mat-menu\"]], contentQueries: function MatMenu_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MatMenuContent, 5);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MatMenuItem, 4);\n    } if (rf & 2) {\n        let _t;\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.lazyContent = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.items = _t);\n    } }, viewQuery: function MatMenu_Query(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(TemplateRef, 5);\n    } if (rf & 2) {\n        let _t;\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templateRef = _t.first);\n    } }, inputs: { backdropClass: \"backdropClass\", xPosition: \"xPosition\", yPosition: \"yPosition\", overlapTrigger: \"overlapTrigger\", hasBackdrop: \"hasBackdrop\", panelClass: [\"class\", \"panelClass\"], classList: \"classList\" }, outputs: { closed: \"closed\", close: \"close\" }, exportAs: [\"matMenu\"], features: [ɵngcc0.ɵɵProvidersFeature([\n            { provide: MAT_MENU_PANEL, useExisting: MatMenu }\n        ])], ngContentSelectors: _c1, decls: 1, vars: 0, consts: [[\"tabindex\", \"-1\", \"role\", \"menu\", 1, \"mat-menu-panel\", 3, \"ngClass\", \"keydown\", \"click\"], [1, \"mat-menu-content\"]], template: function MatMenu_Template(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MatMenu_ng_template_0_Template, 3, 2, \"ng-template\");\n    } }, directives: [ɵngcc3.NgClass], styles: [\".mat-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh - 48px);border-radius:4px;outline:0}@media screen and (-ms-high-contrast:active){.mat-menu-panel{outline:solid 1px}}.mat-menu-content:not(:empty){padding-top:8px;padding-bottom:8px}.mat-menu-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative}.mat-menu-item::-moz-focus-inner{border:0}.mat-menu-item[disabled]{cursor:default}[dir=rtl] .mat-menu-item{text-align:right}.mat-menu-item .mat-icon{margin-right:16px;vertical-align:middle}.mat-menu-item .mat-icon svg{vertical-align:top}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px;margin-right:0}@media screen and (-ms-high-contrast:active){.mat-menu-item-highlighted,.mat-menu-item.cdk-keyboard-focused,.mat-menu-item.cdk-program-focused{outline:dotted 1px}}.mat-menu-item-submenu-trigger{padding-right:32px}.mat-menu-item-submenu-trigger::after{width:0;height:0;border-style:solid;border-width:5px 0 5px 5px;border-color:transparent transparent transparent currentColor;content:'';display:inline-block;position:absolute;top:50%;right:16px;transform:translateY(-50%)}[dir=rtl] .mat-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}[dir=rtl] .mat-menu-item-submenu-trigger::after{right:auto;left:16px;transform:rotateY(180deg) translateY(-50%)}.mat-menu-panel.ng-animating .mat-menu-item-submenu-trigger{pointer-events:none}button.mat-menu-item{width:100%}.mat-menu-item .mat-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\"], encapsulation: 2, data: { animation: [\n            matMenuAnimations.transformMenu,\n            matMenuAnimations.fadeInItems\n        ] }, changeDetection: 0 });\n/** @nocollapse */\nMatMenu.ctorParameters = () => [\n    { type: ElementRef },\n    { type: NgZone },\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_DEFAULT_OPTIONS,] }] }\n];\nMatMenu.propDecorators = {\n    backdropClass: [{ type: Input }],\n    xPosition: [{ type: Input }],\n    yPosition: [{ type: Input }],\n    templateRef: [{ type: ViewChild, args: [TemplateRef,] }],\n    items: [{ type: ContentChildren, args: [MatMenuItem,] }],\n    lazyContent: [{ type: ContentChild, args: [MatMenuContent,] }],\n    overlapTrigger: [{ type: Input }],\n    hasBackdrop: [{ type: Input }],\n    panelClass: [{ type: Input, args: ['class',] }],\n    classList: [{ type: Input }],\n    closed: [{ type: Output }],\n    close: [{ type: Output }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatMenu, [{\n        type: Component,\n        args: [{ selector: 'mat-menu',\n                template: \"<ng-template><div class=\\\"mat-menu-panel\\\" [ngClass]=\\\"_classList\\\" (keydown)=\\\"_handleKeydown($event)\\\" (click)=\\\"closed.emit('click')\\\" [@transformMenu]=\\\"_panelAnimationState\\\" (@transformMenu.start)=\\\"_isAnimating = true\\\" (@transformMenu.done)=\\\"_onAnimationDone($event)\\\" tabindex=\\\"-1\\\" role=\\\"menu\\\"><div class=\\\"mat-menu-content\\\"><ng-content></ng-content></div></div></ng-template>\",\n                styles: [\".mat-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh - 48px);border-radius:4px;outline:0}@media screen and (-ms-high-contrast:active){.mat-menu-panel{outline:solid 1px}}.mat-menu-content:not(:empty){padding-top:8px;padding-bottom:8px}.mat-menu-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative}.mat-menu-item::-moz-focus-inner{border:0}.mat-menu-item[disabled]{cursor:default}[dir=rtl] .mat-menu-item{text-align:right}.mat-menu-item .mat-icon{margin-right:16px;vertical-align:middle}.mat-menu-item .mat-icon svg{vertical-align:top}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px;margin-right:0}@media screen and (-ms-high-contrast:active){.mat-menu-item-highlighted,.mat-menu-item.cdk-keyboard-focused,.mat-menu-item.cdk-program-focused{outline:dotted 1px}}.mat-menu-item-submenu-trigger{padding-right:32px}.mat-menu-item-submenu-trigger::after{width:0;height:0;border-style:solid;border-width:5px 0 5px 5px;border-color:transparent transparent transparent currentColor;content:'';display:inline-block;position:absolute;top:50%;right:16px;transform:translateY(-50%)}[dir=rtl] .mat-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}[dir=rtl] .mat-menu-item-submenu-trigger::after{right:auto;left:16px;transform:rotateY(180deg) translateY(-50%)}.mat-menu-panel.ng-animating .mat-menu-item-submenu-trigger{pointer-events:none}button.mat-menu-item{width:100%}.mat-menu-item .mat-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\"],\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                encapsulation: ViewEncapsulation.None,\n                exportAs: 'matMenu',\n                animations: [\n                    matMenuAnimations.transformMenu,\n                    matMenuAnimations.fadeInItems\n                ], providers: [\n                    { provide: MAT_MENU_PANEL, useExisting: MatMenu }\n                ]\n            }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [MAT_MENU_DEFAULT_OPTIONS]\n            }] }]; }, { backdropClass: [{\n            type: Input\n        }], closed: [{\n            type: Output\n        }], close: [{\n            type: Output\n        }], xPosition: [{\n            type: Input\n        }], yPosition: [{\n            type: Input\n        }], overlapTrigger: [{\n            type: Input\n        }], hasBackdrop: [{\n            type: Input\n        }], panelClass: [{\n            type: Input,\n            args: ['class']\n        }], classList: [{\n            type: Input\n        }], templateRef: [{\n            type: ViewChild,\n            args: [TemplateRef]\n        }], items: [{\n            type: ContentChildren,\n            args: [MatMenuItem]\n        }], lazyContent: [{\n            type: ContentChild,\n            args: [MatMenuContent]\n        }] }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * Injection token that determines the scroll handling while the menu is open.\n  @type {?} */\nconst MAT_MENU_SCROLL_STRATEGY = new InjectionToken('mat-menu-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction MAT_MENU_SCROLL_STRATEGY_FACTORY(overlay) {\n    return () => overlay.scrollStrategies.reposition();\n}\n/** *\n * \\@docs-private\n  @type {?} */\nconst MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n    provide: MAT_MENU_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: MAT_MENU_SCROLL_STRATEGY_FACTORY,\n};\n/** *\n * Default top padding of the menu panel.\n  @type {?} */\nconst MENU_PANEL_TOP_PADDING = 8;\n/**\n * This directive is intended to be used in conjunction with an mat-menu tag.  It is\n * responsible for toggling the display of the provided menu instance.\n */\nclass MatMenuTrigger {\n    /**\n     * @param {?} _overlay\n     * @param {?} _element\n     * @param {?} _viewContainerRef\n     * @param {?} scrollStrategy\n     * @param {?} _parentMenu\n     * @param {?} _menuItemInstance\n     * @param {?} _dir\n     * @param {?=} _focusMonitor\n     */\n    constructor(_overlay, _element, _viewContainerRef, scrollStrategy, _parentMenu, _menuItemInstance, _dir, _focusMonitor) {\n        this._overlay = _overlay;\n        this._element = _element;\n        this._viewContainerRef = _viewContainerRef;\n        this._parentMenu = _parentMenu;\n        this._menuItemInstance = _menuItemInstance;\n        this._dir = _dir;\n        this._focusMonitor = _focusMonitor;\n        this._overlayRef = null;\n        this._menuOpen = false;\n        this._closeSubscription = Subscription.EMPTY;\n        this._hoverSubscription = Subscription.EMPTY;\n        // Tracking input type is necessary so it's possible to only auto-focus\n        // the first item of the list when the menu is opened via the keyboard\n        this._openedBy = null;\n        /**\n         * Event emitted when the associated menu is opened.\n         */\n        this.menuOpened = new EventEmitter();\n        /**\n         * Event emitted when the associated menu is opened.\n         * @deprecated Switch to `menuOpened` instead\n         * \\@breaking-change 8.0.0\n         */\n        this.onMenuOpen = this.menuOpened;\n        /**\n         * Event emitted when the associated menu is closed.\n         */\n        this.menuClosed = new EventEmitter();\n        /**\n         * Event emitted when the associated menu is closed.\n         * @deprecated Switch to `menuClosed` instead\n         * \\@breaking-change 8.0.0\n         */\n        this.onMenuClose = this.menuClosed;\n        if (_menuItemInstance) {\n            _menuItemInstance._triggersSubmenu = this.triggersSubmenu();\n        }\n        this._scrollStrategy = scrollStrategy;\n    }\n    /**\n     * @deprecated\n     * \\@breaking-change 8.0.0\n     * @return {?}\n     */\n    get _deprecatedMatMenuTriggerFor() {\n        return this.menu;\n    }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    set _deprecatedMatMenuTriggerFor(v) {\n        this.menu = v;\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        this._checkMenu();\n        this.menu.close.asObservable().subscribe(reason => {\n            this._destroyMenu();\n            // If a click closed the menu, we should close the entire chain of nested menus.\n            if ((reason === 'click' || reason === 'tab') && this._parentMenu) {\n                this._parentMenu.closed.emit(reason);\n            }\n        });\n        this._handleHover();\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this._overlayRef) {\n            this._overlayRef.dispose();\n            this._overlayRef = null;\n        }\n        this._cleanUpSubscriptions();\n    }\n    /**\n     * Whether the menu is open.\n     * @return {?}\n     */\n    get menuOpen() {\n        return this._menuOpen;\n    }\n    /**\n     * The text direction of the containing app.\n     * @return {?}\n     */\n    get dir() {\n        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n    }\n    /**\n     * Whether the menu triggers a sub-menu or a top-level one.\n     * @return {?}\n     */\n    triggersSubmenu() {\n        return !!(this._menuItemInstance && this._parentMenu);\n    }\n    /**\n     * Toggles the menu between the open and closed states.\n     * @return {?}\n     */\n    toggleMenu() {\n        return this._menuOpen ? this.closeMenu() : this.openMenu();\n    }\n    /**\n     * Opens the menu.\n     * @return {?}\n     */\n    openMenu() {\n        if (this._menuOpen) {\n            return;\n        }\n        this._checkMenu();\n        /** @type {?} */\n        const overlayRef = this._createOverlay();\n        this._setPosition(/** @type {?} */ (overlayRef.getConfig().positionStrategy));\n        overlayRef.attach(this._portal);\n        if (this.menu.lazyContent) {\n            this.menu.lazyContent.attach(this.menuData);\n        }\n        this._closeSubscription = this._menuClosingActions().subscribe(() => this.closeMenu());\n        this._initMenu();\n        if (this.menu instanceof MatMenu) {\n            this.menu._startAnimation();\n        }\n    }\n    /**\n     * Closes the menu.\n     * @return {?}\n     */\n    closeMenu() {\n        this.menu.close.emit();\n    }\n    /**\n     * Focuses the menu trigger.\n     * @param {?=} origin Source of the menu trigger's focus.\n     * @return {?}\n     */\n    focus(origin = 'program') {\n        if (this._focusMonitor) {\n            this._focusMonitor.focusVia(this._element, origin);\n        }\n        else {\n            this._element.nativeElement.focus();\n        }\n    }\n    /**\n     * Closes the menu and does the necessary cleanup.\n     * @return {?}\n     */\n    _destroyMenu() {\n        if (!this._overlayRef || !this.menuOpen) {\n            return;\n        }\n        /** @type {?} */\n        const menu = this.menu;\n        this._closeSubscription.unsubscribe();\n        this._overlayRef.detach();\n        if (menu instanceof MatMenu) {\n            menu._resetAnimation();\n            if (menu.lazyContent) {\n                // Wait for the exit animation to finish before detaching the content.\n                menu._animationDone\n                    .pipe(filter(event => event.toState === 'void'), take(1), \n                // Interrupt if the content got re-attached.\n                takeUntil(menu.lazyContent._attached))\n                    .subscribe(() => /** @type {?} */ ((menu.lazyContent)).detach(), undefined, () => {\n                    // No matter whether the content got re-attached, reset the menu.\n                    this._resetMenu();\n                });\n            }\n            else {\n                this._resetMenu();\n            }\n        }\n        else {\n            this._resetMenu();\n            if (menu.lazyContent) {\n                menu.lazyContent.detach();\n            }\n        }\n    }\n    /**\n     * This method sets the menu state to open and focuses the first item if\n     * the menu was opened via the keyboard.\n     * @return {?}\n     */\n    _initMenu() {\n        this.menu.parentMenu = this.triggersSubmenu() ? this._parentMenu : undefined;\n        this.menu.direction = this.dir;\n        this._setMenuElevation();\n        this._setIsMenuOpen(true);\n        this.menu.focusFirstItem(this._openedBy || 'program');\n    }\n    /**\n     * Updates the menu elevation based on the amount of parent menus that it has.\n     * @return {?}\n     */\n    _setMenuElevation() {\n        if (this.menu.setElevation) {\n            /** @type {?} */\n            let depth = 0;\n            /** @type {?} */\n            let parentMenu = this.menu.parentMenu;\n            while (parentMenu) {\n                depth++;\n                parentMenu = parentMenu.parentMenu;\n            }\n            this.menu.setElevation(depth);\n        }\n    }\n    /**\n     * This method resets the menu when it's closed, most importantly restoring\n     * focus to the menu trigger if the menu was opened via the keyboard.\n     * @return {?}\n     */\n    _resetMenu() {\n        this._setIsMenuOpen(false);\n        // We should reset focus if the user is navigating using a keyboard or\n        // if we have a top-level trigger which might cause focus to be lost\n        // when clicking on the backdrop.\n        if (!this._openedBy) {\n            // Note that the focus style will show up both for `program` and\n            // `keyboard` so we don't have to specify which one it is.\n            this.focus();\n        }\n        else if (!this.triggersSubmenu()) {\n            this.focus(this._openedBy);\n        }\n        this._openedBy = null;\n    }\n    /**\n     * @param {?} isOpen\n     * @return {?}\n     */\n    _setIsMenuOpen(isOpen) {\n        this._menuOpen = isOpen;\n        this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit();\n        if (this.triggersSubmenu()) {\n            this._menuItemInstance._highlighted = isOpen;\n        }\n    }\n    /**\n     * This method checks that a valid instance of MatMenu has been passed into\n     * matMenuTriggerFor. If not, an exception is thrown.\n     * @return {?}\n     */\n    _checkMenu() {\n        if (!this.menu) {\n            throwMatMenuMissingError();\n        }\n    }\n    /**\n     * This method creates the overlay from the provided menu's template and saves its\n     * OverlayRef so that it can be attached to the DOM when openMenu is called.\n     * @return {?}\n     */\n    _createOverlay() {\n        if (!this._overlayRef) {\n            this._portal = new TemplatePortal(this.menu.templateRef, this._viewContainerRef);\n            /** @type {?} */\n            const config = this._getOverlayConfig();\n            this._subscribeToPositions(/** @type {?} */ (config.positionStrategy));\n            this._overlayRef = this._overlay.create(config);\n            // Consume the `keydownEvents` in order to prevent them from going to another overlay.\n            // Ideally we'd also have our keyboard event logic in here, however doing so will\n            // break anybody that may have implemented the `MatMenuPanel` themselves.\n            this._overlayRef.keydownEvents().subscribe();\n        }\n        return this._overlayRef;\n    }\n    /**\n     * This method builds the configuration object needed to create the overlay, the OverlayState.\n     * @return {?} OverlayConfig\n     */\n    _getOverlayConfig() {\n        return new OverlayConfig({\n            positionStrategy: this._overlay.position()\n                .flexibleConnectedTo(this._element)\n                .withLockedPosition()\n                .withTransformOriginOn('.mat-menu-panel'),\n            hasBackdrop: this.menu.hasBackdrop == null ? !this.triggersSubmenu() : this.menu.hasBackdrop,\n            backdropClass: this.menu.backdropClass || 'cdk-overlay-transparent-backdrop',\n            scrollStrategy: this._scrollStrategy(),\n            direction: this._dir\n        });\n    }\n    /**\n     * Listens to changes in the position of the overlay and sets the correct classes\n     * on the menu based on the new position. This ensures the animation origin is always\n     * correct, even if a fallback position is used for the overlay.\n     * @param {?} position\n     * @return {?}\n     */\n    _subscribeToPositions(position) {\n        if (this.menu.setPositionClasses) {\n            position.positionChanges.subscribe(change => {\n                /** @type {?} */\n                const posX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';\n                /** @type {?} */\n                const posY = change.connectionPair.overlayY === 'top' ? 'below' : 'above'; /** @type {?} */\n                ((this.menu.setPositionClasses))(posX, posY);\n            });\n        }\n    }\n    /**\n     * Sets the appropriate positions on a position strategy\n     * so the overlay connects with the trigger correctly.\n     * @param {?} positionStrategy Strategy whose position to update.\n     * @return {?}\n     */\n    _setPosition(positionStrategy) {\n        let [originX, originFallbackX] = this.menu.xPosition === 'before' ? ['end', 'start'] : ['start', 'end'];\n        let [overlayY, overlayFallbackY] = this.menu.yPosition === 'above' ? ['bottom', 'top'] : ['top', 'bottom'];\n        let [originY, originFallbackY] = [overlayY, overlayFallbackY];\n        let [overlayX, overlayFallbackX] = [originX, originFallbackX];\n        /** @type {?} */\n        let offsetY = 0;\n        if (this.triggersSubmenu()) {\n            // When the menu is a sub-menu, it should always align itself\n            // to the edges of the trigger, instead of overlapping it.\n            overlayFallbackX = originX = this.menu.xPosition === 'before' ? 'start' : 'end';\n            originFallbackX = overlayX = originX === 'end' ? 'start' : 'end';\n            offsetY = overlayY === 'bottom' ? MENU_PANEL_TOP_PADDING : -MENU_PANEL_TOP_PADDING;\n        }\n        else if (!this.menu.overlapTrigger) {\n            originY = overlayY === 'top' ? 'bottom' : 'top';\n            originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';\n        }\n        positionStrategy.withPositions([\n            { originX, originY, overlayX, overlayY, offsetY },\n            { originX: originFallbackX, originY, overlayX: overlayFallbackX, overlayY, offsetY },\n            {\n                originX,\n                originY: originFallbackY,\n                overlayX,\n                overlayY: overlayFallbackY,\n                offsetY: -offsetY\n            },\n            {\n                originX: originFallbackX,\n                originY: originFallbackY,\n                overlayX: overlayFallbackX,\n                overlayY: overlayFallbackY,\n                offsetY: -offsetY\n            }\n        ]);\n    }\n    /**\n     * Cleans up the active subscriptions.\n     * @return {?}\n     */\n    _cleanUpSubscriptions() {\n        this._closeSubscription.unsubscribe();\n        this._hoverSubscription.unsubscribe();\n    }\n    /**\n     * Returns a stream that emits whenever an action that should close the menu occurs.\n     * @return {?}\n     */\n    _menuClosingActions() {\n        /** @type {?} */\n        const backdrop = /** @type {?} */ ((this._overlayRef)).backdropClick();\n        /** @type {?} */\n        const detachments = /** @type {?} */ ((this._overlayRef)).detachments();\n        /** @type {?} */\n        const parentClose = this._parentMenu ? this._parentMenu.closed : of();\n        /** @type {?} */\n        const hover = this._parentMenu ? this._parentMenu._hovered().pipe(filter(active => active !== this._menuItemInstance), filter(() => this._menuOpen)) : of();\n        return merge(backdrop, parentClose, hover, detachments);\n    }\n    /**\n     * Handles mouse presses on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n    _handleMousedown(event) {\n        if (!isFakeMousedownFromScreenReader(event)) {\n            // Since right or middle button clicks won't trigger the `click` event,\n            // we shouldn't consider the menu as opened by mouse in those cases.\n            this._openedBy = event.button === 0 ? 'mouse' : null;\n            // Since clicking on the trigger won't close the menu if it opens a sub-menu,\n            // we should prevent focus from moving onto it via click to avoid the\n            // highlight from lingering on the menu item.\n            if (this.triggersSubmenu()) {\n                event.preventDefault();\n            }\n        }\n    }\n    /**\n     * Handles key presses on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n    _handleKeydown(event) {\n        /** @type {?} */\n        const keyCode = event.keyCode;\n        if (this.triggersSubmenu() && ((keyCode === RIGHT_ARROW && this.dir === 'ltr') ||\n            (keyCode === LEFT_ARROW && this.dir === 'rtl'))) {\n            this.openMenu();\n        }\n    }\n    /**\n     * Handles click events on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n    _handleClick(event) {\n        if (this.triggersSubmenu()) {\n            // Stop event propagation to avoid closing the parent menu.\n            event.stopPropagation();\n            this.openMenu();\n        }\n        else {\n            this.toggleMenu();\n        }\n    }\n    /**\n     * Handles the cases where the user hovers over the trigger.\n     * @return {?}\n     */\n    _handleHover() {\n        // Subscribe to changes in the hovered item in order to toggle the panel.\n        if (!this.triggersSubmenu()) {\n            return;\n        }\n        this._hoverSubscription = this._parentMenu._hovered()\n            // Since we might have multiple competing triggers for the same menu (e.g. a sub-menu\n            // with different data and triggers), we have to delay it by a tick to ensure that\n            // it won't be closed immediately after it is opened.\n            .pipe(filter(active => active === this._menuItemInstance && !active.disabled), delay(0, asapScheduler))\n            .subscribe(() => {\n            this._openedBy = 'mouse';\n            // If the same menu is used between multiple triggers, it might still be animating\n            // while the new trigger tries to re-open it. Wait for the animation to finish\n            // before doing so. Also interrupt if the user moves to another item.\n            if (this.menu instanceof MatMenu && this.menu._isAnimating) {\n                // We need the `delay(0)` here in order to avoid\n                // 'changed after checked' errors in some cases. See #12194.\n                this.menu._animationDone\n                    .pipe(take(1), delay(0, asapScheduler), takeUntil(this._parentMenu._hovered()))\n                    .subscribe(() => this.openMenu());\n            }\n            else {\n                this.openMenu();\n            }\n        });\n    }\n}\nMatMenuTrigger.ɵfac = function MatMenuTrigger_Factory(t) { return new (t || MatMenuTrigger)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.Overlay), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(MAT_MENU_SCROLL_STRATEGY), ɵngcc0.ɵɵdirectiveInject(MatMenu, 8), ɵngcc0.ɵɵdirectiveInject(MatMenuItem, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc5.Directionality, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.FocusMonitor)); };\nMatMenuTrigger.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MatMenuTrigger, selectors: [[\"\", \"mat-menu-trigger-for\", \"\"], [\"\", \"matMenuTriggerFor\", \"\"]], hostAttrs: [\"aria-haspopup\", \"true\"], hostVars: 1, hostBindings: function MatMenuTrigger_HostBindings(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"mousedown\", function MatMenuTrigger_mousedown_HostBindingHandler($event) { return ctx._handleMousedown($event); })(\"touchstart\", function MatMenuTrigger_touchstart_HostBindingHandler() { return ctx._openedBy = \"touch\"; })(\"keydown\", function MatMenuTrigger_keydown_HostBindingHandler($event) { return ctx._handleKeydown($event); })(\"click\", function MatMenuTrigger_click_HostBindingHandler($event) { return ctx._handleClick($event); });\n    } if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"aria-expanded\", ctx.menuOpen || null);\n    } }, inputs: { _deprecatedMatMenuTriggerFor: [\"mat-menu-trigger-for\", \"_deprecatedMatMenuTriggerFor\"], menu: [\"matMenuTriggerFor\", \"menu\"], menuData: [\"matMenuTriggerData\", \"menuData\"] }, outputs: { menuOpened: \"menuOpened\", onMenuOpen: \"onMenuOpen\", menuClosed: \"menuClosed\", onMenuClose: \"onMenuClose\" }, exportAs: [\"matMenuTrigger\"] });\n/** @nocollapse */\nMatMenuTrigger.ctorParameters = () => [\n    { type: Overlay },\n    { type: ElementRef },\n    { type: ViewContainerRef },\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_SCROLL_STRATEGY,] }] },\n    { type: MatMenu, decorators: [{ type: Optional }] },\n    { type: MatMenuItem, decorators: [{ type: Optional }, { type: Self }] },\n    { type: Directionality, decorators: [{ type: Optional }] },\n    { type: FocusMonitor }\n];\nMatMenuTrigger.propDecorators = {\n    _deprecatedMatMenuTriggerFor: [{ type: Input, args: ['mat-menu-trigger-for',] }],\n    menu: [{ type: Input, args: ['matMenuTriggerFor',] }],\n    menuData: [{ type: Input, args: ['matMenuTriggerData',] }],\n    menuOpened: [{ type: Output }],\n    onMenuOpen: [{ type: Output }],\n    menuClosed: [{ type: Output }],\n    onMenuClose: [{ type: Output }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatMenuTrigger, [{\n        type: Directive,\n        args: [{\n                selector: `[mat-menu-trigger-for], [matMenuTriggerFor]`,\n                host: {\n                    'aria-haspopup': 'true',\n                    '[attr.aria-expanded]': 'menuOpen || null',\n                    '(mousedown)': '_handleMousedown($event)',\n                    '(touchstart)': '_openedBy = \"touch\"',\n                    '(keydown)': '_handleKeydown($event)',\n                    '(click)': '_handleClick($event)'\n                },\n                exportAs: 'matMenuTrigger'\n            }]\n    }], function () { return [{ type: ɵngcc4.Overlay }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ViewContainerRef }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [MAT_MENU_SCROLL_STRATEGY]\n            }] }, { type: MatMenu, decorators: [{\n                type: Optional\n            }] }, { type: MatMenuItem, decorators: [{\n                type: Optional\n            }, {\n                type: Self\n            }] }, { type: ɵngcc5.Directionality, decorators: [{\n                type: Optional\n            }] }, { type: ɵngcc1.FocusMonitor }]; }, { menuOpened: [{\n            type: Output\n        }], onMenuOpen: [{\n            type: Output\n        }], menuClosed: [{\n            type: Output\n        }], onMenuClose: [{\n            type: Output\n        }], _deprecatedMatMenuTriggerFor: [{\n            type: Input,\n            args: ['mat-menu-trigger-for']\n        }], menu: [{\n            type: Input,\n            args: ['matMenuTriggerFor']\n        }], menuData: [{\n            type: Input,\n            args: ['matMenuTriggerData']\n        }] }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nclass MatMenuModule {\n}\nMatMenuModule.ɵfac = function MatMenuModule_Factory(t) { return new (t || MatMenuModule)(); };\nMatMenuModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: MatMenuModule });\nMatMenuModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER], imports: [[\n            CommonModule,\n            MatCommonModule,\n            MatRippleModule,\n            OverlayModule,\n        ], MatCommonModule] });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatMenuModule, [{\n        type: NgModule,\n        args: [{\n                imports: [\n                    CommonModule,\n                    MatCommonModule,\n                    MatRippleModule,\n                    OverlayModule,\n                ],\n                exports: [MatMenu, MatMenuItem, MatMenuTrigger, MatMenuContent, MatCommonModule],\n                declarations: [MatMenu, MatMenuItem, MatMenuTrigger, MatMenuContent],\n                providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatMenuModule, { declarations: function () { return [MatMenu, MatMenuItem, MatMenuTrigger, MatMenuContent]; }, imports: function () { return [CommonModule,\n        MatCommonModule,\n        MatRippleModule,\n        OverlayModule]; }, exports: function () { return [MatMenu, MatMenuItem, MatMenuTrigger, MatMenuContent, MatCommonModule]; } }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\nexport { MAT_MENU_SCROLL_STRATEGY, MatMenuModule, MatMenu, MAT_MENU_DEFAULT_OPTIONS, MatMenuItem, MatMenuTrigger, matMenuAnimations, fadeInItems, transformMenu, MatMenuContent, MAT_MENU_DEFAULT_OPTIONS_FACTORY as ɵa19, MatMenuItemBase as ɵb19, _MatMenuItemMixinBase as ɵc19, MAT_MENU_PANEL as ɵf19, MAT_MENU_SCROLL_STRATEGY_FACTORY as ɵd19, MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER as ɵe19 };\n\n//# sourceMappingURL=menu.js.map"]},"metadata":{},"sourceType":"module"}