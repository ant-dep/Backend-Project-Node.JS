{"ast":null,"code":"import _classCallCheck from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { CdkTextareaAutosize, AutofillMonitor, TextFieldModule } from '@angular/cdk/text-field';\nimport { Directive, Input, InjectionToken, ElementRef, Inject, NgZone, Optional, Self, NgModule } from '@angular/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { getSupportedInputTypes, Platform } from '@angular/cdk/platform';\nimport { FormGroupDirective, NgControl, NgForm } from '@angular/forms';\nimport { ErrorStateMatcher, mixinErrorState } from '@angular/material/core';\nimport { MatFormFieldControl, MatFormFieldModule } from '@angular/material/form-field';\nimport { Subject } from 'rxjs';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/platform';\nimport * as ɵngcc2 from '@angular/forms';\nimport * as ɵngcc3 from '@angular/material/core';\nimport * as ɵngcc4 from '@angular/cdk/text-field';\nvar _CdkTextareaAutosize = CdkTextareaAutosize;\n\nvar MatTextareaAutosize = /*@__PURE__*/function () {\n  var MatTextareaAutosize = /*#__PURE__*/function (_CdkTextareaAutosize2) {\n    _inherits(MatTextareaAutosize, _CdkTextareaAutosize2);\n\n    var _super = _createSuper(MatTextareaAutosize);\n\n    function MatTextareaAutosize() {\n      _classCallCheck(this, MatTextareaAutosize);\n\n      return _super.apply(this, arguments);\n    }\n\n    _createClass(MatTextareaAutosize, [{\n      key: \"matAutosizeMinRows\",\n      get:\n      /**\n       * @return {?}\n       */\n      function get() {\n        return this.minRows;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this.minRows = value;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"matAutosizeMaxRows\",\n      get: function get() {\n        return this.maxRows;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this.maxRows = value;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"matAutosize\",\n      get: function get() {\n        return this.enabled;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this.enabled = value;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"matTextareaAutosize\",\n      get: function get() {\n        return this.enabled;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this.enabled = value;\n      }\n    }]);\n\n    return MatTextareaAutosize;\n  }(_CdkTextareaAutosize);\n\n  MatTextareaAutosize.ɵfac =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  function () {\n    var ɵMatTextareaAutosize_BaseFactory;\n    return function MatTextareaAutosize_Factory(t) {\n      return (ɵMatTextareaAutosize_BaseFactory || (ɵMatTextareaAutosize_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(MatTextareaAutosize)))(t || MatTextareaAutosize);\n    };\n  }();\n\n  MatTextareaAutosize.ɵdir =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineDirective({\n    type: MatTextareaAutosize,\n    selectors: [[\"textarea\", \"mat-autosize\", \"\"], [\"textarea\", \"matTextareaAutosize\", \"\"]],\n    hostAttrs: [\"rows\", \"1\", 1, \"cdk-textarea-autosize\", \"mat-autosize\"],\n    hostBindings: function MatTextareaAutosize_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"input\", function MatTextareaAutosize_input_HostBindingHandler() {\n          return ctx._noopInputHandler();\n        });\n      }\n    },\n    inputs: {\n      cdkAutosizeMinRows: \"cdkAutosizeMinRows\",\n      cdkAutosizeMaxRows: \"cdkAutosizeMaxRows\",\n      matAutosizeMinRows: \"matAutosizeMinRows\",\n      matAutosizeMaxRows: \"matAutosizeMaxRows\",\n      matAutosize: [\"mat-autosize\", \"matAutosize\"],\n      matTextareaAutosize: \"matTextareaAutosize\"\n    },\n    exportAs: [\"matTextareaAutosize\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  return MatTextareaAutosize;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * \\@docs-private\n * @param {?} type\n * @return {?}\n */\n\n\nfunction getMatInputUnsupportedTypeError(type) {\n  return Error(\"Input type \\\"\".concat(type, \"\\\" isn't supported by matInput.\"));\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** *\n * This token is used to inject the object whose value should be set into `MatInput`. If none is\n * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide\n * themselves for this token, in order to make `MatInput` delegate the getting and setting of the\n * value to them.\n  @type {?} */\n\n\nvar MAT_INPUT_VALUE_ACCESSOR = /*@__PURE__*/new InjectionToken('MAT_INPUT_VALUE_ACCESSOR');\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\nvar MAT_INPUT_INVALID_TYPES = ['button', 'checkbox', 'file', 'hidden', 'image', 'radio', 'range', 'reset', 'submit'];\n/** @type {?} */\n\nvar nextUniqueId = 0;\n/**\n * \\@docs-private\n */\n\nvar MatInputBase =\n/**\n * @param {?} _defaultErrorStateMatcher\n * @param {?} _parentForm\n * @param {?} _parentFormGroup\n * @param {?} ngControl\n */\nfunction MatInputBase(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {\n  _classCallCheck(this, MatInputBase);\n\n  this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n  this._parentForm = _parentForm;\n  this._parentFormGroup = _parentFormGroup;\n  this.ngControl = ngControl;\n};\n/** @type {?} */\n\n\nvar _MatInputMixinBase = /*@__PURE__*/mixinErrorState(MatInputBase);\n\nvar MatInput = /*@__PURE__*/function () {\n  var MatInput = /*#__PURE__*/function (_MatInputMixinBase2) {\n    _inherits(MatInput, _MatInputMixinBase2);\n\n    var _super2 = _createSuper(MatInput);\n\n    /**\n     * @param {?} _elementRef\n     * @param {?} _platform\n     * @param {?} ngControl\n     * @param {?} _parentForm\n     * @param {?} _parentFormGroup\n     * @param {?} _defaultErrorStateMatcher\n     * @param {?} inputValueAccessor\n     * @param {?} _autofillMonitor\n     * @param {?} ngZone\n     */\n    function MatInput(_elementRef, _platform,\n    /** @docs-private */\n    ngControl, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, inputValueAccessor, _autofillMonitor, ngZone) {\n      var _this;\n\n      _classCallCheck(this, MatInput);\n\n      _this = _super2.call(this, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n      _this._elementRef = _elementRef;\n      _this._platform = _platform;\n      _this.ngControl = ngControl;\n      _this._autofillMonitor = _autofillMonitor;\n      _this._uid = \"mat-input-\".concat(nextUniqueId++);\n      /**\n       * Whether the component is being rendered on the server.\n       */\n\n      _this._isServer = false;\n      /**\n       * Whether the component is a native html select.\n       */\n\n      _this._isNativeSelect = false;\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * \\@docs-private\n       */\n\n      _this.focused = false;\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * \\@docs-private\n       */\n\n      _this.stateChanges = new Subject();\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * \\@docs-private\n       */\n\n      _this.controlType = 'mat-input';\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * \\@docs-private\n       */\n\n      _this.autofilled = false;\n      _this._disabled = false;\n      _this._required = false;\n      _this._type = 'text';\n      _this._readonly = false;\n      _this._neverEmptyInputTypes = ['date', 'datetime', 'datetime-local', 'month', 'time', 'week'].filter(function (t) {\n        return getSupportedInputTypes().has(t);\n      });\n      /** @type {?} */\n\n      var element = _this._elementRef.nativeElement; // If no input value accessor was explicitly specified, use the element as the input value\n      // accessor.\n\n      _this._inputValueAccessor = inputValueAccessor || element;\n      _this._previousNativeValue = _this.value; // Force setter to be called in case id was not specified.\n\n      _this.id = _this.id; // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n      // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n      // exists on iOS, we only bother to install the listener on iOS.\n\n      if (_platform.IOS) {\n        ngZone.runOutsideAngular(function () {\n          _elementRef.nativeElement.addEventListener('keyup', function (event) {\n            /** @type {?} */\n            var el =\n            /** @type {?} */\n            event.target;\n\n            if (!el.value && !el.selectionStart && !el.selectionEnd) {\n              // Note: Just setting `0, 0` doesn't fix the issue. Setting\n              // `1, 1` fixes it for the first time that you type text and\n              // then hold delete. Toggling to `1, 1` and then back to\n              // `0, 0` seems to completely fix it.\n              el.setSelectionRange(1, 1);\n              el.setSelectionRange(0, 0);\n            }\n          });\n        });\n      }\n\n      _this._isServer = !_this._platform.isBrowser;\n      _this._isNativeSelect = element.nodeName.toLowerCase() === 'select';\n\n      if (_this._isNativeSelect) {\n        _this.controlType =\n        /** @type {?} */\n        element.multiple ? 'mat-native-select-multiple' : 'mat-native-select';\n      }\n\n      return _this;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n\n\n    _createClass(MatInput, [{\n      key: \"disabled\",\n      get: function get() {\n        if (this.ngControl && this.ngControl.disabled !== null) {\n          return this.ngControl.disabled;\n        }\n\n        return this._disabled;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._disabled = coerceBooleanProperty(value); // Browsers may not fire the blur event if the input is disabled too quickly.\n        // Reset from here to ensure that the element doesn't become stuck.\n\n        if (this.focused) {\n          this.focused = false;\n          this.stateChanges.next();\n        }\n      }\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * \\@docs-private\n       * @return {?}\n       */\n\n    }, {\n      key: \"id\",\n      get: function get() {\n        return this._id;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._id = value || this._uid;\n      }\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * \\@docs-private\n       * @return {?}\n       */\n\n    }, {\n      key: \"required\",\n      get: function get() {\n        return this._required;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._required = coerceBooleanProperty(value);\n      }\n      /**\n       * Input type of the element.\n       * @return {?}\n       */\n\n    }, {\n      key: \"type\",\n      get: function get() {\n        return this._type;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._type = value || 'text';\n\n        this._validateType(); // When using Angular inputs, developers are no longer able to set the properties on the native\n        // input element. To ensure that bindings for `type` work, we need to sync the setter\n        // with the native property. Textarea elements don't support the type property or attribute.\n\n\n        if (!this._isTextarea() && getSupportedInputTypes().has(this._type)) {\n          /** @type {?} */\n          this._elementRef.nativeElement.type = this._type;\n        }\n      }\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * \\@docs-private\n       * @return {?}\n       */\n\n    }, {\n      key: \"value\",\n      get: function get() {\n        return this._inputValueAccessor.value;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        if (value !== this.value) {\n          this._inputValueAccessor.value = value;\n          this.stateChanges.next();\n        }\n      }\n      /**\n       * Whether the element is readonly.\n       * @return {?}\n       */\n\n    }, {\n      key: \"readonly\",\n      get: function get() {\n        return this._readonly;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._readonly = coerceBooleanProperty(value);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this2 = this;\n\n        if (this._platform.isBrowser) {\n          this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(function (event) {\n            _this2.autofilled = event.isAutofilled;\n\n            _this2.stateChanges.next();\n          });\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges() {\n        this.stateChanges.next();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.stateChanges.complete();\n\n        if (this._platform.isBrowser) {\n          this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngDoCheck\",\n      value: function ngDoCheck() {\n        if (this.ngControl) {\n          // We need to re-evaluate this on every change detection cycle, because there are some\n          // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n          // that whatever logic is in here has to be super lean or we risk destroying the performance.\n          this.updateErrorState();\n        } // We need to dirty-check the native element's value, because there are some cases where\n        // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n        // updating the value using `emitEvent: false`).\n\n\n        this._dirtyCheckNativeValue();\n      }\n      /**\n       * Focuses the input.\n       * @return {?}\n       */\n\n    }, {\n      key: \"focus\",\n      value: function focus() {\n        this._elementRef.nativeElement.focus();\n      }\n      /**\n       * Callback for the cases where the focused state of the input changes.\n       * @param {?} isFocused\n       * @return {?}\n       */\n\n    }, {\n      key: \"_focusChanged\",\n      value: function _focusChanged(isFocused) {\n        if (isFocused !== this.focused && !this.readonly) {\n          this.focused = isFocused;\n          this.stateChanges.next();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"_onInput\",\n      value: function _onInput() {// This is a noop function and is used to let Angular know whenever the value changes.\n        // Angular will run a new change detection each time the `input` event has been dispatched.\n        // It's necessary that Angular recognizes the value change, because when floatingLabel\n        // is set to false and Angular forms aren't used, the placeholder won't recognize the\n        // value changes and will not disappear.\n        // Listening to the input event wouldn't be necessary when the input is using the\n        // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n      }\n      /**\n       * Does some manual dirty checking on the native input `value` property.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_dirtyCheckNativeValue\",\n      value: function _dirtyCheckNativeValue() {\n        /** @type {?} */\n        var newValue = this._elementRef.nativeElement.value;\n\n        if (this._previousNativeValue !== newValue) {\n          this._previousNativeValue = newValue;\n          this.stateChanges.next();\n        }\n      }\n      /**\n       * Make sure the input is a supported type.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_validateType\",\n      value: function _validateType() {\n        if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1) {\n          throw getMatInputUnsupportedTypeError(this._type);\n        }\n      }\n      /**\n       * Checks whether the input type is one of the types that are never empty.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_isNeverEmpty\",\n      value: function _isNeverEmpty() {\n        return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n      }\n      /**\n       * Checks whether the input is invalid based on the native validation.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_isBadInput\",\n      value: function _isBadInput() {\n        /** @type {?} */\n        var validity =\n        /** @type {?} */\n        this._elementRef.nativeElement.validity;\n        return validity && validity.badInput;\n      }\n      /**\n       * Determines if the component host is a textarea.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_isTextarea\",\n      value: function _isTextarea() {\n        return this._elementRef.nativeElement.nodeName.toLowerCase() === 'textarea';\n      }\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * \\@docs-private\n       * @return {?}\n       */\n\n    }, {\n      key: \"empty\",\n      get: function get() {\n        return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() && !this.autofilled;\n      }\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * \\@docs-private\n       * @return {?}\n       */\n\n    }, {\n      key: \"shouldLabelFloat\",\n      get: function get() {\n        if (this._isNativeSelect) {\n          /** @type {?} */\n          var selectElement =\n          /** @type {?} */\n          this._elementRef.nativeElement;\n          return selectElement.multiple || !this.empty || !!selectElement.options[0].label || this.focused;\n        } else {\n          return this.focused || !this.empty;\n        }\n      }\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * \\@docs-private\n       * @param {?} ids\n       * @return {?}\n       */\n\n    }, {\n      key: \"setDescribedByIds\",\n      value: function setDescribedByIds(ids) {\n        this._ariaDescribedby = ids.join(' ');\n      }\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * \\@docs-private\n       * @return {?}\n       */\n\n    }, {\n      key: \"onContainerClick\",\n      value: function onContainerClick() {\n        // Do not re-focus the input element if the element is already focused. Otherwise it can happen\n        // that someone clicks on a time input and the cursor resets to the \"hours\" field while the\n        // \"minutes\" field was actually clicked. See: https://github.com/angular/material2/issues/12849\n        if (!this.focused) {\n          this.focus();\n        }\n      }\n    }]);\n\n    return MatInput;\n  }(_MatInputMixinBase);\n\n  MatInput.ɵfac = function MatInput_Factory(t) {\n    return new (t || MatInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgControl, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgForm, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.FormGroupDirective, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.ErrorStateMatcher), ɵngcc0.ɵɵdirectiveInject(MAT_INPUT_VALUE_ACCESSOR, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.AutofillMonitor), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  MatInput.ɵdir =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineDirective({\n    type: MatInput,\n    selectors: [[\"input\", \"matInput\", \"\"], [\"textarea\", \"matInput\", \"\"], [\"select\", \"matNativeControl\", \"\"], [\"input\", \"matNativeControl\", \"\"], [\"textarea\", \"matNativeControl\", \"\"]],\n    hostAttrs: [1, \"mat-input-element\", \"mat-form-field-autofill-control\"],\n    hostVars: 10,\n    hostBindings: function MatInput_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"blur\", function MatInput_blur_HostBindingHandler() {\n          return ctx._focusChanged(false);\n        })(\"focus\", function MatInput_focus_HostBindingHandler() {\n          return ctx._focusChanged(true);\n        })(\"input\", function MatInput_input_HostBindingHandler() {\n          return ctx._onInput();\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵhostProperty(\"disabled\", ctx.disabled)(\"required\", ctx.required);\n        ɵngcc0.ɵɵattribute(\"id\", ctx.id)(\"placeholder\", ctx.placeholder)(\"readonly\", ctx.readonly && !ctx._isNativeSelect || null)(\"aria-describedby\", ctx._ariaDescribedby || null)(\"aria-invalid\", ctx.errorState)(\"aria-required\", ctx.required.toString());\n        ɵngcc0.ɵɵclassProp(\"mat-input-server\", ctx._isServer);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      disabled: \"disabled\",\n      required: \"required\",\n      type: \"type\",\n      value: \"value\",\n      readonly: \"readonly\",\n      placeholder: \"placeholder\",\n      errorStateMatcher: \"errorStateMatcher\"\n    },\n    exportAs: [\"matInput\"],\n    features: [/*@__PURE__*/ɵngcc0.ɵɵProvidersFeature([{\n      provide: MatFormFieldControl,\n      useExisting: MatInput\n    }]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return MatInput;\n}();\n\nvar MatInputModule = /*@__PURE__*/function () {\n  var MatInputModule = function MatInputModule() {\n    _classCallCheck(this, MatInputModule);\n  };\n\n  MatInputModule.ɵfac = function MatInputModule_Factory(t) {\n    return new (t || MatInputModule)();\n  };\n\n  MatInputModule.ɵmod =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineNgModule({\n    type: MatInputModule\n  });\n  MatInputModule.ɵinj =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineInjector({\n    providers: [ErrorStateMatcher],\n    imports: [[CommonModule, TextFieldModule, MatFormFieldModule], TextFieldModule, MatFormFieldModule]\n  });\n  return MatInputModule;\n}();\n/*@__PURE__*/\n\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatInputModule, {\n    declarations: function declarations() {\n      return [MatInput, MatTextareaAutosize];\n    },\n    imports: function imports() {\n      return [CommonModule, TextFieldModule, MatFormFieldModule];\n    },\n    exports: function exports() {\n      return [TextFieldModule, MatFormFieldModule, MatInput, MatTextareaAutosize];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nexport { _CdkTextareaAutosize, MatTextareaAutosize, MatInputBase, _MatInputMixinBase, MatInput, getMatInputUnsupportedTypeError, MatInputModule, MAT_INPUT_VALUE_ACCESSOR }; //# sourceMappingURL=input.js.map","map":null,"metadata":{},"sourceType":"module"}