{"ast":null,"code":"import _createClass from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { InjectionToken, Attribute, ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, forwardRef, Input, Output, ViewChild, ViewEncapsulation, NgZone, Optional, Inject, NgModule } from '@angular/core';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Platform } from '@angular/cdk/platform';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { mixinColor, mixinDisabled, mixinDisableRipple, mixinTabIndex, GestureConfig, MatCommonModule, MatRippleModule } from '@angular/material/core';\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\nimport { ObserversModule } from '@angular/cdk/observers';\nimport { HAMMER_GESTURE_CONFIG } from '@angular/platform-browser';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** *\n * Injection token to be used to override the default options for `mat-slide-toggle`.\n  @type {?} */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/platform';\nimport * as ɵngcc2 from '@angular/cdk/a11y';\nimport * as ɵngcc3 from '@angular/cdk/bidi';\nimport * as ɵngcc4 from '@angular/material/core';\nimport * as ɵngcc5 from '@angular/cdk/observers';\nvar _c0 = [\"thumbContainer\"];\nvar _c1 = [\"toggleBar\"];\nvar _c2 = [\"input\"];\n\nvar _c3 = function _c3() {\n  return {\n    enterDuration: 150\n  };\n};\n\nvar _c4 = [\"*\"];\nvar MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS = /*@__PURE__*/new InjectionToken('mat-slide-toggle-default-options', {\n  providedIn: 'root',\n  factory: function factory() {\n    return {\n      disableToggleValue: false,\n      disableDragValue: false\n    };\n  }\n});\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\nvar nextUniqueId = 0;\n/** *\n * \\@docs-private\n  @type {?} */\n\nvar MAT_SLIDE_TOGGLE_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: /*@__PURE__*/forwardRef(function () {\n    return MatSlideToggle;\n  }),\n  multi: true\n};\n/**\n * Change event object emitted by a MatSlideToggle.\n */\n\nvar MatSlideToggleChange =\n/**\n * @param {?} source\n * @param {?} checked\n */\nfunction MatSlideToggleChange(source, checked) {\n  _classCallCheck(this, MatSlideToggleChange);\n\n  this.source = source;\n  this.checked = checked;\n};\n/**\n * \\@docs-private\n */\n\n\nvar MatSlideToggleBase =\n/**\n * @param {?} _elementRef\n */\nfunction MatSlideToggleBase(_elementRef) {\n  _classCallCheck(this, MatSlideToggleBase);\n\n  this._elementRef = _elementRef;\n};\n/** @type {?} */\n\n\nvar _MatSlideToggleMixinBase = /*@__PURE__*/mixinTabIndex( /*@__PURE__*/mixinColor( /*@__PURE__*/mixinDisableRipple( /*@__PURE__*/mixinDisabled(MatSlideToggleBase)), 'accent'));\n\nvar MatSlideToggle = /*@__PURE__*/function () {\n  var MatSlideToggle = /*#__PURE__*/function (_MatSlideToggleMixinB) {\n    _inherits(MatSlideToggle, _MatSlideToggleMixinB);\n\n    var _super = _createSuper(MatSlideToggle);\n\n    /**\n     * @param {?} elementRef\n     * @param {?} _platform\n     * @param {?} _focusMonitor\n     * @param {?} _changeDetectorRef\n     * @param {?} tabIndex\n     * @param {?} _ngZone\n     * @param {?} defaults\n     * @param {?=} _animationMode\n     * @param {?=} _dir\n     */\n    function MatSlideToggle(elementRef,\n    /**\n    * @deprecated The `_platform` parameter to be removed.\n    * @breaking-change 8.0.0\n    */\n    _platform, _focusMonitor, _changeDetectorRef, tabIndex, _ngZone, defaults, _animationMode, _dir) {\n      var _this;\n\n      _classCallCheck(this, MatSlideToggle);\n\n      _this = _super.call(this, elementRef);\n      _this._focusMonitor = _focusMonitor;\n      _this._changeDetectorRef = _changeDetectorRef;\n      _this._ngZone = _ngZone;\n      _this.defaults = defaults;\n      _this._animationMode = _animationMode;\n      _this._dir = _dir;\n\n      _this.onChange = function (_) {};\n\n      _this.onTouched = function () {};\n\n      _this._uniqueId = \"mat-slide-toggle-\".concat(++nextUniqueId);\n      _this._required = false;\n      _this._checked = false;\n      /**\n       * Whether the thumb is currently being dragged.\n       */\n\n      _this._dragging = false;\n      /**\n       * Name value will be applied to the input element if present.\n       */\n\n      _this.name = null;\n      /**\n       * A unique id for the slide-toggle input. If none is supplied, it will be auto-generated.\n       */\n\n      _this.id = _this._uniqueId;\n      /**\n       * Whether the label should appear after or before the slide-toggle. Defaults to 'after'.\n       */\n\n      _this.labelPosition = 'after';\n      /**\n       * Used to set the aria-label attribute on the underlying input element.\n       */\n\n      _this.ariaLabel = null;\n      /**\n       * Used to set the aria-labelledby attribute on the underlying input element.\n       */\n\n      _this.ariaLabelledby = null;\n      /**\n       * An event will be dispatched each time the slide-toggle changes its value.\n       */\n\n      _this.change = new EventEmitter();\n      /**\n       * An event will be dispatched each time the slide-toggle input is toggled.\n       * This event is always emitted when the user toggles the slide toggle, but this does not mean\n       * the slide toggle's value has changed. The event does not fire when the user drags to change\n       * the slide toggle value.\n       */\n\n      _this.toggleChange = new EventEmitter();\n      /**\n       * An event will be dispatched each time the slide-toggle is dragged.\n       * This event is always emitted when the user drags the slide toggle to make a change greater\n       * than 50%. It does not mean the slide toggle's value is changed. The event is not emitted when\n       * the user toggles the slide toggle to change its value.\n       */\n\n      _this.dragChange = new EventEmitter();\n      _this.tabIndex = parseInt(tabIndex) || 0;\n      return _this;\n    }\n    /**\n     * Whether the slide-toggle is required.\n     * @return {?}\n     */\n\n\n    _createClass(MatSlideToggle, [{\n      key: \"required\",\n      get: function get() {\n        return this._required;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._required = coerceBooleanProperty(value);\n      }\n      /**\n       * Whether the slide-toggle element is checked or not.\n       * @return {?}\n       */\n\n    }, {\n      key: \"checked\",\n      get: function get() {\n        return this._checked;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._checked = coerceBooleanProperty(value);\n\n        this._changeDetectorRef.markForCheck();\n      }\n      /**\n       * Returns the unique id for the visual hidden input.\n       * @return {?}\n       */\n\n    }, {\n      key: \"inputId\",\n      get: function get() {\n        return \"\".concat(this.id || this._uniqueId, \"-input\");\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngAfterContentInit\",\n      value: function ngAfterContentInit() {\n        var _this2 = this;\n\n        this._focusMonitor.monitor(this._elementRef, true).subscribe(function (focusOrigin) {\n          if (!focusOrigin) {\n            // When a focused element becomes disabled, the browser *immediately* fires a blur event.\n            // Angular does not expect events to be raised during change detection, so any state\n            // change (such as a form control's 'ng-touched') will cause a changed-after-checked\n            // error. See https://github.com/angular/angular/issues/17793. To work around this,\n            // we defer telling the form control it has been touched until the next tick.\n            Promise.resolve().then(function () {\n              return _this2.onTouched();\n            });\n          }\n        });\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this._focusMonitor.stopMonitoring(this._elementRef);\n      }\n      /**\n       * Method being called whenever the underlying input emits a change event.\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"_onChangeEvent\",\n      value: function _onChangeEvent(event) {\n        // We always have to stop propagation on the change event.\n        // Otherwise the change event, from the input element, will bubble up and\n        // emit its event object to the component's `change` output.\n        event.stopPropagation();\n\n        if (!this._dragging) {\n          this.toggleChange.emit();\n        } // Releasing the pointer over the `<label>` element while dragging triggers another\n        // click event on the `<label>` element. This means that the checked state of the underlying\n        // input changed unintentionally and needs to be changed back. Or when the slide toggle's config\n        // disabled toggle change event by setting `disableToggleValue: true`, the slide toggle's value\n        // does not change, and the checked state of the underlying input needs to be changed back.\n\n\n        if (this._dragging || this.defaults.disableToggleValue) {\n          this._inputElement.nativeElement.checked = this.checked;\n          return;\n        } // Sync the value from the underlying input element with the component instance.\n\n\n        this.checked = this._inputElement.nativeElement.checked; // Emit our custom change event only if the underlying input emitted one. This ensures that\n        // there is no change event, when the checked state changes programmatically.\n\n        this._emitChangeEvent();\n      }\n      /**\n       * Method being called whenever the slide-toggle has been clicked.\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"_onInputClick\",\n      value: function _onInputClick(event) {\n        // We have to stop propagation for click events on the visual hidden input element.\n        // By default, when a user clicks on a label element, a generated click event will be\n        // dispatched on the associated input element. Since we are using a label element as our\n        // root container, the click event on the `slide-toggle` will be executed twice.\n        // The real click event will bubble up, and the generated click event also tries to bubble up.\n        // This will lead to multiple click events.\n        // Preventing bubbling for the second event will solve that issue.\n        event.stopPropagation();\n      }\n      /**\n       * Implemented as part of ControlValueAccessor.\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"writeValue\",\n      value: function writeValue(value) {\n        this.checked = !!value;\n      }\n      /**\n       * Implemented as part of ControlValueAccessor.\n       * @param {?} fn\n       * @return {?}\n       */\n\n    }, {\n      key: \"registerOnChange\",\n      value: function registerOnChange(fn) {\n        this.onChange = fn;\n      }\n      /**\n       * Implemented as part of ControlValueAccessor.\n       * @param {?} fn\n       * @return {?}\n       */\n\n    }, {\n      key: \"registerOnTouched\",\n      value: function registerOnTouched(fn) {\n        this.onTouched = fn;\n      }\n      /**\n       * Implemented as a part of ControlValueAccessor.\n       * @param {?} isDisabled\n       * @return {?}\n       */\n\n    }, {\n      key: \"setDisabledState\",\n      value: function setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n\n        this._changeDetectorRef.markForCheck();\n      }\n      /**\n       * Focuses the slide-toggle.\n       * @return {?}\n       */\n\n    }, {\n      key: \"focus\",\n      value: function focus() {\n        this._focusMonitor.focusVia(this._inputElement, 'keyboard');\n      }\n      /**\n       * Toggles the checked state of the slide-toggle.\n       * @return {?}\n       */\n\n    }, {\n      key: \"toggle\",\n      value: function toggle() {\n        this.checked = !this.checked;\n        this.onChange(this.checked);\n      }\n      /**\n       * Emits a change event on the `change` output. Also notifies the FormControl about the change.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_emitChangeEvent\",\n      value: function _emitChangeEvent() {\n        this.onChange(this.checked);\n        this.change.emit(new MatSlideToggleChange(this, this.checked));\n      }\n      /**\n       * Retrieves the percentage of thumb from the moved distance. Percentage as fraction of 100.\n       * @param {?} distance\n       * @return {?}\n       */\n\n    }, {\n      key: \"_getDragPercentage\",\n      value: function _getDragPercentage(distance) {\n        /** @type {?} */\n        var percentage = distance / this._thumbBarWidth * 100; // When the toggle was initially checked, then we have to start the drag at the end.\n\n        if (this._previousChecked) {\n          percentage += 100;\n        }\n\n        return Math.max(0, Math.min(percentage, 100));\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"_onDragStart\",\n      value: function _onDragStart() {\n        if (!this.disabled && !this._dragging) {\n          /** @type {?} */\n          var thumbEl = this._thumbEl.nativeElement;\n          this._thumbBarWidth = this._thumbBarEl.nativeElement.clientWidth - thumbEl.clientWidth;\n          thumbEl.classList.add('mat-dragging');\n          this._previousChecked = this.checked;\n          this._dragging = true;\n        }\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"_onDrag\",\n      value: function _onDrag(event) {\n        if (this._dragging) {\n          /** @type {?} */\n          var direction = this._dir && this._dir.value === 'rtl' ? -1 : 1;\n          this._dragPercentage = this._getDragPercentage(event.deltaX * direction);\n          /** @type {?} */\n\n          var dragX = this._dragPercentage / 100 * this._thumbBarWidth * direction;\n          this._thumbEl.nativeElement.style.transform = \"translate3d(\".concat(dragX, \"px, 0, 0)\");\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"_onDragEnd\",\n      value: function _onDragEnd() {\n        var _this3 = this;\n\n        if (this._dragging) {\n          /** @type {?} */\n          var newCheckedValue = this._dragPercentage > 50;\n\n          if (newCheckedValue !== this.checked) {\n            this.dragChange.emit();\n\n            if (!this.defaults.disableDragValue) {\n              this.checked = newCheckedValue;\n\n              this._emitChangeEvent();\n            }\n          } // The drag should be stopped outside of the current event handler, otherwise the\n          // click event will be fired before it and will revert the drag change.\n\n\n          this._ngZone.runOutsideAngular(function () {\n            return setTimeout(function () {\n              if (_this3._dragging) {\n                _this3._dragging = false;\n\n                _this3._thumbEl.nativeElement.classList.remove('mat-dragging'); // Reset the transform because the component will take care\n                // of the thumb position after drag.\n\n\n                _this3._thumbEl.nativeElement.style.transform = '';\n              }\n            });\n          });\n        }\n      }\n      /**\n       * Method being called whenever the label text changes.\n       * @return {?}\n       */\n\n    }, {\n      key: \"_onLabelTextChange\",\n      value: function _onLabelTextChange() {\n        // Since the event of the `cdkObserveContent` directive runs outside of the zone, the\n        // slide-toggle component will be only marked for check, but no actual change detection runs\n        // automatically. Instead of going back into the zone in order to trigger a change detection\n        // which causes *all* components to be checked (if explicitly marked or not using OnPush),\n        // we only trigger an explicit change detection for the slide-toggle view and it's children.\n        this._changeDetectorRef.detectChanges();\n      }\n    }]);\n\n    return MatSlideToggle;\n  }(_MatSlideToggleMixinBase);\n\n  MatSlideToggle.ɵfac = function MatSlideToggle_Factory(t) {\n    return new (t || MatSlideToggle)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.FocusMonitor), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵinjectAttribute('tabindex'), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS), ɵngcc0.ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Directionality, 8));\n  };\n\n  MatSlideToggle.ɵcmp =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineComponent({\n    type: MatSlideToggle,\n    selectors: [[\"mat-slide-toggle\"]],\n    viewQuery: function MatSlideToggle_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 5);\n        ɵngcc0.ɵɵviewQuery(_c1, 5);\n        ɵngcc0.ɵɵviewQuery(_c2, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._thumbEl = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._thumbBarEl = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputElement = _t.first);\n      }\n    },\n    hostAttrs: [1, \"mat-slide-toggle\"],\n    hostVars: 10,\n    hostBindings: function MatSlideToggle_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵhostProperty(\"id\", ctx.id);\n        ɵngcc0.ɵɵattribute(\"tabindex\", null);\n        ɵngcc0.ɵɵclassProp(\"mat-checked\", ctx.checked)(\"mat-disabled\", ctx.disabled)(\"mat-slide-toggle-label-before\", ctx.labelPosition == \"before\")(\"_mat-animation-noopable\", ctx._animationMode === \"NoopAnimations\");\n      }\n    },\n    inputs: {\n      disabled: \"disabled\",\n      disableRipple: \"disableRipple\",\n      color: \"color\",\n      tabIndex: \"tabIndex\",\n      name: \"name\",\n      id: \"id\",\n      labelPosition: \"labelPosition\",\n      ariaLabel: [\"aria-label\", \"ariaLabel\"],\n      ariaLabelledby: [\"aria-labelledby\", \"ariaLabelledby\"],\n      required: \"required\",\n      checked: \"checked\"\n    },\n    outputs: {\n      change: \"change\",\n      toggleChange: \"toggleChange\",\n      dragChange: \"dragChange\"\n    },\n    exportAs: [\"matSlideToggle\"],\n    features: [/*@__PURE__*/ɵngcc0.ɵɵProvidersFeature([MAT_SLIDE_TOGGLE_VALUE_ACCESSOR]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c4,\n    decls: 14,\n    vars: 16,\n    consts: [[1, \"mat-slide-toggle-label\"], [\"label\", \"\"], [1, \"mat-slide-toggle-bar\"], [\"toggleBar\", \"\"], [\"type\", \"checkbox\", 1, \"mat-slide-toggle-input\", \"cdk-visually-hidden\", 3, \"id\", \"required\", \"tabIndex\", \"checked\", \"disabled\", \"change\", \"click\"], [\"input\", \"\"], [1, \"mat-slide-toggle-thumb-container\", 3, \"slidestart\", \"slide\", \"slideend\"], [\"thumbContainer\", \"\"], [1, \"mat-slide-toggle-thumb\"], [\"mat-ripple\", \"\", 1, \"mat-slide-toggle-ripple\", 3, \"matRippleTrigger\", \"matRippleDisabled\", \"matRippleCentered\", \"matRippleRadius\", \"matRippleAnimation\"], [1, \"mat-ripple-element\", \"mat-slide-toggle-persistent-ripple\"], [1, \"mat-slide-toggle-content\", 3, \"cdkObserveContent\"], [\"labelContent\", \"\"]],\n    template: function MatSlideToggle_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"label\", 0, 1);\n        ɵngcc0.ɵɵelementStart(2, \"div\", 2, 3);\n        ɵngcc0.ɵɵelementStart(4, \"input\", 4, 5);\n        ɵngcc0.ɵɵlistener(\"change\", function MatSlideToggle_Template_input_change_4_listener($event) {\n          return ctx._onChangeEvent($event);\n        })(\"click\", function MatSlideToggle_Template_input_click_4_listener($event) {\n          return ctx._onInputClick($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(6, \"div\", 6, 7);\n        ɵngcc0.ɵɵlistener(\"slidestart\", function MatSlideToggle_Template_div_slidestart_6_listener() {\n          return ctx._onDragStart();\n        })(\"slide\", function MatSlideToggle_Template_div_slide_6_listener($event) {\n          return ctx._onDrag($event);\n        })(\"slideend\", function MatSlideToggle_Template_div_slideend_6_listener() {\n          return ctx._onDragEnd();\n        });\n        ɵngcc0.ɵɵelement(8, \"div\", 8);\n        ɵngcc0.ɵɵelementStart(9, \"div\", 9);\n        ɵngcc0.ɵɵelement(10, \"div\", 10);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(11, \"span\", 11, 12);\n        ɵngcc0.ɵɵlistener(\"cdkObserveContent\", function MatSlideToggle_Template_span_cdkObserveContent_11_listener() {\n          return ctx._onLabelTextChange();\n        });\n        ɵngcc0.ɵɵprojection(13);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        var _r0 = ɵngcc0.ɵɵreference(1);\n\n        var _r4 = ɵngcc0.ɵɵreference(12);\n\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵclassProp(\"mat-slide-toggle-bar-no-side-margin\", !_r4.textContent || !_r4.textContent.trim());\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"id\", ctx.inputId)(\"required\", ctx.required)(\"tabIndex\", ctx.tabIndex)(\"checked\", ctx.checked)(\"disabled\", ctx.disabled);\n        ɵngcc0.ɵɵattribute(\"name\", ctx.name)(\"aria-label\", ctx.ariaLabel)(\"aria-labelledby\", ctx.ariaLabelledby);\n        ɵngcc0.ɵɵadvance(5);\n        ɵngcc0.ɵɵproperty(\"matRippleTrigger\", _r0)(\"matRippleDisabled\", ctx.disableRipple || ctx.disabled)(\"matRippleCentered\", true)(\"matRippleRadius\", 20)(\"matRippleAnimation\", ɵngcc0.ɵɵpureFunction0(15, _c3));\n      }\n    },\n    directives: [ɵngcc4.MatRipple, ɵngcc5.CdkObserveContent],\n    styles: [\".mat-slide-toggle{display:inline-block;height:24px;max-width:100%;line-height:24px;white-space:nowrap;outline:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb-container{transform:translate3d(16px,0,0)}[dir=rtl] .mat-slide-toggle.mat-checked .mat-slide-toggle-thumb-container{transform:translate3d(-16px,0,0)}.mat-slide-toggle.mat-disabled .mat-slide-toggle-label,.mat-slide-toggle.mat-disabled .mat-slide-toggle-thumb-container{cursor:default}.mat-slide-toggle-label{display:flex;flex:1;flex-direction:row;align-items:center;height:inherit;cursor:pointer}.mat-slide-toggle-content{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-slide-toggle-label-before .mat-slide-toggle-label{order:1}.mat-slide-toggle-label-before .mat-slide-toggle-bar{order:2}.mat-slide-toggle-bar,[dir=rtl] .mat-slide-toggle-label-before .mat-slide-toggle-bar{margin-right:8px;margin-left:0}.mat-slide-toggle-label-before .mat-slide-toggle-bar,[dir=rtl] .mat-slide-toggle-bar{margin-left:8px;margin-right:0}.mat-slide-toggle-bar-no-side-margin{margin-left:0;margin-right:0}.mat-slide-toggle-thumb-container{position:absolute;z-index:1;width:20px;height:20px;top:-3px;left:0;transform:translate3d(0,0,0);transition:all 80ms linear;transition-property:transform;cursor:-webkit-grab;cursor:grab}.mat-slide-toggle-thumb-container.mat-dragging,.mat-slide-toggle-thumb-container:active{cursor:-webkit-grabbing;cursor:grabbing;transition-duration:0s}._mat-animation-noopable .mat-slide-toggle-thumb-container{transition:none}[dir=rtl] .mat-slide-toggle-thumb-container{left:auto;right:0}.mat-slide-toggle-thumb{height:20px;width:20px;border-radius:50%}.mat-slide-toggle-bar{position:relative;width:36px;height:14px;flex-shrink:0;border-radius:8px}.mat-slide-toggle-input{bottom:0;left:10px}[dir=rtl] .mat-slide-toggle-input{left:auto;right:10px}.mat-slide-toggle-bar,.mat-slide-toggle-thumb{transition:all 80ms linear;transition-property:background-color;transition-delay:50ms}._mat-animation-noopable .mat-slide-toggle-bar,._mat-animation-noopable .mat-slide-toggle-thumb{transition:none}.mat-slide-toggle .mat-slide-toggle-ripple{position:absolute;top:calc(50% - 20px);left:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}.mat-slide-toggle .mat-slide-toggle-ripple .mat-ripple-element:not(.mat-slide-toggle-persistent-ripple){opacity:.12}.mat-slide-toggle-persistent-ripple{width:100%;height:100%;transform:none}.mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{opacity:.04}.mat-slide-toggle.cdk-focused .mat-slide-toggle-persistent-ripple{opacity:.12}.mat-slide-toggle-persistent-ripple,.mat-slide-toggle.mat-disabled .mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{opacity:0}@media screen and (-ms-high-contrast:active){.mat-slide-toggle-thumb{background:#fff;border:1px solid #000}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb{background:#000;border:1px solid #fff}.mat-slide-toggle-bar{background:#fff}}@media screen and (-ms-high-contrast:black-on-white){.mat-slide-toggle-bar{border:1px solid #000}}\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MatSlideToggle;\n}();\n\nvar MatSlideToggleModule = /*@__PURE__*/function () {\n  var MatSlideToggleModule = function MatSlideToggleModule() {\n    _classCallCheck(this, MatSlideToggleModule);\n  };\n\n  MatSlideToggleModule.ɵfac = function MatSlideToggleModule_Factory(t) {\n    return new (t || MatSlideToggleModule)();\n  };\n\n  MatSlideToggleModule.ɵmod =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineNgModule({\n    type: MatSlideToggleModule\n  });\n  MatSlideToggleModule.ɵinj =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  ɵngcc0.ɵɵdefineInjector({\n    providers: [{\n      provide: HAMMER_GESTURE_CONFIG,\n      useClass: GestureConfig\n    }],\n    imports: [[MatRippleModule, MatCommonModule, ObserversModule], MatCommonModule]\n  });\n  return MatSlideToggleModule;\n}();\n/*@__PURE__*/\n\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatSlideToggleModule, {\n    declarations: function declarations() {\n      return [MatSlideToggle];\n    },\n    imports: function imports() {\n      return [MatRippleModule, MatCommonModule, ObserversModule];\n    },\n    exports: function exports() {\n      return [MatSlideToggle, MatCommonModule];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nexport { MatSlideToggleModule, MAT_SLIDE_TOGGLE_VALUE_ACCESSOR, MatSlideToggleChange, MatSlideToggleBase, _MatSlideToggleMixinBase, MatSlideToggle, MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS }; //# sourceMappingURL=slide-toggle.js.map","map":null,"metadata":{},"sourceType":"module"}