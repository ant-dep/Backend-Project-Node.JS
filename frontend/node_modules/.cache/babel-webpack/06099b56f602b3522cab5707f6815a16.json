{"ast":null,"code":"import _get from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/adepertat/Dropbox/ECOLES/Openclassroom/P6_de_Pertat_Antoine/AntoinedePertat_6_240521/frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ComponentFactoryResolver, Directive, EventEmitter, NgModule, Output, TemplateRef, ViewContainerRef } from '@angular/core';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * \\@docs-private\n * @return {?}\n */\n\nimport * as Éµngcc0 from '@angular/core';\n\nfunction throwNullPortalError() {\n  throw Error('Must provide a portal to attach');\n}\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction throwPortalAlreadyAttachedError() {\n  throw Error('Host already has a portal attached');\n}\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction throwPortalOutletAlreadyDisposedError() {\n  throw Error('This PortalOutlet has already been disposed');\n}\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction throwUnknownPortalTypeError() {\n  throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' + 'a ComponentPortal or a TemplatePortal.');\n}\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction throwNullPortalOutletError() {\n  throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction throwNoPortalAttachedError() {\n  throw Error('Attempting to detach a portal that is not attached to a host');\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n * @abstract\n * @template T\n */\n\n\nvar Portal = /*#__PURE__*/function () {\n  function Portal() {\n    _classCallCheck(this, Portal);\n  }\n\n  _createClass(Portal, [{\n    key: \"attach\",\n    value:\n    /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @return {?}\n     */\n    function attach(host) {\n      if (host == null) {\n        throwNullPortalOutletError();\n      }\n\n      if (host.hasAttached()) {\n        throwPortalAlreadyAttachedError();\n      }\n\n      this._attachedHost = host;\n      return (\n        /** @type {?} */\n        host.attach(this)\n      );\n    }\n    /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      /** @type {?} */\n      var host = this._attachedHost;\n\n      if (host == null) {\n        throwNoPortalAttachedError();\n      } else {\n        this._attachedHost = null;\n        host.detach();\n      }\n    }\n    /**\n     * Whether this portal is attached to a host.\n     * @return {?}\n     */\n\n  }, {\n    key: \"isAttached\",\n    get: function get() {\n      return this._attachedHost != null;\n    }\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     * @param {?} host\n     * @return {?}\n     */\n\n  }, {\n    key: \"setAttachedHost\",\n    value: function setAttachedHost(host) {\n      this._attachedHost = host;\n    }\n  }]);\n\n  return Portal;\n}();\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n * @template T\n */\n\n\nvar ComponentPortal = /*#__PURE__*/function (_Portal) {\n  _inherits(ComponentPortal, _Portal);\n\n  var _super = _createSuper(ComponentPortal);\n\n  /**\n   * @param {?} component\n   * @param {?=} viewContainerRef\n   * @param {?=} injector\n   * @param {?=} componentFactoryResolver\n   */\n  function ComponentPortal(component, viewContainerRef, injector, componentFactoryResolver) {\n    var _this;\n\n    _classCallCheck(this, ComponentPortal);\n\n    _this = _super.call(this);\n    _this.component = component;\n    _this.viewContainerRef = viewContainerRef;\n    _this.injector = injector;\n    _this.componentFactoryResolver = componentFactoryResolver;\n    return _this;\n  }\n\n  return ComponentPortal;\n}(Portal);\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n * @template C\n */\n\n\nvar TemplatePortal = /*#__PURE__*/function (_Portal2) {\n  _inherits(TemplatePortal, _Portal2);\n\n  var _super2 = _createSuper(TemplatePortal);\n\n  /**\n   * @param {?} template\n   * @param {?} viewContainerRef\n   * @param {?=} context\n   */\n  function TemplatePortal(template, viewContainerRef, context) {\n    var _this2;\n\n    _classCallCheck(this, TemplatePortal);\n\n    _this2 = _super2.call(this);\n    _this2.templateRef = template;\n    _this2.viewContainerRef = viewContainerRef;\n    _this2.context = context;\n    return _this2;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(TemplatePortal, [{\n    key: \"origin\",\n    get: function get() {\n      return this.templateRef.elementRef;\n    }\n    /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     * @param {?} host\n     * @param {?=} context\n     * @return {?}\n     */\n\n  }, {\n    key: \"attach\",\n    value: function attach(host) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.context;\n      this.context = context;\n      return _get(_getPrototypeOf(TemplatePortal.prototype), \"attach\", this).call(this, host);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      this.context = undefined;\n      return _get(_getPrototypeOf(TemplatePortal.prototype), \"detach\", this).call(this);\n    }\n  }]);\n\n  return TemplatePortal;\n}(Portal);\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n * @abstract\n */\n\n\nvar BasePortalOutlet = /*#__PURE__*/function () {\n  function BasePortalOutlet() {\n    _classCallCheck(this, BasePortalOutlet);\n\n    /**\n     * Whether this host has already been permanently disposed.\n     */\n    this._isDisposed = false;\n  }\n  /**\n   * Whether this host has an attached portal.\n   * @return {?}\n   */\n\n\n  _createClass(BasePortalOutlet, [{\n    key: \"hasAttached\",\n    value: function hasAttached() {\n      return !!this._attachedPortal;\n    }\n    /**\n     * Attaches a portal.\n     * @param {?} portal\n     * @return {?}\n     */\n\n  }, {\n    key: \"attach\",\n    value: function attach(portal) {\n      if (!portal) {\n        throwNullPortalError();\n      }\n\n      if (this.hasAttached()) {\n        throwPortalAlreadyAttachedError();\n      }\n\n      if (this._isDisposed) {\n        throwPortalOutletAlreadyDisposedError();\n      }\n\n      if (portal instanceof ComponentPortal) {\n        this._attachedPortal = portal;\n        return this.attachComponentPortal(portal);\n      } else if (portal instanceof TemplatePortal) {\n        this._attachedPortal = portal;\n        return this.attachTemplatePortal(portal);\n      }\n\n      throwUnknownPortalTypeError();\n    }\n    /**\n     * Detaches a previously attached portal.\n     * @return {?}\n     */\n\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      if (this._attachedPortal) {\n        this._attachedPortal.setAttachedHost(null);\n\n        this._attachedPortal = null;\n      }\n\n      this._invokeDisposeFn();\n    }\n    /**\n     * Permanently dispose of this portal host.\n     * @return {?}\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      if (this.hasAttached()) {\n        this.detach();\n      }\n\n      this._invokeDisposeFn();\n\n      this._isDisposed = true;\n    }\n    /**\n     * \\@docs-private\n     * @param {?} fn\n     * @return {?}\n     */\n\n  }, {\n    key: \"setDisposeFn\",\n    value: function setDisposeFn(fn) {\n      this._disposeFn = fn;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"_invokeDisposeFn\",\n    value: function _invokeDisposeFn() {\n      if (this._disposeFn) {\n        this._disposeFn();\n\n        this._disposeFn = null;\n      }\n    }\n  }]);\n\n  return BasePortalOutlet;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\n\n\nvar DomPortalOutlet = /*#__PURE__*/function (_BasePortalOutlet) {\n  _inherits(DomPortalOutlet, _BasePortalOutlet);\n\n  var _super3 = _createSuper(DomPortalOutlet);\n\n  /**\n   * @param {?} outletElement\n   * @param {?} _componentFactoryResolver\n   * @param {?} _appRef\n   * @param {?} _defaultInjector\n   */\n  function DomPortalOutlet(outletElement, _componentFactoryResolver, _appRef, _defaultInjector) {\n    var _this3;\n\n    _classCallCheck(this, DomPortalOutlet);\n\n    _this3 = _super3.call(this);\n    _this3.outletElement = outletElement;\n    _this3._componentFactoryResolver = _componentFactoryResolver;\n    _this3._appRef = _appRef;\n    _this3._defaultInjector = _defaultInjector;\n    return _this3;\n  }\n  /**\n   * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n   * @template T\n   * @param {?} portal Portal to be attached\n   * @return {?} Reference to the created component.\n   */\n\n\n  _createClass(DomPortalOutlet, [{\n    key: \"attachComponentPortal\",\n    value: function attachComponentPortal(portal) {\n      var _this4 = this;\n\n      /** @type {?} */\n      var resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n      /** @type {?} */\n\n      var componentFactory = resolver.resolveComponentFactory(portal.component);\n      /** @type {?} */\n\n      var componentRef; // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n      // for the component (in terms of Angular's component tree, not rendering).\n      // When the ViewContainerRef is missing, we use the factory to create the component directly\n      // and then manually attach the view to the application.\n\n      if (portal.viewContainerRef) {\n        componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.injector);\n        this.setDisposeFn(function () {\n          return componentRef.destroy();\n        });\n      } else {\n        componentRef = componentFactory.create(portal.injector || this._defaultInjector);\n\n        this._appRef.attachView(componentRef.hostView);\n\n        this.setDisposeFn(function () {\n          _this4._appRef.detachView(componentRef.hostView);\n\n          componentRef.destroy();\n        });\n      } // At this point the component has been instantiated, so we move it to the location in the DOM\n      // where we want it to be rendered.\n\n\n      this.outletElement.appendChild(this._getComponentRootNode(componentRef));\n      return componentRef;\n    }\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n\n  }, {\n    key: \"attachTemplatePortal\",\n    value: function attachTemplatePortal(portal) {\n      var _this5 = this;\n\n      /** @type {?} */\n      var viewContainer = portal.viewContainerRef;\n      /** @type {?} */\n\n      var viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);\n      viewRef.detectChanges(); // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n      // But for the DomPortalOutlet the view can be added everywhere in the DOM\n      // (e.g Overlay Container) To move the view to the specified host element. We just\n      // re-append the existing root nodes.\n\n      viewRef.rootNodes.forEach(function (rootNode) {\n        return _this5.outletElement.appendChild(rootNode);\n      });\n      this.setDisposeFn(function () {\n        /** @type {?} */\n        var index = viewContainer.indexOf(viewRef);\n\n        if (index !== -1) {\n          viewContainer.remove(index);\n        }\n      }); // TODO(jelbourn): Return locals from view.\n\n      return viewRef;\n    }\n    /**\n     * Clears out a portal from the DOM.\n     * @return {?}\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(DomPortalOutlet.prototype), \"dispose\", this).call(this);\n\n      if (this.outletElement.parentNode != null) {\n        this.outletElement.parentNode.removeChild(this.outletElement);\n      }\n    }\n    /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @param {?} componentRef\n     * @return {?}\n     */\n\n  }, {\n    key: \"_getComponentRootNode\",\n    value: function _getComponentRootNode(componentRef) {\n      return (\n        /** @type {?} */\n\n        /** @type {?} */\n        componentRef.hostView.rootNodes[0]\n      );\n    }\n  }]);\n\n  return DomPortalOutlet;\n}(BasePortalOutlet);\n\nvar CdkPortal = /*@__PURE__*/function () {\n  var CdkPortal = /*#__PURE__*/function (_TemplatePortal) {\n    _inherits(CdkPortal, _TemplatePortal);\n\n    var _super4 = _createSuper(CdkPortal);\n\n    /**\n     * @param {?} templateRef\n     * @param {?} viewContainerRef\n     */\n    function CdkPortal(templateRef, viewContainerRef) {\n      _classCallCheck(this, CdkPortal);\n\n      return _super4.call(this, templateRef, viewContainerRef);\n    }\n\n    return CdkPortal;\n  }(TemplatePortal);\n\n  CdkPortal.Éµfac = function CdkPortal_Factory(t) {\n    return new (t || CdkPortal)(Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.TemplateRef), Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.ViewContainerRef));\n  };\n\n  CdkPortal.Éµdir =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  Éµngcc0.ÉµÉµdefineDirective({\n    type: CdkPortal,\n    selectors: [[\"\", \"cdk-portal\", \"\"], [\"\", \"cdkPortal\", \"\"], [\"\", \"portal\", \"\"]],\n    exportAs: [\"cdkPortal\"],\n    features: [Éµngcc0.ÉµÉµInheritDefinitionFeature]\n  });\n  return CdkPortal;\n}();\n\nvar CdkPortalOutlet = /*@__PURE__*/function () {\n  var CdkPortalOutlet = /*#__PURE__*/function (_BasePortalOutlet2) {\n    _inherits(CdkPortalOutlet, _BasePortalOutlet2);\n\n    var _super5 = _createSuper(CdkPortalOutlet);\n\n    /**\n     * @param {?} _componentFactoryResolver\n     * @param {?} _viewContainerRef\n     */\n    function CdkPortalOutlet(_componentFactoryResolver, _viewContainerRef) {\n      var _this6;\n\n      _classCallCheck(this, CdkPortalOutlet);\n\n      _this6 = _super5.call(this);\n      _this6._componentFactoryResolver = _componentFactoryResolver;\n      _this6._viewContainerRef = _viewContainerRef;\n      /**\n       * Whether the portal component is initialized.\n       */\n\n      _this6._isInitialized = false;\n      _this6.attached = new EventEmitter();\n      return _this6;\n    }\n    /**\n     * Portal associated with the Portal outlet.\n     * @return {?}\n     */\n\n\n    _createClass(CdkPortalOutlet, [{\n      key: \"portal\",\n      get: function get() {\n        return this._attachedPortal;\n      }\n      /**\n       * @param {?} portal\n       * @return {?}\n       */\n      ,\n      set: function set(portal) {\n        // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have\n        // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`\n        // and attach a portal programmatically in the parent component. When Angular does the first CD\n        // round, it will fire the setter with empty string, causing the user's content to be cleared.\n        if (this.hasAttached() && !portal && !this._isInitialized) {\n          return;\n        }\n\n        if (this.hasAttached()) {\n          _get(_getPrototypeOf(CdkPortalOutlet.prototype), \"detach\", this).call(this);\n        }\n\n        if (portal) {\n          _get(_getPrototypeOf(CdkPortalOutlet.prototype), \"attach\", this).call(this, portal);\n        }\n\n        this._attachedPortal = portal;\n      }\n      /**\n       * Component or view reference that is attached to the portal.\n       * @return {?}\n       */\n\n    }, {\n      key: \"attachedRef\",\n      get: function get() {\n        return this._attachedRef;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        this._isInitialized = true;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        _get(_getPrototypeOf(CdkPortalOutlet.prototype), \"dispose\", this).call(this);\n\n        this._attachedPortal = null;\n        this._attachedRef = null;\n      }\n      /**\n       * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n       *\n       * @template T\n       * @param {?} portal Portal to be attached to the portal outlet.\n       * @return {?} Reference to the created component.\n       */\n\n    }, {\n      key: \"attachComponentPortal\",\n      value: function attachComponentPortal(portal) {\n        portal.setAttachedHost(this);\n        /** @type {?} */\n\n        var viewContainerRef = portal.viewContainerRef != null ? portal.viewContainerRef : this._viewContainerRef;\n        /** @type {?} */\n\n        var componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        /** @type {?} */\n\n\n        var ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.injector);\n\n        _get(_getPrototypeOf(CdkPortalOutlet.prototype), \"setDisposeFn\", this).call(this, function () {\n          return ref.destroy();\n        });\n\n        this._attachedPortal = portal;\n        this._attachedRef = ref;\n        this.attached.emit(ref);\n        return ref;\n      }\n      /**\n       * Attach the given TemplatePortal to this PortlHost as an embedded View.\n       * @template C\n       * @param {?} portal Portal to be attached.\n       * @return {?} Reference to the created embedded view.\n       */\n\n    }, {\n      key: \"attachTemplatePortal\",\n      value: function attachTemplatePortal(portal) {\n        var _this7 = this;\n\n        portal.setAttachedHost(this);\n        /** @type {?} */\n\n        var viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);\n\n        _get(_getPrototypeOf(CdkPortalOutlet.prototype), \"setDisposeFn\", this).call(this, function () {\n          return _this7._viewContainerRef.clear();\n        });\n\n        this._attachedPortal = portal;\n        this._attachedRef = viewRef;\n        this.attached.emit(viewRef);\n        return viewRef;\n      }\n    }]);\n\n    return CdkPortalOutlet;\n  }(BasePortalOutlet);\n\n  CdkPortalOutlet.Éµfac = function CdkPortalOutlet_Factory(t) {\n    return new (t || CdkPortalOutlet)(Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.ComponentFactoryResolver), Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.ViewContainerRef));\n  };\n\n  CdkPortalOutlet.Éµdir =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  Éµngcc0.ÉµÉµdefineDirective({\n    type: CdkPortalOutlet,\n    selectors: [[\"\", \"cdkPortalOutlet\", \"\"], [\"\", \"cdkPortalHost\", \"\"], [\"\", \"portalHost\", \"\"]],\n    inputs: {\n      portal: [\"cdkPortalOutlet\", \"portal\"]\n    },\n    outputs: {\n      attached: \"attached\"\n    },\n    exportAs: [\"cdkPortalOutlet\", \"cdkPortalHost\"],\n    features: [Éµngcc0.ÉµÉµInheritDefinitionFeature]\n  });\n  return CdkPortalOutlet;\n}();\n\nvar PortalModule = /*@__PURE__*/function () {\n  var PortalModule = function PortalModule() {\n    _classCallCheck(this, PortalModule);\n  };\n\n  PortalModule.Éµfac = function PortalModule_Factory(t) {\n    return new (t || PortalModule)();\n  };\n\n  PortalModule.Éµmod =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  Éµngcc0.ÉµÉµdefineNgModule({\n    type: PortalModule\n  });\n  PortalModule.Éµinj =\n  /*@__PURE__*/\n\n  /*@__PURE__*/\n  Éµngcc0.ÉµÉµdefineInjector({});\n  return PortalModule;\n}();\n/*@__PURE__*/\n\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && Éµngcc0.ÉµÉµsetNgModuleScope(PortalModule, {\n    declarations: [CdkPortal, CdkPortalOutlet],\n    exports: [CdkPortal, CdkPortalOutlet]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * \\@docs-private\n */\n\n\nvar PortalInjector = /*#__PURE__*/function () {\n  /**\n   * @param {?} _parentInjector\n   * @param {?} _customTokens\n   */\n  function PortalInjector(_parentInjector, _customTokens) {\n    _classCallCheck(this, PortalInjector);\n\n    this._parentInjector = _parentInjector;\n    this._customTokens = _customTokens;\n  }\n  /**\n   * @param {?} token\n   * @param {?=} notFoundValue\n   * @return {?}\n   */\n\n\n  _createClass(PortalInjector, [{\n    key: \"get\",\n    value: function get(token, notFoundValue) {\n      /** @type {?} */\n      var value = this._customTokens.get(token);\n\n      if (typeof value !== 'undefined') {\n        return value;\n      }\n\n      return this._parentInjector.get(token, notFoundValue);\n    }\n  }]);\n\n  return PortalInjector;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nexport { DomPortalOutlet as DomPortalHost, CdkPortalOutlet as PortalHostDirective, CdkPortal as TemplatePortalDirective, BasePortalOutlet as BasePortalHost, Portal, ComponentPortal, TemplatePortal, BasePortalOutlet, DomPortalOutlet, CdkPortal, CdkPortalOutlet, PortalModule, PortalInjector }; //# sourceMappingURL=portal.js.map","map":null,"metadata":{},"sourceType":"module"}